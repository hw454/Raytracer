%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}


% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{DSMRayTracerDoc Documentation}
\date{Jun 24, 2020}
\release{0}
\author{Hayley}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\ifdefined\shorthandoff
  \ifnum\catcode`\=\string=\active\shorthandoff{=}\fi
  \ifnum\catcode`\"=\active\shorthandoff{"}\fi
\fi

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{Main Program}
\label{\detokenize{index:module-RayTracerMainProgram}}\label{\detokenize{index:main-program}}\index{RayTracerMainProgram (module)@\spxentry{RayTracerMainProgram}\spxextra{module}}
Code to trace rays around a room. This code uses:
\begin{itemize}
\item {} 
the function {\hyperref[\detokenize{index:RayTracerMainProgram.RayTracer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{RayTracer()}}}}} to compute the points for   the ray trajectories.

\item {} 
the function {\hyperref[\detokenize{index:RayTracerMainProgram.MeshProgram}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MeshProgram()}}}}} to compute the points for   the ray trajectories and iterate along the rays storing the   information in a {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.DS}}}}} and outputing   the points and mesh.

\item {} 
the function {\hyperref[\detokenize{index:RayTracerMainProgram.power_grid}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{power\_grid()}}}}} which loads the last saved   and loads the antenna and obstacle physical parameters from   {\hyperref[\detokenize{index:ParameterInput.ObstacleCoefficients}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ParameterInput.ObstacleCoefficients()}}}}}. It uses these and   the functions {\hyperref[\detokenize{index:RayTracerMainProgram.RefCoefComputation}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{RefCoefComputation()}}}}} which output Rper   and Rpar the perpendicular and parallel to polarisation reflection   coefficients, and the function {\hyperref[\detokenize{index:RayTracerMainProgram.RefCombine}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{RefCombine()}}}}} to   get the loss from reflection for each ray segment entering each grid   point. This is then combine with the distance of each raysegments   travel from the mesh and the antenna gains to get the Power in   decibels.

\item {} 
The ray points from {\hyperref[\detokenize{index:RayTracerMainProgram.RayTracer}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{RayTracer()}}}}} are saved as:
‘RayPoints\sphinxstylestrong{Nra}Refs\sphinxstylestrong{Nre}n.npy’ with \sphinxstylestrong{Nra} replaced by the     number of rays and \sphinxstylestrong{Nre} replaced by the number of reflections.

\item {} 
The ray points from {\hyperref[\detokenize{index:RayTracerMainProgram.MeshProgram}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{MeshProgram()}}}}} are saved as:
‘RayMeshPoints\sphinxstylestrong{Nra}Refs\sphinxstylestrong{Nre}n.npy’ with \sphinxstylestrong{Nra} replaced     by the     number of rays and \sphinxstylestrong{Nre} replaced by the number of reflections.     The mesh is saved as ‘DSM\sphinxstylestrong{Nra}Refs\sphinxstylestrong{Nre}m.npy’.

\end{itemize}
\index{MeshProgram() (in module RayTracerMainProgram)@\spxentry{MeshProgram()}\spxextra{in module RayTracerMainProgram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:RayTracerMainProgram.MeshProgram}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{RayTracerMainProgram.}}\sphinxbfcode{\sphinxupquote{MeshProgram}}}{\emph{plottype=\textquotesingle{}\textquotesingle{}}}{}
Refect rays and output the Mesh containing ray information.

Parameters for the raytracer are input in {\hyperref[\detokenize{index:module-ParameterInput}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ParameterInput}}}}}
The raytracing parameters defined in this module are saved and then loaded.
\begin{itemize}
\item {} 
‘Raytracing.npy’ \sphinxhyphen{} An array of 4 floats which is saved to   {[}Nra (number of rays), Nre (number of reflections),   h (relative meshwidth),   L (room length scale, the longest axis has been rescaled to 1 and this   is it’s original length){]}

\item {} 
‘Obstacles.npy’  \sphinxhyphen{} An array for 3x3x1 arrays containing co\sphinxhyphen{}ordinates   forming triangles which form the obstacles. This is saved to Oblist   (The obstacles which are within the outerboundary )

\item {} 
‘Origin.npy’     \sphinxhyphen{} A 3x1 array for the co\sphinxhyphen{}ordinate of the source.   This is saved to Tx  (The location of the source antenna and origin   of every ray)

\item {} 
‘OuterBoundary.npy’ \sphinxhyphen{} An array for 3x3x1 arrays containing   co\sphinxhyphen{}ordinates forming triangles which form the obstacles. This is   saved to OuterBoundary   (The Obstacles forming the outer boundary of   the room )

\end{itemize}

Put the two arrays of obstacles into one array

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Oblist}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Oblist}\PYG{p}{,}\PYG{n}{OuterBoundary}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
‘Directions.npy’ \sphinxhyphen{} An Nrax3x1 array containing the vectors which   correspond to the initial direction of each ray. This is save to Direc.

\end{itemize}

A room is initialised with \sphinxstyleemphasis{Oblist} using the py:class:\sphinxtitleref{Room.room}   class in {\hyperref[\detokenize{index:module-Room}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Room}}}}}.

The number of obstacles and the number of x, y and z steps is found

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Nob}\PYG{o}{=}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{Nob}
\PYG{n}{Nx}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{maxxleng}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{Ny}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{maxyleng}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{Nz}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{maxzleng}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{n}{h}\PYG{p}{)}
\end{sphinxVerbatim}

Initialise a \sphinxtitleref{DSM}.   {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.DS}}}}} with the   number of spaces in the x, y and z axis Nx, Ny, Nz, the number of   obstacles Nob, the number of reflections Nre and the number of rays Nra.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Mesh}\PYG{o}{=}\PYG{n}{DSM}\PYG{o}{.}\PYG{n}{DS}\PYG{p}{(}\PYG{n}{Nx}\PYG{p}{,}\PYG{n}{Ny}\PYG{p}{,}\PYG{n}{Nz}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Nob}\PYG{o}{*}\PYG{n}{Nre}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{Nre}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Nra}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Find the reflection points of the rays and store the distance and   reflection angles of the rays in the Mesh. Use the   py:func:\sphinxtitleref{Room.room.ray\_mesh\_bounce} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Rays}\PYG{p}{,} \PYG{n}{Mesh}\PYG{o}{=}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{ray\PYGZus{}mesh\PYGZus{}bounce}\PYG{p}{(}\PYG{n}{Tx}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Nre}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Nra}\PYG{p}{)}\PYG{p}{,}\PYG{n}{Direc}\PYG{p}{,}\PYG{n}{Mesh}\PYG{p}{)}
\end{sphinxVerbatim}

Save the reflection points in Rays to   ‘RayMeshPoints\sphinxstylestrong{Nra}Refs\sphinxstylestrong{Nre}n.npy’ making the   substitution for \sphinxstylestrong{Nra} and \sphinxstylestrong{Nre} with their parameter values.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Mesh

\end{description}\end{quote}

\end{fulllineitems}

\index{Quality() (in module RayTracerMainProgram)@\spxentry{Quality()}\spxextra{in module RayTracerMainProgram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:RayTracerMainProgram.Quality}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{RayTracerMainProgram.}}\sphinxbfcode{\sphinxupquote{Quality}}}{\emph{plottype=\textquotesingle{}\textquotesingle{}}, \emph{Roomnum=0}}{}
Calculate the field on a grid using enviroment parameters and the   ray Mesh.

Loads:
\begin{itemize}
\item {} 
(\sphinxstyleemphasis{Nra}= number of rays, \sphinxstyleemphasis{Nre}= number of reflections,   \sphinxstyleemphasis{h}= meshwidth, \sphinxstyleemphasis{L}= room length scale)=\textasciigrave{}Paramters/Raytracing.npy\textasciigrave{}

\item {} 
(\sphinxstyleemphasis{Nob}=number of obstacles)=\textasciigrave{}Parameters/Nob.npy\textasciigrave{}

\item {} 
(\sphinxstyleemphasis{Gt}=transmitter gains)=\textasciigrave{}Parameters/TxGains.npy\textasciigrave{}

\item {} 
(\sphinxstyleemphasis{freq}= frequency)=\textasciigrave{}Parameters/frequency.npy\textasciigrave{}

\item {} 
(\sphinxstyleemphasis{Freespace}= permittivity, permeabilty   and spead of light)=\textasciigrave{}Parameters/Freespace.npy\textasciigrave{}

\item {} 
(\sphinxstyleemphasis{Znobrat}= Znob/Z0, the ratio of the impedance of obstacles and   the impedance in freespace.) = \sphinxtitleref{Parameters/Znobrat.npy}

\item {} 
(\sphinxstyleemphasis{refindex}= the refractive index of the obstacles)=  Paramerters/refindex.npy\textasciigrave{}

\item {} 
(\sphinxstyleemphasis{Mesh})=\textasciigrave{}DSM\sphinxstylestrong{Nra}Refs\sphinxstylestrong{Nre}m.npy\textasciigrave{}

\end{itemize}

Method:
* Initialise Grid using the number of x, y, and z steps in \sphinxstyleemphasis{Mesh}.
* Use the function \sphinxcode{\sphinxupquote{DictionarySparseMatrix.DS.power\_compute()}}
to compute the power.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
Nx Ny x Nz numpy array of floats.

\item[{Returns}] \leavevmode
Grid

\end{description}\end{quote}

\end{fulllineitems}

\index{RayTracer() (in module RayTracerMainProgram)@\spxentry{RayTracer()}\spxextra{in module RayTracerMainProgram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:RayTracerMainProgram.RayTracer}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{RayTracerMainProgram.}}\sphinxbfcode{\sphinxupquote{RayTracer}}}{}{}
Refect rays and output the points of reflection.

Parameters for the raytracer are input in   {\hyperref[\detokenize{index:ParameterInput.DeclareParameters}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ParameterInput.DeclareParameters()}}}}} The raytracing   parameters defined in this function are saved and then loaded.
\begin{itemize}
\item {} 
‘Raytracing.npy’ \sphinxhyphen{} An array of 4 floats which is saved to   {[}Nra (number of rays), Nre (number of reflections),   h (relative meshwidth),   L (room length scale, the longest axis has been rescaled to 1 and this   is it’s original length){]}

\item {} 
‘Obstacles.npy’  \sphinxhyphen{} An array for 3x3x1 arrays containing co\sphinxhyphen{}ordinates   forming triangles which form the obstacles. This is saved to Oblist   (The obstacles which are within the outerboundary )

\item {} 
‘Origin.npy’     \sphinxhyphen{} A 3x1 array for the co\sphinxhyphen{}ordinate of the source.   This is saved to Tx  (The location of the source antenna and origin   of every ray)

\item {} 
‘OuterBoundary.npy’ \sphinxhyphen{} An array for 3x3x1 arrays containing   co\sphinxhyphen{}ordinates forming triangles which form the obstacles. This is   saved to OuterBoundary   (The Obstacles forming the outer boundary of   the room )

\end{itemize}

Put the two arrays of obstacles into one array

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Oblist}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Oblist}\PYG{p}{,}\PYG{n}{OuterBoundary}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
‘Directions.npy’ \sphinxhyphen{} An Nrax3x1 array containing the vectors which   correspond to the initial direction of each ray. This is save to Direc.

\end{itemize}

A room is initialised with \sphinxstyleemphasis{Oblist} using the \sphinxcode{\sphinxupquote{room}}   class in {\hyperref[\detokenize{index:module-Room}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Room}}}}}.

Find the reflection points of the rays using   \sphinxcode{\sphinxupquote{room.ray\_bounce()}} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Rays}\PYG{p}{,} \PYG{n}{Mesh}\PYG{o}{=}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{ray\PYGZus{}bounce}\PYG{p}{(}\PYG{n}{Tx}\PYG{p}{,}\PYG{n}{Nre}\PYG{p}{,}\PYG{n}{Nra}\PYG{p}{,}\PYG{n}{Direc}\PYG{p}{)}
\end{sphinxVerbatim}

Save the reflection points in Rays to   ‘RayPoints\sphinxstylestrong{Nra}Refs\sphinxstylestrong{Nre}n.npy’ making the   substitution for \sphinxstylestrong{Nra} and \sphinxstylestrong{Nre} with their parameter values.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
0 to mark a successful run

\end{description}\end{quote}

\end{fulllineitems}

\index{RefCoefComputation() (in module RayTracerMainProgram)@\spxentry{RefCoefComputation()}\spxextra{in module RayTracerMainProgram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:RayTracerMainProgram.RefCoefComputation}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{RayTracerMainProgram.}}\sphinxbfcode{\sphinxupquote{RefCoefComputation}}}{\emph{Mesh}, \emph{plottype=\textquotesingle{}\textquotesingle{}}}{}
Compute the mesh of reflection coefficients.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{Mesh}} \textendash{} The DS mesh which contains the angles and distances rays   have travelled.

\end{description}\end{quote}

Load the physical parameters using
{\hyperref[\detokenize{index:ParameterInput.ObstacleCoefficients}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ParameterInput.ObstacleCoefficients()}}}}}
\begin{itemize}
\item {} 
Znobrat \sphinxhyphen{} is the vector of characteristic impedances for obstacles   divided by the characteristic impedance of air.

\item {} 
refindex \sphinxhyphen{} if the vector of refractive indexes for the obstacles.

\end{itemize}

Compute the Reflection coefficients (RefCoefper,Refcoefpar) using:   {\hyperref[\detokenize{index:DictionarySparseMatrix.ref_coef}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.ref\_coef()}}}}}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
({\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.DS}}}}} (Nx,Ny,Nz,na,nb)    , {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.DS}}}}} (Nx,Ny,Nz,na,nb))

\item[{Returns}] \leavevmode
(RefCoefper,Refcoefpar)

\end{description}\end{quote}

\end{fulllineitems}

\index{RefCombine() (in module RayTracerMainProgram)@\spxentry{RefCombine()}\spxextra{in module RayTracerMainProgram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:RayTracerMainProgram.RefCombine}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{RayTracerMainProgram.}}\sphinxbfcode{\sphinxupquote{RefCombine}}}{\emph{Rper}, \emph{Rpar}, \emph{plottype=\textquotesingle{}\textquotesingle{}}}{}
Combine reflection coefficients to get the loss from reflection   coefficient for each ray segment.

Take in the DS’s ({\hyperref[\detokenize{index:module-DictionarySparseMatrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix}}}}}. \sphinxcode{\sphinxupquote{DS}})  corresponding to the reflection coefficients for all the ray   interactions ({\hyperref[\detokenize{index:module-DictionarySparseMatrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix}}}}}. \sphinxcode{\sphinxupquote{ref\_coef(Mesh)()}}).

Use the function {\hyperref[\detokenize{index:module-DictionarySparseMatrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix}}}}}. \sphinxcode{\sphinxupquote{DS}}.   \sphinxcode{\sphinxupquote{dict\_col\_mult()}} to multiple reflection coefficients in the same column.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Combper}\PYG{o}{=}\PYG{p}{[}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{Rper}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{Rper}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{Rper}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{Rper}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{Rper}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{Rper}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}
\PYG{p}{]}
\end{sphinxVerbatim}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Combpar}\PYG{o}{=}\PYG{p}{[}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{Rpar}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{Rpar}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{Rpar}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{Rpar}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{Rpar}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{Rpar}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}
\PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Rper}} \textendash{} The mesh corresponding to reflection coefficients   perpendicular to the polarisation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Rpar}} \textendash{} The mesh corresponding to reflection coefficients   parallel to the polarisation.

\end{itemize}

\item[{Return type}] \leavevmode
({\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.DS}}}}} (Nx,Ny,Nz,1,nb),   {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.DS}}}}} (Nx,Ny,Nz,na,nb))

\item[{Returns}] \leavevmode
Combper, Combpar

\end{description}\end{quote}

\end{fulllineitems}

\index{StdProgram() (in module RayTracerMainProgram)@\spxentry{StdProgram()}\spxextra{in module RayTracerMainProgram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:RayTracerMainProgram.StdProgram}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{RayTracerMainProgram.}}\sphinxbfcode{\sphinxupquote{StdProgram}}}{\emph{plottype}, \emph{index=0}}{}
Refect rays and input object information output the power.

Parameters for the raytracer are input in {\hyperref[\detokenize{index:module-ParameterInput}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{ParameterInput}}}}}
The raytracing parameters defined in this module are saved and then loaded.
\begin{itemize}
\item {} 
‘Raytracing.npy’ \sphinxhyphen{} An array of 4 floats which is saved to   {[}Nra (number of rays), Nre (number of reflections),   h (relative meshwidth),   L (room length scale, the longest axis has been rescaled to 1 and this   is it’s original length){]}

\item {} 
‘Obstacles.npy’  \sphinxhyphen{} An array for 3x3x1 arrays containing co\sphinxhyphen{}ordinates   forming triangles which form the obstacles. This is saved to Oblist   (The obstacles which are within the outerboundary )

\item {} 
‘Origin.npy’     \sphinxhyphen{} A 3x1 array for the co\sphinxhyphen{}ordinate of the source.   This is saved to Tx  (The location of the source antenna and origin   of every ray)

\item {} 
‘OuterBoundary.npy’ \sphinxhyphen{} An array for 3x3x1 arrays containing   co\sphinxhyphen{}ordinates forming triangles which form the obstacles. This is   saved to OuterBoundary   (The Obstacles forming the outer boundary of   the room )

\end{itemize}

Put the two arrays of obstacles into one array

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Oblist}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Oblist}\PYG{p}{,}\PYG{n}{OuterBoundary}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
‘Directions.npy’ \sphinxhyphen{} An Nrax3x1 array containing the vectors which   correspond to the initial direction of each ray. This is save to Direc.

\end{itemize}

A room is initialised with \sphinxstyleemphasis{Oblist} using the py:class:\sphinxtitleref{Room.room}   class in {\hyperref[\detokenize{index:module-Room}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Room}}}}}.

The number of obstacles and the number of x, y and z steps is found

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Nob}\PYG{o}{=}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{Nob}
\PYG{n}{Nx}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{maxxleng}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{Ny}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{maxyleng}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{Nz}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{maxzleng}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{n}{h}\PYG{p}{)}
\end{sphinxVerbatim}

Initialise a \sphinxtitleref{DSM}.   {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.DS}}}}} with the   number of spaces in the x, y and z axis Nx, Ny, Nz, the number of   obstacles Nob, the number of reflections Nre and the number of rays Nra.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Mesh}\PYG{o}{=}\PYG{n}{DSM}\PYG{o}{.}\PYG{n}{DS}\PYG{p}{(}\PYG{n}{Nx}\PYG{p}{,}\PYG{n}{Ny}\PYG{p}{,}\PYG{n}{Nz}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Nob}\PYG{o}{*}\PYG{n}{Nre}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{Nre}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Nra}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{sphinxVerbatim}

Find the reflection points of the rays and store the power Use the   py:func:\sphinxtitleref{Room.room.ray\_mesh\_bounce} function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Rays}\PYG{p}{,} \PYG{n}{Mesh}\PYG{o}{=}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{ray\PYGZus{}mesh\PYGZus{}power\PYGZus{}bounce}\PYG{p}{(}\PYG{n}{Tx}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Nre}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Nra}\PYG{p}{)}\PYG{p}{,}\PYG{n}{Direc}\PYG{p}{,}\PYG{n}{Mesh}\PYG{p}{)}
\end{sphinxVerbatim}

Save the reflection points in Rays to   ‘RayMeshPoints\sphinxstylestrong{Nra}Refs\sphinxstylestrong{Nre}n.npy’ making the   substitution for \sphinxstylestrong{Nra} and \sphinxstylestrong{Nre} with their parameter values.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Mesh

\end{description}\end{quote}

\end{fulllineitems}

\index{plot\_grid() (in module RayTracerMainProgram)@\spxentry{plot\_grid()}\spxextra{in module RayTracerMainProgram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:RayTracerMainProgram.plot_grid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{RayTracerMainProgram.}}\sphinxbfcode{\sphinxupquote{plot\_grid}}}{\emph{plottype=\textquotesingle{}\textquotesingle{}}, \emph{index=0}}{}
Plots slices of a 3D power grid.

Loads \sphinxtitleref{Power\_grid.npy} and for each z step plots a heatmap of the   values at the (x,y) position.

\end{fulllineitems}

\index{power\_grid() (in module RayTracerMainProgram)@\spxentry{power\_grid()}\spxextra{in module RayTracerMainProgram}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:RayTracerMainProgram.power_grid}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{RayTracerMainProgram.}}\sphinxbfcode{\sphinxupquote{power\_grid}}}{\emph{plottype=\textquotesingle{}\textquotesingle{}}, \emph{Roomnum=0}}{}
Calculate the field on a grid using enviroment parameters and the   ray Mesh.

Loads:
\begin{itemize}
\item {} 
(\sphinxstyleemphasis{Nra}= number of rays, \sphinxstyleemphasis{Nre}= number of reflections,   \sphinxstyleemphasis{h}= meshwidth, \sphinxstyleemphasis{L}= room length scale)=\textasciigrave{}Paramters/Raytracing.npy\textasciigrave{}

\item {} 
(\sphinxstyleemphasis{Nob}=number of obstacles)=\textasciigrave{}Parameters/Nob.npy\textasciigrave{}

\item {} 
(\sphinxstyleemphasis{Gt}=transmitter gains)=\textasciigrave{}Parameters/TxGains.npy\textasciigrave{}

\item {} 
(\sphinxstyleemphasis{freq}= frequency)=\textasciigrave{}Parameters/frequency.npy\textasciigrave{}

\item {} 
(\sphinxstyleemphasis{Freespace}= permittivity, permeabilty   and spead of light)=\textasciigrave{}Parameters/Freespace.npy\textasciigrave{}

\item {} 
(\sphinxstyleemphasis{Znobrat}= Znob/Z0, the ratio of the impedance of obstacles and   the impedance in freespace.) = \sphinxtitleref{Parameters/Znobrat.npy}

\item {} 
(\sphinxstyleemphasis{refindex}= the refractive index of the obstacles)=  Paramerters/refindex.npy\textasciigrave{}

\item {} 
(\sphinxstyleemphasis{Mesh})=\textasciigrave{}DSM\sphinxstylestrong{Nra}Refs\sphinxstylestrong{Nre}m.npy\textasciigrave{}

\end{itemize}

Method:
* Initialise Grid using the number of x, y, and z steps in \sphinxstyleemphasis{Mesh}.
* Use the function \sphinxcode{\sphinxupquote{DictionarySparseMatrix.DS.power\_compute()}}
to compute the power.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
Nx Ny x Nz numpy array of floats.

\item[{Returns}] \leavevmode
Grid

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Input of the parameters}
\label{\detokenize{index:module-ParameterInput}}\label{\detokenize{index:input-of-the-parameters}}\index{ParameterInput (module)@\spxentry{ParameterInput}\spxextra{module}}
The code saves the values for the parameters in a ray tracer
\index{BoxBuild() (in module ParameterInput)@\spxentry{BoxBuild()}\spxextra{in module ParameterInput}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:ParameterInput.BoxBuild}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ParameterInput.}}\sphinxbfcode{\sphinxupquote{BoxBuild}}}{\emph{xmi}, \emph{xma}, \emph{ymi}, \emph{yma}, \emph{zmi}, \emph{zma}}{}
Input the inimum and maximum x,y, and z co\sphinxhyphen{}ordinates which will form a Box.
:param xmi: The minimum x co\sphinxhyphen{}ordinate.
:param xma: The maximum x co\sphinxhyphen{}ordinate.
:param ymi:The minimum y co\sphinxhyphen{}ordinate.
:param yma: The maximum y co\sphinxhyphen{}ordinate.
:param zmi: The minimum z co\sphinxhyphen{}ordinate.
:param zma: The maximum z co\sphinxhyphen{}ordinate.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Box}\PYG{o}{=}\PYG{p}{[}\PYG{n}{T0}\PYG{p}{,}\PYG{n}{T1}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{n}{T12}\PYG{p}{]}
\PYG{n}{TJ}\PYG{o}{=}\PYG{p}{[}\PYG{n}{p0J}\PYG{p}{,}\PYG{n}{p1J}\PYG{p}{,}\PYG{n}{p2J}\PYG{p}{]}
\PYG{n}{p0J}\PYG{o}{=}\PYG{p}{[}\PYG{n}{x0J}\PYG{p}{,}\PYG{n}{y0J}\PYG{p}{,}\PYG{n}{z0J}\PYG{p}{]}
\PYG{n}{p1J}\PYG{o}{=}\PYG{p}{[}\PYG{n}{x1J}\PYG{p}{,}\PYG{n}{y1J}\PYG{p}{,}\PYG{n}{z1J}\PYG{p}{]}
\PYG{n}{p2J}\PYG{o}{=}\PYG{p}{[}\PYG{n}{x2J}\PYG{p}{,}\PYG{n}{y2J}\PYG{p}{,}\PYG{n}{x2J}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
12 x 3 x 3 numpy array.

\item[{Returns}] \leavevmode
Box

\end{description}\end{quote}

\end{fulllineitems}

\index{DeclareParameters() (in module ParameterInput)@\spxentry{DeclareParameters()}\spxextra{in module ParameterInput}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:ParameterInput.DeclareParameters}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ParameterInput.}}\sphinxbfcode{\sphinxupquote{DeclareParameters}}}{}{}
All input parameters for the ray\sphinxhyphen{}launching method are entered in
this function which will then save them inside a Parameters folder.
\begin{itemize}
\item {} 
Nra \sphinxhyphen{} Number of rays

\begin{sphinxadmonition}{note}{Note:}
Due to need of integer steps the input number of rays can not
always be used if everything is equally spaced.
\end{sphinxadmonition}

\item {} 
Nre \sphinxhyphen{} Number of reflections

\item {} 
Ns \sphinxhyphen{} Number of steps to split longest axis.

\item {} 
l1 \sphinxhyphen{} Interior obstacle scale

\item {} 
l2 \sphinxhyphen{} Boundary scale.

\item {} 
triangle1 \sphinxhyphen{} First interior obstacle

\item {} 
…

\item {} 
triangleN \sphinxhyphen{} Last interior obstacle

\item {} 
OuterBoundary1 \sphinxhyphen{} First obstacle forming the boundary of the   environment

\item {} 
…

\item {} 
OuterBoundaryN \sphinxhyphen{} Last obstacle forming the boundary of the   environment.

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
0 if successfully completed.

\end{description}\end{quote}

\end{fulllineitems}

\index{ObstacleCoefficients() (in module ParameterInput)@\spxentry{ObstacleCoefficients()}\spxextra{in module ParameterInput}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:ParameterInput.ObstacleCoefficients}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ParameterInput.}}\sphinxbfcode{\sphinxupquote{ObstacleCoefficients}}}{\emph{index=0}}{}
Input the paramters for obstacles and the antenna. To ensure   arrays are of the right length for compatibility for the   ray\sphinxhyphen{}launcher retrieve the ray\sphinxhyphen{}launching parameters in   {\hyperref[\detokenize{index:ParameterInput.DeclareParameters}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DeclareParameters()}}}}}

Load:
\begin{itemize}
\item {} 
‘Obstacles.npy’     \sphinxhyphen{}Co\sphinxhyphen{}ordinates of obstacles in the room

\item {} 
‘OuterBoundary.npy’ \sphinxhyphen{} Co\sphinxhyphen{}ordinates of the walls of the room

\item {} 
‘Raytracing.npy’    \sphinxhyphen{}{[}Nra (number of rays), Nre (number of reflections),   h (relative meshwidth){]}

\end{itemize}

Calculate:
\begin{itemize}
\item {} 
Nob=len({[}Obstacles,OuterBoundary{]})

\end{itemize}

Input:
\begin{itemize}
\item {} 
\sphinxtitleref{Freespace} \sphinxhyphen{}{[}mu0 (permeability of air),   eps0 (permittivity of air),Z0 (characteristic impedance of air),   c (speed of light){]}

\item {} 
\sphinxtitleref{frequency} \sphinxhyphen{} \(\omega\) angular frequency of the wave out   the antenna.

\item {} 
\sphinxtitleref{mur}       \sphinxhyphen{} \(\mu_r\) The relative permeability for all obstacles.   This should be an array with the same number of terms as the number   of obstacles Nob.

\item {} 
\sphinxtitleref{epsr}     \sphinxhyphen{} \(\epsilon_r\) The relative permittivity for each obstacle.   This should be an array with the same number of terms as the number   of obstacles Nob.

\item {} 
\sphinxtitleref{sigma}     \sphinxhyphen{} \(\sigma\) The electrical conductivity of the obstacles.   This should be an array with the same number of terms as the number   of obstacles.

\item {} 
\sphinxtitleref{Gt}        \sphinxhyphen{} The gains of the antenna. The should be an array with   the same number of terms as the number of rays Nra.

\end{itemize}

Calculate:
\begin{itemize}
\item {} 
\sphinxtitleref{eps0}   \sphinxhyphen{} \(\epsilon_0=\frac{1}{\mu_0 c^2}\)  permittivity of   freespace.

\item {} 
\sphinxtitleref{Z0}     \sphinxhyphen{} \(Z_0=\sqrt{\frac{\mu_0}{\epsilon_0}}\) characteristic   impedance of freespace.

\item {} 
\sphinxtitleref{refindex} \sphinxhyphen{} The refreactive index   \(n=\sqrt{\mu_r\epsilon_r}\)

\item {} 
\sphinxtitleref{Znobrat}\sphinxhyphen{} The relative impedance of the obstacles given by,
\(\hat{Z}_{Nob}=\frac{Z_{Nob}}{Z_0}\). The impedance of each     obstacle \(Z_{Nob}\) is given by     \(Z_{Nob}=\sqrt{\frac{i\omega\mu_0\mu_r}{\sigma+i\epsilon_0\epsilon_r}}\).

\end{itemize}

The Znobrat and refindex terms are then reformatted so that they   repeat Nre times with an extra term. The extra term corresponds to   the line of sight path. This makes them the same length as a column   in a matrix in a {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.DS}}}}}.   Each term corresponds to a possible obstacle reflection combination.

The Gains matrix is also reformated to that it repeats (Nre+1) times.   This corresponds to every possible ray reflection number combination   This makes them the same length as a row in a matrix in a   {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.DS}}}}}.   Each term corresponds to a possible obstacle reflection combination.

Save:
* \sphinxtitleref{frequency.npy}\sphinxhyphen{} The angular frequency \(\omega\).
* \sphinxtitleref{refindex.npy} \sphinxhyphen{} The refractive index of the obstacles.
* \sphinxtitleref{Znobrat.npy}  \sphinxhyphen{} The relative characteristic impedance.
* \sphinxtitleref{TxGains.npy}  \sphinxhyphen{} The gains of the antenna.
* \sphinxtitleref{Freespace.npy}\sphinxhyphen{} The freespace parameters.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Freespace}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mu0}\PYG{p}{,}\PYG{n}{eps0}\PYG{p}{,}\PYG{n}{Z0}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
0 if successfully completed.

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Rays}
\label{\detokenize{index:module-Rays}}\label{\detokenize{index:rays}}\index{Rays (module)@\spxentry{Rays}\spxextra{module}}
Code to construct the ray\sphinxhyphen{}tracing objects rays
\index{Ray (class in Rays)@\spxentry{Ray}\spxextra{class in Rays}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Rays.Ray}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Rays.}}\sphinxbfcode{\sphinxupquote{Ray}}}{\emph{origin}, \emph{direc}}{}
A ray is a representation of the the trajectory of a reflecting   line and its reflections.
Ray.points is an array of co\sphinxhyphen{}ordinates representing
the collision points with the last term being the direction the ray ended in.
And Ray.reflections is an array containing tuples of the angles of incidence
and the number referring to the position of the obstacle in the obstacle list
\index{mesh\_multiref() (Rays.Ray method)@\spxentry{mesh\_multiref()}\spxextra{Rays.Ray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Rays.Ray.mesh_multiref}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mesh\_multiref}}}{\emph{room}, \emph{Nre}, \emph{Mesh}, \emph{Nra}, \emph{nra}, \emph{deltheta}}{}
Takes a ray and finds the first Nre reflections within a room.
As each reflection is found the ray is stepped through and
information added to the Mesh.
:param room: Obstacle co\sphinxhyphen{}ordinates, {\hyperref[\detokenize{index:module-Room}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Room}}}}}. \sphinxcode{\sphinxupquote{room}}.
:param Nre: Number of reflections, integer.
:param Mesh: A grid with corresponding sparse matrices, this     is a {\hyperref[\detokenize{index:module-DictionarySparseMatrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix}}}}}. \sphinxcode{\sphinxupquote{DS}} object.
:param Nra: Total number of rays, integer.

Method:
\begin{itemize}
\item {} 
Create a temporary vector vec.

\item {} 
For each ray segment use     \sphinxcode{\sphinxupquote{mesh\_singleray(room,Mesh,dist,vec,Nra,Nre,nra)()}} to      segment storing r*calcvec in the Mesh. With r being the distance      ray travelled to get  centre of the grid point the ray has gone      through.

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Mesh

\end{description}\end{quote}

\end{fulllineitems}

\index{mesh\_power\_multiref() (Rays.Ray method)@\spxentry{mesh\_power\_multiref()}\spxextra{Rays.Ray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Rays.Ray.mesh_power_multiref}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mesh\_power\_multiref}}}{\emph{room}, \emph{Nre}, \emph{Mesh}, \emph{Nra}, \emph{it}, \emph{Znobrat}, \emph{refindex}, \emph{Antpar}, \emph{refcoef}, \emph{deltheta}}{}
Takes a ray and finds the first Nre reflections within a room.
As each reflection is found the ray is stepped through and
information added to the Mesh.
:param room: Obstacle co\sphinxhyphen{}ordinates, {\hyperref[\detokenize{index:module-Room}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Room}}}}}. \sphinxcode{\sphinxupquote{room}}.
:param Nre: Number of reflections, integer.
:param Grid: a Nx*Ny*Nz array which will contain power values
:param Nra: total number of rays.
:param it: current ray number.
:param Znobrat: The array with the ratio of the impedance of an     obstacle over the impedance of air.
:param refindex: Array with the refractive indices of an obstacle.
:param Antpar: array with antenna parameters \sphinxhyphen{} scaled wavenumber, wavelength, lengthscale.
:param Gt: transmitter gains.

Method:
\begin{itemize}
\item {} 
Start with the initial power.

\item {} 
For each ray segment use     \sphinxcode{\sphinxupquote{mesh\_power\_singleray(room,Mesh,dist,vec,Nra,Nre,nra)()}} to      store the power along the ray.

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
grid

\end{description}\end{quote}

\end{fulllineitems}

\index{mesh\_power\_singleray() (Rays.Ray method)@\spxentry{mesh\_power\_singleray()}\spxextra{Rays.Ray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Rays.Ray.mesh_power_singleray}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mesh\_power\_singleray}}}{\emph{room}, \emph{\_Grid}, \emph{dist}, \emph{RefCoef}, \emph{Nra}, \emph{nre}, \emph{Nre}, \emph{nra}, \emph{refindex}, \emph{Znobrat}, \emph{khat}, \emph{L}, \emph{deltheta}}{}
Iterate between two intersection points and store the ray     information in the Mesh
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{room}} \textendash{} {\hyperref[\detokenize{index:module-Room}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Room}}}}}. \sphinxcode{\sphinxupquote{room}} object which     contains the co\sphinxhyphen{}ordinates of the obstacles.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Grid}} \textendash{} {\hyperref[\detokenize{index:module-DictionarySparseMatrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix}}}}}. \sphinxcode{\sphinxupquote{DS}}     which will store the field in the parallel and perdenicular to     polarisation components at each \((x,y,z)\) position.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dist}} \textendash{} A scalar variable which is the distance the ray     travelled at the start of the ray segment.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{RefCoef}} \textendash{} A vector containing the product of the reflection     coefficients in the perpendicular and parallel directions to the     polarisation.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nra}} \textendash{} Total number of rays.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nre}} \textendash{} Maximum number of reflections.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nra}} \textendash{} Current ray number.

\end{itemize}

\end{description}\end{quote}

Method:
\begin{itemize}
\item {} 
Calculate \(\theta\) the reflection angle using     \sphinxcode{\sphinxupquote{reflect\_angle(room)()}}.

\item {} 
Find the number of steps \(Ns\) to the end of the ray segment     using \sphinxcode{\sphinxupquote{number\_steps(meshwidth)()}}.

\item {} 
Compute an array of normal vectors representing the ray cone.

\item {} 
Check the reflection number:
\begin{itemize}
\item {} 
If 0 then the \(RefCoef\) term is 1.

\item {} 
Else set \(RefCoef\)

\end{itemize}

\item {} 
Step along the ray, For \(m1\in[0,Ns):\)
\begin{itemize}
\item {} 
Check if the ray point is outside the domain.

\item {} 
Calculate the co\sphinxhyphen{}ordinate of the centre.

\item {} 
Recalculate distance to be for the centre point       \(Mesh[i1,j1,k1,:,col]=np.sqrt(np.dot((p0-p2),(p0-p2)))*calcvec\).

\item {} 
For each normal:
\begin{itemize}
\item {} 
Find the next cone point \(p3\) from the previous point         \(p1\), using the distance through a grid cube         \(\alpha\). This is given by:math:\sphinxtitleref{p3=p1+m2*alpha*norm}.

\item {} 
Find the co\sphinxhyphen{}ordinate for the centre of the grid point z         corresponding to the \(p3\)’s.

\item {} 
Find the distance to this centre point.

\item {} 
Set the column \(nra*Nre+nre\) of the mesh term at         these grid points to the distance times the vector of         reflection angles.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Grid}\PYG{p}{[}\PYG{n}{cpos}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cpos}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cpos}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{e}\PYG{o}{\PYGZca{}}\PYG{p}{\PYGZob{}}\PYG{n}{ikr}\PYG{p}{\PYGZcb{}}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{n}{r2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{)}\PYG{o}{*}\PYG{n}{RefCoef}
\end{sphinxVerbatim}

\item {} 
Find the co\sphinxhyphen{}ordinate for the next ray point.       \(p1=p1+alpha*direc\).

\end{itemize}

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Mesh, dist, calcvec

\end{description}\end{quote}

\end{fulllineitems}

\index{mesh\_singleray() (Rays.Ray method)@\spxentry{mesh\_singleray()}\spxextra{Rays.Ray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Rays.Ray.mesh_singleray}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{mesh\_singleray}}}{\emph{room}, \emph{Mesh}, \emph{dist}, \emph{calcvec}, \emph{Nra}, \emph{Nre}, \emph{nra}, \emph{deltheta}}{}
Iterate between two intersection points and store the ray     information in the Mesh
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{room}} \textendash{} {\hyperref[\detokenize{index:module-Room}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Room}}}}}. \sphinxcode{\sphinxupquote{room}} object which     contains the co\sphinxhyphen{}ordinates of the obstacles.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Mesh}} \textendash{} {\hyperref[\detokenize{index:module-DictionarySparseMatrix}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DictionarySparseMatrix}}}}}. \sphinxcode{\sphinxupquote{DS}}     which will store all of the ray information.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{dist}} \textendash{} A scalar variable which is the distance the ray     travelled at the start of the ray segment.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{calcvec}} \textendash{} A vector containing \(e^{i     heta}\) terms     for reflection angles :math:\textasciigrave{}  heta\textasciigrave{}. These terms are stored     in row nre*Nob+nob with nre being the current reflection number,     Nob the maximum obstacle number and nob the number of the     obstacle which was hit with the corresponding angle.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nra}} \textendash{} Total number of rays.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nre}} \textendash{} Maximum number of reflections.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nra}} \textendash{} Current ray number.

\end{itemize}

\end{description}\end{quote}

Method:
\begin{itemize}
\item {} 
Calculate \(\theta\) the reflection angle using     \sphinxcode{\sphinxupquote{reflect\_angle(room)()}}.

\item {} 
Find the number of steps \(Ns\) to the end of the ray segment     using \sphinxcode{\sphinxupquote{number\_steps(meshwidth)()}}.

\item {} 
Compute an array of normal vectors representing the ray cone.

\item {} 
Check the reflection number:
\begin{itemize}
\item {} 
If 0 then the \(calcvec[0]\) term is exp(1j*pi*0.5).

\item {} 
Else set \(calcvec[nre*Nob+nob]=e^{i \theta}\).

\end{itemize}

\item {} 
Step along the ray, For \(m1\in[0,Ns):\)
\begin{itemize}
\item {} 
Check if the ray point is outside the domain.

\item {} 
Calculate the co\sphinxhyphen{}ordinate of the centre.

\item {} 
Recalculate distance to be for the centre point       \(Mesh[i1,j1,k1,:,col]=np.sqrt(np.dot((p0-p2),(p0-p2)))*calcvec\).

\item {} 
For each normal:
\begin{itemize}
\item {} 
Find the next cone point \(p3\) from the previous point         \(p1\), using the distance through a grid cube         \(\alpha\). This is given by:math:\sphinxtitleref{p3=p1+m2*alpha*norm}.

\item {} 
Find the co\sphinxhyphen{}ordinate for the centre of the grid point z         corresponding to the \(p3\)’s.

\item {} 
Find the distance to this centre point.

\item {} 
Set the column \(nra*Nre+nre\) of the mesh term at         these grid points to the distance times the vector of         reflection angles.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Mesh}\PYG{p}{[}\PYG{n}{cpos}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cpos}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cpos}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]}\PYG{o}{=}\PYG{n}{r2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{calcvec}
\end{sphinxVerbatim}

\item {} 
Find the co\sphinxhyphen{}ordinate for the next ray point.       \(p1=p1+alpha*direc\).

\end{itemize}

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Mesh, dist, calcvec

\end{description}\end{quote}

\end{fulllineitems}

\index{multiref() (Rays.Ray method)@\spxentry{multiref()}\spxextra{Rays.Ray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Rays.Ray.multiref}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{multiref}}}{\emph{room}, \emph{Nre}}{}
Takes a ray and finds the first five reflections within a room.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{room}} \textendash{} {\hyperref[\detokenize{index:Room.room}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Room.room}}}}} object which     contains all the obstacles in the room.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nre}} \textendash{} The number of reflections. Integer value.

\end{itemize}

\end{description}\end{quote}

Using the function \sphinxcode{\sphinxupquote{reflect\_calc(room)()}} find the     co\sphinxhyphen{}ordinate of the reflected ray. Store this in s.points     and return whether the function was successful.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
3x1 numpy array.

\item[{Returns}] \leavevmode
end=1 if unsuccessful, 0 is successful.

\end{description}\end{quote}

\end{fulllineitems}

\index{raytest() (Rays.Ray method)@\spxentry{raytest()}\spxextra{Rays.Ray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Rays.Ray.raytest}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{raytest}}}{\emph{room}, \emph{err}}{}
Checks the reflection function for errors using the test     functions in {\hyperref[\detokenize{index:module-reflection}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{reflection}}}}}.

\end{fulllineitems}

\index{reflect\_calc() (Rays.Ray method)@\spxentry{reflect\_calc()}\spxextra{Rays.Ray method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Rays.Ray.reflect_calc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{reflect\_calc}}}{\emph{room}}{}
Finds the reflection of the ray inside a room.

Method:
\begin{itemize}
\item {} 
If: the previous collision point was \sphinxstyleemphasis{None} then don’t find the     next one. Return: 1

\item {} 
Else: Compute the next collision point,
\begin{itemize}
\item {} 
If: the collision point doesn’t exist. Return: 1

\item {} 
Else:  save the collision point in the {\hyperref[\detokenize{index:Rays.Ray}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{Ray}}}}} points.       Return: 0

\end{itemize}

\end{itemize}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
0 or 1 indicator of success.

\item[{Returns}] \leavevmode
0 if  reflection was computed 1 if not.

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{no\_cone\_steps() (in module Rays)@\spxentry{no\_cone\_steps()}\spxextra{in module Rays}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Rays.no_cone_steps}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Rays.}}\sphinxbfcode{\sphinxupquote{no\_cone\_steps}}}{\emph{h}, \emph{dist}, \emph{delangle}}{}
find the number of steps taken along one normal in the cone

\end{fulllineitems}

\index{no\_cones() (in module Rays)@\spxentry{no\_cones()}\spxextra{in module Rays}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Rays.no_cones}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Rays.}}\sphinxbfcode{\sphinxupquote{no\_cones}}}{\emph{h}, \emph{dist}, \emph{delangle}, \emph{refangle}, \emph{nref}}{}
find the number of steps taken along one normal in the cone

\end{fulllineitems}

\index{no\_steps() (in module Rays)@\spxentry{no\_steps()}\spxextra{in module Rays}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Rays.no_steps}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Rays.}}\sphinxbfcode{\sphinxupquote{no\_steps}}}{\emph{alpha}, \emph{segleng}, \emph{dist}, \emph{delangle}, \emph{refangle=0.0}}{}
The number of steps along the ray between intersection points

\end{fulllineitems}

\index{singleray\_test() (in module Rays)@\spxentry{singleray\_test()}\spxextra{in module Rays}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Rays.singleray_test}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{Rays.}}\sphinxbfcode{\sphinxupquote{singleray\_test}}}{}{}
Test the stepping through a single ray.

\end{fulllineitems}



\chapter{Room}
\label{\detokenize{index:module-Room}}\label{\detokenize{index:room}}\index{Room (module)@\spxentry{Room}\spxextra{module}}
Code to construct the mesh of the room
\index{room (class in Room)@\spxentry{room}\spxextra{class in Room}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Room.room}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{Room.}}\sphinxbfcode{\sphinxupquote{room}}}{\emph{obst}}{}
A room is where the obstacle co\sphinxhyphen{}ordinates are contained.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{obst}} \textendash{} is a Nobx3x{[}3x1{]} array, where Nob is the number of     obstacles.

\end{description}\end{quote}

obst{[}j{]} is a 3x{[}3x1{]} array which is 3, 3D co\sphinxhyphen{}ordinates   which form a triangle.

This array of triangles forms the obstacles in the room.
\begin{description}
\item[{Attributes of room:}] \leavevmode\begin{itemize}
\item {} 
s.obst=obst

\item {} 
.points{[}3*j{]}=obst{[}j{]}{[}0{]}

\item {} 
s.maxlength is a 4x1 array initialised as empty. Once assigned     this is the maximum length in theroom and in the x, y, and z axis.

\item {} 
s.bounds is a 3x2 array     \(s.bounds= [ [minx, miny, minz], [maxx,maxy,maxz]]\)

\item {} 
s.inside\_points is an initial empty array. Points which are known     to be inside obstacles are added to this array later.

\item {} 
s.time is an array with the time the room was created.

\item {} 
s.meshwidth is initialised as zero but is stored once asked for     using get\_meshwidth.

\end{itemize}

\end{description}
\index{coordinate() (Room.room method)@\spxentry{coordinate()}\spxextra{Room.room method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Room.room.coordinate}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{coordinate}}}{\emph{h}, \emph{i}, \emph{j}, \emph{k}}{}
Find the co\sphinxhyphen{}ordinate of the point at the centre of the element.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} \textendash{} the meshwdith. Once assigned this matches s.meshwidth

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{i}} \textendash{} the first index or an array corresponding to the first     index for multiple points.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{j}} \textendash{} the second index or an array corresponding to the second     index for multiple points.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} the third index or an array corresponding to the third     index for multiple points.

\end{itemize}

\end{description}\end{quote}

If there is only 1 i, 1 j, and 1 k,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p}\PYG{o}{=}\PYG{p}{[}\PYG{n}{minx}\PYG{p}{,}\PYG{n}{miny}\PYG{p}{,}\PYG{n}{minz}\PYG{p}{]} \PYG{o}{+}\PYG{n}{h}\PYG{o}{*}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{]}
\end{sphinxVerbatim}

ElseIf there’s arrays for i,j, and k,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{p}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{n}{minx}\PYG{p}{,}\PYG{n}{miny}\PYG{p}{,}\PYG{n}{minz}\PYG{p}{]} \PYG{o}{+}\PYG{n}{h}\PYG{o}{*}\PYG{p}{[}\PYG{n}{i0}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{j0}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{k0}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
  \PYG{p}{[}\PYG{n}{minx}\PYG{p}{,}\PYG{n}{miny}\PYG{p}{,}\PYG{n}{minz}\PYG{p}{]} \PYG{o}{+}\PYG{n}{h}\PYG{o}{*}\PYG{p}{[}\PYG{o+ow}{in}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{jn}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{kn}\PYG{o}{+}\PYG{l+m+mf}{0.5} \PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
p

\end{description}\end{quote}

\end{fulllineitems}

\index{maxleng() (Room.room method)@\spxentry{maxleng()}\spxextra{Room.room method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Room.room.maxleng}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{maxleng}}}{\emph{a=0}}{}
Get the maximum length in the room or axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{a}} \textendash{} the axis or room. a=0 maximum length in room, a=1 for     x\sphinxhyphen{}axis, a=2 for y\sphinxhyphen{}axis a=3 for z\sphinxhyphen{}axis.

\end{description}\end{quote}

If the maxlength{[}a{]} hasn’t been found yet find it by comparing the     between points in s.points.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
s.maxlength{[}a{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{position() (Room.room method)@\spxentry{position()}\spxextra{Room.room method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Room.room.position}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{position}}}{\emph{p}, \emph{h}}{}
Find the indexing position in a mesh with width h for point p     lying in the room s.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p}} \textendash{} ={[}x,y,z{]} the co\sphinxhyphen{}ordinate of the point p or an array     of \(points p=[[x0,y0,z0],...,[xn,yn,zn]]\)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} \textendash{} is the meshwidth, once assigned this matches s.meshwidth

\end{itemize}

\end{description}\end{quote}

If p is one point,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{o}{=}\PYG{p}{(}\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{p}{[}\PYG{n}{minx}\PYG{p}{,}\PYG{n}{miny}\PYG{p}{,}\PYG{n}{minz}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{n}{h}\PYG{p}{,}
\end{sphinxVerbatim}

If p is an array of points,

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{o}{=}\PYG{p}{[}\PYG{p}{(}\PYG{n}{p0}\PYG{o}{\PYGZhy{}}\PYG{p}{[}\PYG{n}{minx}\PYG{p}{,}\PYG{n}{miny}\PYG{p}{,}\PYG{n}{minz}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{n}{h}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}\PYG{p}{(}\PYG{n}{pn}\PYG{o}{\PYGZhy{}}\PYG{p}{[}\PYG{n}{minx}\PYG{p}{,}\PYG{n}{miny}\PYG{p}{,}\PYG{n}{minz}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{n}{h}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{ray\_bounce() (Room.room method)@\spxentry{ray\_bounce()}\spxextra{Room.room method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Room.room.ray_bounce}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ray\_bounce}}}{\emph{Tx}, \emph{Nre}, \emph{Nra}, \emph{directions}}{}
Trace ray’s uniformly emitted from an origin around a room.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nra}} \textendash{} Number of rays

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nre}} \textendash{} number of reflections Nre

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{directions}} \textendash{} A Nra*3 array of the initial directions     for each ray.

\end{itemize}

\end{description}\end{quote}

The multiref function is used to find the Nre reflections for     the Nra rays with the obstacles s.obst.

\(raylist=[[p00,p01,...,p0Nre],[p10,...,p1Nre],...,[pNra0,...,pNraNre]]\)
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
An array of the ray points.

\item[{Returns}] \leavevmode
raylist

\end{description}\end{quote}

\end{fulllineitems}

\index{ray\_mesh\_bounce() (Room.room method)@\spxentry{ray\_mesh\_bounce()}\spxextra{Room.room method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Room.room.ray_mesh_bounce}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ray\_mesh\_bounce}}}{\emph{Tx}, \emph{Nre}, \emph{Nra}, \emph{directions}, \emph{Mesh}, \emph{deltheta}}{}
Traces ray’s uniformly emitted from an origin around a room.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Tx}} \textendash{} the co\sphinxhyphen{}ordinate of the transmitter location

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nra}} \textendash{} Number of rays

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nre}} \textendash{} number of reflections

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{directions}} \textendash{} Nra*3 array of the initial direction for     each ray.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Mesh}} \textendash{} a Nx*Ny*Nz*na*nb array (actually a dictionary of     sparse matrices using class DS but built to have similar     structure to an array).

\end{itemize}

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{na}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Nob}\PYG{o}{*}\PYG{n}{Nre}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nb}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{Nre}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Nra}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{sphinxVerbatim}

The rays are reflected Nre times with the obstacles s.obst.     The points of intersection with the obstacles are stored in z
raylist. This is done using the mesh\_multiref function.
As each intersection is found the mesh\_multiref function     forms the line segment between intersection points and the     corresponding ray cone. All mesh elements in the ray cone store     the reflection angles and the distance along the ray cone from the     source to the centre of each mesh element. This is stored in Mesh.
See \sphinxcode{\sphinxupquote{Rays.mesh\_multiref()}} for more details on the     reflections and storage.

When complete the time in s.time() is assigned to the time taken     to complete the function.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
raylist, Mesh

\end{description}\end{quote}

\end{fulllineitems}

\index{ray\_mesh\_power\_bounce() (Room.room method)@\spxentry{ray\_mesh\_power\_bounce()}\spxextra{Room.room method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:Room.room.ray_mesh_power_bounce}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{ray\_mesh\_power\_bounce}}}{\emph{Tx}, \emph{Nre}, \emph{Nra}, \emph{directions}, \emph{Grid}, \emph{Znobrat}, \emph{refindex}, \emph{Antpar}, \emph{Gt}, \emph{Pol}, \emph{deltheta}}{}
Traces ray’s uniformly emitted from an origin around a room.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Tx}} \textendash{} the co\sphinxhyphen{}ordinate of the transmitter location

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nra}} \textendash{} Number of rays

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nre}} \textendash{} number of reflections

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{directions}} \textendash{} Nra*3 array of the initial direction for     each ray.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Grid}} \textendash{} a Nx*Ny*Nz array which will contain power values

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Znobrat}} \textendash{} The array with the ratio of the impedance of an     obstacle over the impedance of air.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{refindex}} \textendash{} Array with the refractive indices of an obstacle.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Antpar}} \textendash{} array with antenna parameters \sphinxhyphen{} scaled wavenumber, wavelength, lengthscale.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Gt}} \textendash{} transmitter gains.

\end{itemize}

\end{description}\end{quote}

The rays are reflected Nre times with the obstacles s.obst.     The points of intersection with the obstacles are stored in z
raylist. This is done using the mesh\_multiref function.
As each intersection is found the mesh\_multiref function     forms the line segment between intersection points and the     corresponding ray cone. All mesh elements in the ray cone store     the power. This is stored in Grid.
See \sphinxcode{\sphinxupquote{Rays.mesh\_multiref()}} for more details on the     reflections and storage.

When complete the time in s.time() is assigned to the time taken     to complete the function.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
raylist, Grid

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Mesh}
\label{\detokenize{index:module-DictionarySparseMatrix}}\label{\detokenize{index:mesh}}\index{DictionarySparseMatrix (module)@\spxentry{DictionarySparseMatrix}\spxextra{module}}
Code for the dictionary of sparse matrices class {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}} which indexes like a multidimensional array but the array is sparse.  To exploit \sphinxcode{\sphinxupquote{scipy.sparse.dok\_matrix\textasciigrave{}=SM the \textasciigrave{}DS}} uses a key for  each x,y, z position and associates a SM.

This module also contains functions which are not part of the class  but act on it.
\index{DS (class in DictionarySparseMatrix)@\spxentry{DS}\spxextra{class in DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{DS}}}{\emph{Nx=1}, \emph{Ny=1}, \emph{Nz=1}, \emph{na=1}, \emph{nb=1}, \emph{dt=\textless{}class \textquotesingle{}numpy.complex128\textquotesingle{}\textgreater{}}}{}
The DS class is a dictionary of sparse matrices.
The keys for the dictionary are (i,j,k) such that i is in {[}0,Nx{]},
j is in {[}0, Ny{]}, and k is in {[}0,Nz{]}.
SM=DS{[}x,y,z{]} is a na*nb sparse matrix, initialised with complex128 data type.
\(na=(Nob*Nre+1)\)
\(nb=((Nre)*(Nra)+1)\)
The DS is initialised with keys Nx, Ny, and Nz to a dictionary with   keys,
\(\{ (x,y,z) \forall x \in [0,Nx), y \in [0,Ny), z \in [0,Nz)\}.\)

With the value at each key being an na*nb SM.
\index{asin() (DictionarySparseMatrix.DS method)@\spxentry{asin()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.asin}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{asin}}}{\emph{ind=\sphinxhyphen{}1}}{}
Finds

\(\theta=\arcsin(x)\) for all terms \(x != 0\) in     the DS s. Since all angles     \(\theta\) are in \([0,\pi /2]\),     \(\arcsin(x)\) is not a problem.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
DSM with the same dimensions as s, with     \(\arcsin(s)=\theta\) in      the same positions as the corresponding theta terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{cos() (DictionarySparseMatrix.DS method)@\spxentry{cos()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.cos}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cos}}}{\emph{ind=\sphinxhyphen{}1}}{}
Finds \(\cos(\theta)\) for all terms     \(\theta != 0\) in the DS s.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A DSM with the same dimensions with     \(\cos(\theta)\) in the      same position as the corresponding theta terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{cos\_asin() (DictionarySparseMatrix.DS method)@\spxentry{cos\_asin()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.cos_asin}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{cos\_asin}}}{\emph{ind=\sphinxhyphen{}1}}{}
Finds \(\cos( \asin( \theta))\) for all terms     \(\theta != 0\) in the DS s.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A DSM with the same dimensions with     \(\cos( \asin( \theta))\) in the      same position as the corresponding theta terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{costhetat() (DictionarySparseMatrix.DS method)@\spxentry{costhetat()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.costhetat}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{costhetat}}}{\emph{refindex}, \emph{ind=\sphinxhyphen{}1}}{}
Takes in a Mesh of angles with nonzero terms at ind. Computes
cos of thetat at those angles using the refractive index’s.
:param ind: The indices of the nonzero terms.
:param refindex: The refractive index’s of the obstacles in a vector.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{SIN}\PYG{o}{=}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{s}\PYG{p}{)}
\PYG{n}{thetat}\PYG{o}{=}\PYG{n}{asin}\PYG{p}{(}\PYG{n}{SIN}\PYG{o}{/}\PYG{n}{refindex}\PYG{p}{)}
\PYG{n}{ctht}\PYG{o}{=}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{thetat}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
DSM

\item[{Returns}] \leavevmode
ctht

\end{description}\end{quote}

\end{fulllineitems}

\index{dense() (DictionarySparseMatrix.DS method)@\spxentry{dense()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.dense}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dense}}}{}{}
Fills the DSM s.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A dense Nx x Ny x Nz x na x nb array with matching nonzero terms to      the sparse matrix s and zeroes elsewhere.

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_DSM\_divideby\_vec() (DictionarySparseMatrix.DS method)@\spxentry{dict\_DSM\_divideby\_vec()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.dict_DSM_divideby_vec}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dict\_DSM\_divideby\_vec}}}{\emph{vec}, \emph{ind=\sphinxhyphen{}1}}{}
Divide every column of the DSM s elementwise with the vector vec.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} \textendash{} a row vector with length na.

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{DSM}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{/}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
a DSM ‘out’ with the same dimensions as s.

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_col\_mult\_() (DictionarySparseMatrix.DS method)@\spxentry{dict\_col\_mult\_()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.dict_col_mult_}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dict\_col\_mult\_}}}{\emph{ind=\sphinxhyphen{}1}}{}
Multiply all nonzero terms in a column.

In every grid point x,y,z of s there is a sparse matrix SM.     Take the product of all nonzero terms in each column and     keep these in a vector v.
Construct a new DS of size Nx x Ny x Nz x 1 x nb=s.shape{[}1{]}.    Call this out. out{[}x,y,z{]} should be the v corresponding     to the SM in s at x,y,z.
\begin{description}
\item[{Method:}] \leavevmode\begin{itemize}
\item {} 
Find the {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}}. {\hyperref[\detokenize{index:DictionarySparseMatrix.DS.nonzero}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nonzero()}}}}} indices of s.

\item {} 
For each nonzero x,y,z grid point find the       nonzero() indices of the SM. Do this by column so       that the output has pairs going through       each nonzero column and matching the nonzero row       number. Use function {\hyperref[\detokenize{index:DictionarySparseMatrix.nonzero_bycol}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nonzero\_bycol()}}}}}.

\item {} 
Go through each of these indice pairs for the SM.       Check if the column index is new. If so assign       the column in out to the matching       value in the SM. If the column number is not       new then multiply the value in the column in       out by the corresponding value in the SM.

\end{itemize}

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{o}{=}\PYG{p}{[}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}
\PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
DS of size Nx x Ny x Nz x 1 x nb

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_row\_vec\_multiply() (DictionarySparseMatrix.DS method)@\spxentry{dict\_row\_vec\_multiply()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.dict_row_vec_multiply}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dict\_row\_vec\_multiply}}}{\emph{vec}, \emph{ind=\sphinxhyphen{}1}}{}
Multiply every row of the DSM s elementwise with the
vector vec.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} \textendash{} a row vector with length na.

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{DSM}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\end{sphinxVerbatim}

Multiplication is done using     {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}}. \sphinxcode{\sphinxupquote{dict\_vec\_multiply(vec)()}}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A DSM ‘out’ with the same dimensions as s.

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_scal\_mult() (DictionarySparseMatrix.DS method)@\spxentry{dict\_scal\_mult()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.dict_scal_mult}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dict\_scal\_mult}}}{\emph{scal}, \emph{ind=\sphinxhyphen{}1}}{}
Multiply every term of the DSM s by scal.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{scal}} \textendash{} scalar variable

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{scal}\PYG{o}{*}\PYG{n}{DSM}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
{\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{DS}}}(Nx,Ny,Nz,na,nb)

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_vec\_divideby\_DSM() (DictionarySparseMatrix.DS method)@\spxentry{dict\_vec\_divideby\_DSM()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.dict_vec_divideby_DSM}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dict\_vec\_divideby\_DSM}}}{\emph{vec}, \emph{ind=\sphinxhyphen{}1}}{}
Every column of the DSM s divides elementwise the vector vec.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} \textendash{} a row vector with length na.

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{/}\PYG{n}{DSM}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
a DSM ‘out’ with the same dimensions as s.

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_vec\_multiply() (DictionarySparseMatrix.DS method)@\spxentry{dict\_vec\_multiply()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.dict_vec_multiply}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{dict\_vec\_multiply}}}{\emph{vec}, \emph{ind=\sphinxhyphen{}1}}{}
Multiply every column of the DSM s elementwise with the     vector vec.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} \textendash{} a row vector with length na.

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{*}\PYG{n}{DSM}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\end{sphinxVerbatim}

Multiplication is done using     {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}}. \sphinxcode{\sphinxupquote{dict\_vec\_multiply(vec)()}}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A DSM ‘out’ with the same dimensions as s.

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{double\_dict\_col\_mult\_() (DictionarySparseMatrix.DS method)@\spxentry{double\_dict\_col\_mult\_()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.double_dict_col_mult_}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{double\_dict\_col\_mult\_}}}{\emph{DSM}, \emph{ind=\sphinxhyphen{}1}}{}
Multiply all nonzero terms in a column.

In every grid point x,y,z of s there is a sparse matrix SM.     Take the product of all nonzero terms in each column and     keep these in a vector v.
Construct a new DS of size Nx x Ny x Nz x 1 x nb=s.shape{[}1{]}.    Call this out. out{[}x,y,z{]} should be the v corresponding     to the SM in s at x,y,z.
\begin{description}
\item[{Method:}] \leavevmode\begin{itemize}
\item {} 
Find the {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}}. {\hyperref[\detokenize{index:DictionarySparseMatrix.DS.nonzero}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nonzero()}}}}} indices of s.

\item {} 
For each nonzero x,y,z grid point find the       nonzero() indices of the SM. Do this by column so       that the output has pairs going through       each nonzero column and matching the nonzero row       number. Use function {\hyperref[\detokenize{index:DictionarySparseMatrix.nonzero_bycol}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nonzero\_bycol()}}}}}.

\item {} 
Go through each of these indice pairs for the SM.       Check if the column index is new. If so assign       the column in out to the matching       value in the SM. If the column number is not       new then multiply the value in the column in       out by the corresponding value in the SM.

\end{itemize}

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{o}{=}\PYG{p}{[}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}
\PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
DS of size Nx x Ny x Nz x 1 x nb

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{double\_dict\_vec\_multiply() (DictionarySparseMatrix.DS method)@\spxentry{double\_dict\_vec\_multiply()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.double_dict_vec_multiply}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{double\_dict\_vec\_multiply}}}{\emph{DSM2}, \emph{vec}, \emph{ind=\sphinxhyphen{}1}}{}
Multiply every column of the DSM s elementwise with the     vector vec.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{vec}} \textendash{} a row vector with length na.

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{*}\PYG{n}{DSM}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\end{sphinxVerbatim}

Multiplication is done using     {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}}. \sphinxcode{\sphinxupquote{dict\_vec\_multiply(vec)()}}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A DSM ‘out’ with the same dimensions as s.

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{gain\_phase\_rad\_ref\_mul() (DictionarySparseMatrix.DS method)@\spxentry{gain\_phase\_rad\_ref\_mul()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.gain_phase_rad_ref_mul}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gain\_phase\_rad\_ref\_mul}}}{\emph{Com1}, \emph{Com2}, \emph{G}, \emph{khat}, \emph{L}, \emph{ind=\sphinxhyphen{}1}}{}~\begin{description}
\item[{Multiply all terms of s element wise with Com1/Rad and each row by Gt.}] \leavevmode
Multiply all terms of s elementwise with Com2/Rad and each row by Gt.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} \textendash{} a row vector with length na.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Rad}} \textendash{} A DSM with size Nx, Ny,Nz, 1,na

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Com1}} \textendash{} A DSM with size Nx, Ny,Nz, 1,na

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Com2}} \textendash{} A DSM with size Nx, Ny,Nz, 1,na

\end{itemize}

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out1}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{G}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{s}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Rad}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Com1}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\PYG{n}{out2}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{G}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{s}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Rad}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Com2}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A DSM ‘out’ with the same dimensions as s.

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{gain\_phase\_rad\_ref\_mul\_add() (DictionarySparseMatrix.DS method)@\spxentry{gain\_phase\_rad\_ref\_mul\_add()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.gain_phase_rad_ref_mul_add}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gain\_phase\_rad\_ref\_mul\_add}}}{\emph{Com1}, \emph{Com2}, \emph{G}, \emph{khat}, \emph{L}, \emph{lam}, \emph{ind=\sphinxhyphen{}1}}{}~\begin{description}
\item[{Multiply all terms of s element wise with Com1/Rad and each row by Gt.}] \leavevmode
Multiply all terms of s elementwise with Com2/Rad and each row by Gt.

\end{description}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} \textendash{} a row vector with length na.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Rad}} \textendash{} A DSM with size Nx, Ny,Nz, 1,na

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Com1}} \textendash{} A DSM with size Nx, Ny,Nz, 1,na

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Com2}} \textendash{} A DSM with size Nx, Ny,Nz, 1,na

\end{itemize}

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out1}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{G}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{s}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Rad}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Com1}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\PYG{n}{out2}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{]}\PYG{o}{+}\PYG{o}{=}\PYG{n}{G}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{s}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Rad}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Com2}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A np.array ‘out’ of size Nx, Ny,Nz

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{gain\_phase\_ref\_mul() (DictionarySparseMatrix.DS method)@\spxentry{gain\_phase\_ref\_mul()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.gain_phase_ref_mul}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{gain\_phase\_ref\_mul}}}{\emph{Com1}, \emph{Com2}, \emph{G}, \emph{ind=\sphinxhyphen{}1}}{}~\begin{quote}

Multiply all terms of s element wise with Com1 and each row by Gt.
Multiply all terms of s elementwise with Com2 and each row by Gt.
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{G}} \textendash{} a row vector with length na.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Com1}} \textendash{} A DSM with size Nx, Ny,Nz, 1,na

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Com2}} \textendash{} A DSM with size Nx, Ny,Nz, 1,na

\end{itemize}

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out1}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{G}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{s}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Com1}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\PYG{n}{out2}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{G}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{s}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{Com2}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A DSM ‘out’ with the same dimensions as s.

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{nonzero() (DictionarySparseMatrix.DS method)@\spxentry{nonzero()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.nonzero}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nonzero}}}{}{}
Find the indices of the nonzero terms in the DSM s.
\begin{quote}

\begin{sphinxadmonition}{note}{Note:}
The indices are found by iterating through all           keys (x,y,z) for the DSM s and finding the nonzero           indices of the corresponding sparse matrix.           These indices are then combinded           with the x,y,z key and stacked to create a 5xN           array of all the nonzero terms in the DSM,           where N is the number of nonzero           terms.
\end{sphinxadmonition}
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
indices={[} {[}x1,y1,z1,k1,j1{]},…,{[}xn,yn,zn,kn,jn{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{nonzeroMat() (DictionarySparseMatrix.DS method)@\spxentry{nonzeroMat()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.nonzeroMat}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{nonzeroMat}}}{\emph{cor}}{}
Find the indices of the nonzero terms for part of the DSM s.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{cor}} \textendash{} the part of s that you want the nonzero indices for.

\end{description}\end{quote}

The indices are found by using the {\hyperref[\detokenize{index:DictionarySparseMatrix.DS.nonzero}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nonzero()}}}}} function on s{[}cor{]}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
indices={[} {[}x1,y1,z1,k1,j1{]},…,{[}xn,yn,zn,kn,jn{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{phase\_calc() (DictionarySparseMatrix.DS method)@\spxentry{phase\_calc()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.phase_calc}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{phase\_calc}}}{\emph{khat}, \emph{L}, \emph{ind=\sphinxhyphen{}1}}{}
Compute \(\exp(i
rac{\hat{k}\hat{r}}{L^2})\)     for a Mesh of \(r\)
\begin{quote}
\begin{quote}\begin{description}
\item[{meta public}] \leavevmode
\end{description}\end{quote}

The phase is usually expressed at \(exp(ikr)\).
Since \(\hat{k}\) and \(\hat{r}\) are nondimensional lengths     scaled by the room length L the power of \(L^{-2}\) must be used.

Exponentials are not defined on DS, instead use     \(\exp(i   heta)=\cos(     heta)+i\sin(    heta)\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S1}\PYG{o}{=}\PYG{n}{RadMesh}\PYG{o}{.}\PYG{n}{dict\PYGZus{}scal\PYGZus{}mult}\PYG{p}{(}\PYG{n}{khat}\PYG{p}{)}
\PYG{n}{S2}\PYG{o}{=}\PYG{n}{S1}\PYG{o}{.}\PYG{n}{dict\PYGZus{}scal\PYGZus{}mult}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{L}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{out}\PYG{o}{=}\PYG{n}{S1}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{p}{)}\PYG{o}{+}\PYG{n}{S1}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{dict\PYGZus{}scal\PYGZus{}mult}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{rtype}] \leavevmode
DS of size Nx x Ny x Nz x na x 1

\item[{return}] \leavevmode
out

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}

\index{refcoefbyterm\_withmul() (DictionarySparseMatrix.DS method)@\spxentry{refcoefbyterm\_withmul()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.refcoefbyterm_withmul}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{refcoefbyterm\_withmul}}}{\emph{m}, \emph{refindex}, \emph{lam}, \emph{L}, \emph{ind=\sphinxhyphen{}1}}{}
Using the refractive index of obstacles, the wavelength and the
length scaling the unit mesh the reflection coefficents for each ray
are calculated.
\begin{quote}\begin{description}
\item[{Meta public}] \leavevmode
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{m}} \textendash{} The vector of impedance ratios. (Repeated to line up with terms in Mesh).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{refindex}} \textendash{} The vector of refractive indices of obstacles. (Repeated to line up with terms in Mesh).

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{lam}} \textendash{} The wavelength

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{L}} \textendash{} The length scale for the room.

\end{itemize}

\end{description}\end{quote}

out1 is the combinations of the reflection coefficients for the parallel to polarisation terms.

out2 is the combinations of the reflection coefficients for the perpendicular to polarisation terms.
\begin{itemize}
\item {} 
out1 and out2 are initialised to be zero everywhere with dimensions (Nx,Ny,Nz,1,nb)

\item {} 
Go through the non\sphinxhyphen{}zero indices (i0,i1,i2,i3,i4). If the row number (i3) is 0 and there are no other terms in the column     this is a line of sight ray.

\item {} 
If(i3==0):
\begin{itemize}
\item {} 
If the term in out1(i0,i1,i2,0,i4) is zero then this and out2(i0,i1,i2,0,i4) should be set to 1.

\item {} 
If out1(i0,i1,i2,0,i4) is non\sphinxhyphen{}zero then this ray is already accounted for and nothing should be done.

\end{itemize}

\item {} 
Else:
\begin{quote}
\begin{itemize}
\item {} 
Calculate the reflection coefficients.

\end{itemize}
\begin{equation*}
\begin{split}\theta=s[i0,i1,i2,i3,i4]
cthi=\cos(\theta)
ctht=\cos(\arcsin(\sin(\theta)/n))
S1=m[i3]*cthi
S2=mpi3]*ctht
Rpar=(S1-ctht)/(S1+ctht)
Rper=(cthi-S2)/(cthi+S2)\end{split}
\end{equation*}\end{quote}
\begin{itemize}
\item {} 
out1{[}i0,i1,i2,0,i4{]}=Rper, out2{[}i0,i1,i2,0,i4{]}=Rpar

\end{itemize}

\end{itemize}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
2 DSMs with dimensions (Nx,Ny,Nz,1,nb)

\item[{Returns}] \leavevmode
out1 out2

\end{description}\end{quote}

\end{fulllineitems}

\index{row\_sum() (DictionarySparseMatrix.DS method)@\spxentry{row\_sum()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.row_sum}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{row\_sum}}}{\emph{ind=\sphinxhyphen{}1}}{}
Sum all nonzero terms in a row.

In every grid point x,y,z of s there is a sparse matrix SM.
Construct a new DS of size Nx x Ny x Nz x na=s.shape{[}0{]} x 1.
Call this out.
out{[}x,y,z{]} should be the corresponding na x1 SM to the SM in s at x,y,z.
\begin{description}
\item[{Method:}] \leavevmode\begin{itemize}
\item {} 
Find the {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}}. {\hyperref[\detokenize{index:DictionarySparseMatrix.DS.nonzero}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nonzero()}}}}} indices of s\textasciigrave{}

\item {} 
Go through each of these indice. Check if the       row index is new. If so assign the row in out to the matching       value in the SM. If the row number is not new then sum the       value in the column in out by the corresponding value in the SM.

\end{itemize}

\end{description}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{o}{=}\PYG{p}{[}
\PYG{p}{[}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{row} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{row} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{row} \PYG{n}{na} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{p}{[}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{row} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{row} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{row} \PYG{n}{na} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}
\PYG{p}{]}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
DS of size Nx x Ny x Nz x na x  1

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_dict() (DictionarySparseMatrix.DS method)@\spxentry{save\_dict()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.save_dict}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{save\_dict}}}{\emph{filename\_}}{}
Save the DSM s.
\begin{quote}\begin{description}
\item[{Meta private}] \leavevmode
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{filename}} \textendash{} the name of the file to save to.

\item[{Returns}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}

\index{sin() (DictionarySparseMatrix.DS method)@\spxentry{sin()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.sin}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sin}}}{\emph{ind=\sphinxhyphen{}1}}{}
Finds \(\sin(\theta)\) for all terms
:meta private:

\(\theta != 0\) in the DS s.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A DSM with the same dimensions with     \(\sin(\theta)\) in the      same position as the corresponding theta terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{sparse\_angles() (DictionarySparseMatrix.DS method)@\spxentry{sparse\_angles()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.sparse_angles}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{sparse\_angles}}}{\emph{ind=\sphinxhyphen{}1}}{}
Finds the angles \(\theta\) which are the arguments     of the nonzero complex terms in the DSM s.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ind}} \textendash{} The non\sphinxhyphen{}zero indices of s in the form {[}{[}x0,y0,z0,a0,b0{]},…,{[}xn,yn,zn,an,bn{]}{]}     if ind is not input then the function {\hyperref[\detokenize{index:DictionarySparseMatrix.DS.nonzero}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{nonzero()}}}}} is run at the start to find it.

\end{description}\end{quote}
\begin{itemize}
\item {} 
Go through the nonzero terms (i0,i1,i2,i3,i4) in s.

\end{itemize}

\(\theta\)  is the angle of the term at s{[}i0,i1,i2,i3,i4{]}
\begin{itemize}
\item {} 
AngDSM{[}i0,i1,i2,i3,i4{]}=:math:\sphinxtitleref{theta}

\end{itemize}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A DSM with the same dimensions as s

\item[{Returns}] \leavevmode
AngDSM

\end{description}\end{quote}

\end{fulllineitems}

\index{stopcheck() (DictionarySparseMatrix.DS method)@\spxentry{stopcheck()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.stopcheck}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stopcheck}}}{\emph{i}, \emph{j}, \emph{k}}{}
Check if the index {[}i,j,k{]} is valid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{i}} \textendash{} is the index for the x axis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{j}} \textendash{} is the index for the y axis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} is the index for the z axis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p1}} \textendash{} is the point at the end of the ray.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} \textendash{} is the mesh width

\end{itemize}

\item[{Returns}] \leavevmode
1 if valid, 0 if not.

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{\label{\detokenize{index:id1}}Todo:}
add the inside check to this function
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{\label{\detokenize{index:id2}}Todo:}
add the check for the end of the ray.
\end{sphinxadmonition}
\begin{quote}\begin{description}
\item[{Warning}] \leavevmode
This currently only checks a point is     inside a room, it doesn’t account for if you have gone inside an object.

\end{description}\end{quote}

\end{fulllineitems}

\index{stopchecklist() (DictionarySparseMatrix.DS method)@\spxentry{stopchecklist()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.stopchecklist}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{stopchecklist}}}{\emph{ps}, \emph{p3}, \emph{n}}{}
Check if the list of points is valid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ps}} \textendash{} the indices for the points in the list

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p1}} \textendash{} the end of the ray

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} \textendash{} the meshwidth

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p3}} \textendash{} the points on the cone vectors

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n}} \textendash{} the normal vectors forming the cone.

\end{itemize}

\end{description}\end{quote}
\begin{itemize}
\item {} 
start=0 if no points were valid.

\item {} 
if at least 1 point was valid,
\begin{itemize}
\item {} 
ps={[}{[}i1,j1,k1{]},…,{[}in,jn,kn{]}{]} the indices of the valid points,

\item {} 
p3={[}{[}x1,y1,z1{]},…,{[}xn,yn,zn{]}{]} co\sphinxhyphen{}ordinates of the valid points,

\item {} 
N={[}n0,…,nN{]} the normal vectors corresponding to the valid points.

\end{itemize}

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
start, ps, p3, N

\end{description}\end{quote}

\end{fulllineitems}

\index{togrid() (DictionarySparseMatrix.DS method)@\spxentry{togrid()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.togrid}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{togrid}}}{\emph{ind}}{}
Compute the matrix norm at each grid point and return a     3d numpy array.
\begin{quote}\begin{description}
\item[{Meta private}] \leavevmode
\item[{Return type}] \leavevmode
Nx x Ny x Nz numpy array

\item[{Returns}] \leavevmode
Grid

\end{description}\end{quote}

\end{fulllineitems}

\index{xyznonzero() (DictionarySparseMatrix.DS method)@\spxentry{xyznonzero()}\spxextra{DictionarySparseMatrix.DS method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.DS.xyznonzero}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{xyznonzero}}}{}{}
Find the indices of the nonzero terms in the DSM s.
\begin{quote}\begin{description}
\item[{Meta public}] \leavevmode
\begin{sphinxadmonition}{note}{Note:}
The indices are found by iterating through all           keys (x,y,z) for the DSM s and finding the nonzero           indices of the corresponding sparse matrix.           These indices are then combinded           with the x,y,z key and stacked to create a 5xN           array of all the nonzero terms in the DSM,           where N is the number of nonzero           terms.
\end{sphinxadmonition}

\item[{Returns}] \leavevmode
indices={[} {[}x1,y1,z1,k1,j1{]},…,{[}xn,yn,zn,kn,jn{]}{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{load\_dict() (in module DictionarySparseMatrix)@\spxentry{load\_dict()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.load_dict}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{load\_dict}}}{\emph{filename\_}}{}
Load a DS as a dictionary and construct the DS again.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{filename}} \textendash{} the name of the DS saved

\end{description}\end{quote}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{Nx}\PYG{o}{=}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{Keys}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{Keys}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Ny}\PYG{o}{=}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{Keys}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{Keys}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Nz}\PYG{o}{=}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{Keys}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{Keys}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}

\index{nonzero\_bycol() (in module DictionarySparseMatrix)@\spxentry{nonzero\_bycol()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.nonzero_bycol}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{nonzero\_bycol}}}{\emph{SM}}{}
Find the index pairs for the nonzero terms in a sparse matrix.
Go through each column and find the nonzero rows.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{SM}} \textendash{} sparse matrix.

\item[{Returns}] \leavevmode
{[}{[}i(0j0),i(1j0),…,i(nj0),…,i(njn){]},    {[}j0,…,j0,…,jn,…,jn{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{parnonzero() (in module DictionarySparseMatrix)@\spxentry{parnonzero()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.parnonzero}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{parnonzero}}}{\emph{nj}, \emph{DS}}{}
Parallel version of a program with a dummy DS and a function for   finding the indices of the nonzero terms in a mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{nj}} \textendash{} number of processes.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{DS}} \textendash{} the mesh

\end{itemize}

\end{description}\end{quote}

Pool the nj processes
Specify what needs to be done.
Combine the information.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
5xn array which n is the number of nonzero terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{phase\_calc() (in module DictionarySparseMatrix)@\spxentry{phase\_calc()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.phase_calc}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{phase\_calc}}}{\emph{RadMesh}, \emph{khat}, \emph{L}, \emph{ind=\sphinxhyphen{}1}}{}
Compute \(\exp(i
rac{\hat{k}\hat{r}}{L^2})\)   for a Mesh of \(r\)
\begin{quote}

The phase is usually expressed at \(exp(ikr)\).
Since \(\hat{k}\) and \(\hat{r}\) are nondimensional lengths   scaled by the room length L the power of \(L^{-2}\) must be used.

Exponentials are not defined on DS, instead use   \(\exp(i       heta)=\cos(     heta)+i\sin(    heta)\).

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S1}\PYG{o}{=}\PYG{n}{RadMesh}\PYG{o}{.}\PYG{n}{dict\PYGZus{}scal\PYGZus{}mult}\PYG{p}{(}\PYG{n}{khat}\PYG{p}{)}
\PYG{n}{S2}\PYG{o}{=}\PYG{n}{S1}\PYG{o}{.}\PYG{n}{dict\PYGZus{}scal\PYGZus{}mult}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{L}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{out}\PYG{o}{=}\PYG{n}{S1}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{p}{)}\PYG{o}{+}\PYG{n}{S1}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{dict\PYGZus{}scal\PYGZus{}mult}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{rtype}] \leavevmode
DS of size Nx x Ny x Nz x na x 1

\item[{return}] \leavevmode
out

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}

\index{power\_compute() (in module DictionarySparseMatrix)@\spxentry{power\_compute()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.power_compute}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{power\_compute}}}{\emph{Mesh}, \emph{Grid}, \emph{Znobrat}, \emph{refindex}, \emph{Antpar}, \emph{Gt}, \emph{Pol}, \emph{Nra}, \emph{Nre}, \emph{Ns}, \emph{ind=\sphinxhyphen{}1}}{}
Compute the field from a Mesh of ray information and the physical   parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Mesh}} \textendash{} The {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}} mesh of ray information.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Znobrat}} \textendash{} An Nob x Nre+1 array containing tiles of the impedance   of obstacles divided by the impedance of air.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{refindex}} \textendash{} An Nob x Nre+1 array containing tiles of the refractive  index of obstacles.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Antpar}} \textendash{} Numpy array containing the wavenumber, wavelength and lengthscale.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Gt}} \textendash{} Array of the transmitting antenna gains.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Pol}} \textendash{} 2x1 numpy array containing the polarisation terms.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nra}} \textendash{} The number of rays in the ray tracer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Nre}} \textendash{} The number of reflections in the ray tracer.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Ns}} \textendash{} The number of terms on each axis

\end{itemize}

\end{description}\end{quote}

Method:
\begin{itemize}
\item {} 
First compute the angles of reflectio using py:func:\sphinxtitleref{Mesh.sparse\_angles()}

\item {} 
Compute the combined reflection coefficients using     \sphinxcode{\sphinxupquote{Mesh.refcoefbyterm\_withmu(Nre,refindex,lam,L, ind=\sphinxhyphen{}1)()}}

\item {} 
Combine the reflection coefficients that correspond to the same     ray using {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}}. \sphinxcode{\sphinxupquote{dict\_col\_mult()}}. This     multiplies reflection coefficients in the same column.

\item {} 
Extract the distance each ray had travelled using     {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}}. \sphinxcode{\sphinxupquote{\_\_get\_rad\_\_()}}

\item {} 
Multiply by the gains for the corresponding ray.

\item {} 
Multiply terms by the phases     \(\exp(i\hat{k} \hat{r})^{L^{-2}}\). With \(L\) being     the room length scale. \(\hat{r}\) being the relative distance     travelled which is the actual distance divided by the room length     scale, and \(\hat{k}\) is the relative wavenumber which is the     actual wavenumber times the room length scale.

\item {} 
Multiply by the gains corresponding to each ray.

\item {} 
Divide by the distance corresponding to each ray segment.

\item {} 
Sum all the ray segments in a grid point.

\item {} 
Multiply the grid by the transmitted field times the wavelngth     divided by the room length scale. \(\frac{\lambda}{L 4 \pi}\)

\item {} 
Multiply by initial polarisation vectors and combine.

\item {} 
Ignore dividing by initial phi as when converting to power in db     this disappears.

\item {} 
Take the amplitude and square.

\item {} 
Take \(10log10()\) to get the db Power.

\end{itemize}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
Nx x Ny x Nz numpy array of real values.

\item[{Returns}] \leavevmode
Grid

\end{description}\end{quote}

\end{fulllineitems}

\index{quality\_compute() (in module DictionarySparseMatrix)@\spxentry{quality\_compute()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.quality_compute}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{quality\_compute}}}{\emph{Mesh}, \emph{Grid}, \emph{Znobrat}, \emph{refindex}, \emph{Antpar}, \emph{Gt}, \emph{Pol}, \emph{Nra}, \emph{Nre}, \emph{Ns}, \emph{ind=\sphinxhyphen{}1}}{}
Compute the field from a Mesh of ray information and the physical   parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Mesh}} \textendash{} The {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}} mesh of ray information.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Znobrat}} \textendash{} An Nob x Nre+1 array containing tiles of the impedance     of obstacles divided by the impedance of air.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{refindex}} \textendash{} An Nob x Nre+1 array containing tiles of the refractive    index of obstacles.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Antpar}} \textendash{} Numpy array containing the wavenumber, wavelength and lengthscale.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Gt}} \textendash{} Array of the transmitting antenna gains.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{Pol}} \textendash{} 2x1 numpy array containing the polarisation terms.

\end{itemize}

\end{description}\end{quote}

Method:
\begin{itemize}
\item {} 
First compute the reflection coefficients using     \sphinxcode{\sphinxupquote{ref\_coef(Mesh,Znobrat,refindex)()}}

\item {} 
Combine the reflection coefficients that correspond to the same     ray using {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}}. \sphinxcode{\sphinxupquote{dict\_col\_mult()}}. This     multiplies reflection coefficients in the same column.

\item {} 
Extract the distance each ray had travelled using     {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}}. \sphinxcode{\sphinxupquote{\_\_get\_rad\_\_()}}

\item {} 
Multiply by the gains for the corresponding ray.

\item {} 
Multiply terms by the phases     \(\exp(i\hat{k} \hat{r})^{L^{-2}}\). With \(L\) being     the room length scale. \(\hat{r}\) being the relative distance     travelled which is the actual distance divided by the room length     scale, and \(\hat{k}\) is the relative wavenumber which is the     actual wavenumber times the room length scale.

\item {} 
Multiply by the gains corresponding to each ray.

\item {} 
Divide by the distance corresponding to each ray segment.

\item {} 
Sum all the ray segments in a grid point.

\item {} 
Multiply the grid by the transmitted field times the wavelngth     divided by the room length scale. \(\frac{\lambda}{L 4 \pi}\)

\item {} 
Multiply by initial polarisation vectors and combine.

\item {} 
Ignore dividing by initial phi as when converting to power in db     this disappears.

\item {} 
Take the amplitude and square.

\item {} 
Take \(10log10()\) to get the db Power.

\end{itemize}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
Nx x Ny x Nz numpy array of real values.

\item[{Returns}] \leavevmode
Grid

\end{description}\end{quote}

\end{fulllineitems}

\index{ref\_coef() (in module DictionarySparseMatrix)@\spxentry{ref\_coef()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.ref_coef}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{ref\_coef}}}{\emph{Mesh}, \emph{Znobrat}, \emph{refindex}, \emph{Nra}, \emph{Nre}, \emph{Ns}, \emph{ind=\sphinxhyphen{}1}}{}
Find the reflection coefficients.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{Mesh}} \textendash{} The DS mesh which contains terms re\textasciicircum{}(itheta) with theta   the reflection angle of incidence.

\end{description}\end{quote}

Method:
\begin{quote}
\begin{itemize}
\item {} 
Gets the mesh of angles using {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}}. \sphinxcode{\sphinxupquote{sparse\_angles()}}

\item {} 
Gets the indices of the nonzero terms using {\hyperref[\detokenize{index:DictionarySparseMatrix.DS}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{DS}}}}}. \sphinxcode{\sphinxupquote{nonzero()}}

\item {} 
Initialise sin(thetai), cos(thetai) and cos(thetat) meshes.

\item {} 
Compute cos(thetai),sin(thetai), cos(thetat)

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{cthi}\PYG{o}{=}\PYG{n}{AngDSM}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{SIN}\PYG{o}{=}\PYG{n}{AngDSM}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{Div}\PYG{o}{=}\PYG{n}{SIN}\PYG{o}{.}\PYG{n}{dict\PYGZus{}DSM\PYGZus{}divideby\PYGZus{}vec}\PYG{p}{(}\PYG{n}{refindex}\PYG{p}{)}
\PYG{n}{ctht}\PYG{o}{=}\PYG{n}{Div}\PYG{o}{.}\PYG{n}{asin}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{itemize}
\item {} 
Compute the reflection coefficients.

\end{itemize}

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{n}{S1}\PYG{o}{=}\PYG{p}{(}\PYG{n}{cthi}\PYG{p}{)}\PYG{o}{.}\PYG{n}{dict\PYGZus{}vec\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{Znobrat}\PYG{p}{)}
\PYG{n}{S2}\PYG{o}{=}\PYG{p}{(}\PYG{n}{ctht}\PYG{p}{)}\PYG{o}{.}\PYG{n}{dict\PYGZus{}vec\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{Znobrat}\PYG{p}{)}
\PYG{n}{Rper}\PYG{o}{=}\PYG{p}{(}\PYG{n}{S1}\PYG{o}{\PYGZhy{}}\PYG{n}{ctht}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{S1}\PYG{o}{+}\PYG{n}{ctht}\PYG{p}{)}
\PYG{n}{Rpar}\PYG{o}{=}\PYG{p}{(}\PYG{n}{cthi}\PYG{o}{\PYGZhy{}}\PYG{n}{S2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{cthi}\PYG{o}{+}\PYG{n}{S2}\PYG{p}{)}
\end{sphinxVerbatim}
\end{quote}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
Rper=DS(Nx,Ny,Nz,na,nb),Rpar=DS(Nx,Ny,Nz,na,nb)

\item[{Returns}] \leavevmode
Rper, Rpar

\end{description}\end{quote}

\end{fulllineitems}

\index{stopcheck() (in module DictionarySparseMatrix)@\spxentry{stopcheck()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.stopcheck}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{stopcheck}}}{\emph{i}, \emph{j}, \emph{k}, \emph{Nx}, \emph{Ny}, \emph{Nz}}{}
Check if the index {[}i,j,k{]} is valid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{i}} \textendash{} is the index for the x axis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{j}} \textendash{} is the index for the y axis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{k}} \textendash{} is the index for the z axis.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p1}} \textendash{} is the point at the end of the ray.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} \textendash{} is the mesh width

\end{itemize}

\item[{Returns}] \leavevmode
1 if valid, 0 if not.

\end{description}\end{quote}

\begin{sphinxadmonition}{note}{\label{\detokenize{index:id3}}Todo:}
add the inside check to this function
\end{sphinxadmonition}

\begin{sphinxadmonition}{note}{\label{\detokenize{index:id4}}Todo:}
add the check for the end of the ray.
\end{sphinxadmonition}

\end{fulllineitems}

\index{stopchecklist() (in module DictionarySparseMatrix)@\spxentry{stopchecklist()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.stopchecklist}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{stopchecklist}}}{\emph{ps}, \emph{p3}, \emph{n}, \emph{Nx}, \emph{Ny}, \emph{Nz}}{}
Check if the list of points is valid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ps}} \textendash{} the indices for the points in the list

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p1}} \textendash{} the end of the ray

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{h}} \textendash{} the meshwidth

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{p3}} \textendash{} the points on the cone vectors

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n}} \textendash{} the normal vectors forming the cone.

\end{itemize}

\end{description}\end{quote}

start=0 if no points were valid if at least 1 point was valid,
ps={[}{[}i1,j1,k1{]},…,{[}in,jn,kn{]}{]} the indices of the valid points,
p3={[}{[}x1,y1,z1{]},…,{[}xn,yn,zn{]}{]} co\sphinxhyphen{}ordinates of the valid points,
N={[}n0,…,nN{]} the normal vectors corresponding to the valid points.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
start, ps, p3, N

\end{description}\end{quote}

\end{fulllineitems}

\index{test\_14() (in module DictionarySparseMatrix)@\spxentry{test\_14()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.test_14}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{test\_14}}}{}{}
This is a test of the reflection coefficient function.
It sets test versions for the input parameters required and fills a DS   with dummy values.
It then computes the reflection coefficients associated with those   dummy parameters and values.

\end{fulllineitems}

\index{test\_15() (in module DictionarySparseMatrix)@\spxentry{test\_15()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.test_15}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{test\_15}}}{}{}
Testing multiplying nonzero terms in columns

\end{fulllineitems}

\index{test\_17() (in module DictionarySparseMatrix)@\spxentry{test\_17()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.test_17}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{test\_17}}}{}{}
Test the {\hyperref[\detokenize{index:DictionarySparseMatrix.parnonzero}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parnonzero()}}}}} function which should find   nonzero() indices in parallel.

\end{fulllineitems}

\index{test\_18() (in module DictionarySparseMatrix)@\spxentry{test\_18()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.test_18}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{test\_18}}}{}{}
Testing the save and load pickle functions.

\end{fulllineitems}

\index{test\_19() (in module DictionarySparseMatrix)@\spxentry{test\_19()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.test_19}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{test\_19}}}{}{}
Test the \sphinxcode{\sphinxupquote{nonzero\_bycol(SM)()}} function.
Initialise a dummy sparse matrix SM.
\begin{description}
\item[{In \sphinxcode{\sphinxupquote{nonzero\_bycol(SM)()}}:}] \leavevmode\begin{itemize}
\item {} 
Transpose the matrix.

\item {} 
Find the nonzero indices.

\item {} 
Swap the rows and columns in the indices.

\item {} 
Return the indices

\end{itemize}

\end{description}

Check these match the nonzero terms in SM.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
0 if successful 1 if not.

\end{description}\end{quote}

\end{fulllineitems}

\index{test\_20() (in module DictionarySparseMatrix)@\spxentry{test\_20()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.test_20}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{test\_20}}}{}{}
Test the dict\_col\_mult() function.
Use a dummy DS with each matrix upper triangular with the number in   every position the row.
Check that the col\_mult that comes out is the column number +1   factorial.

\end{fulllineitems}

\index{test\_21() (in module DictionarySparseMatrix)@\spxentry{test\_21()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.test_21}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{test\_21}}}{}{}
Test if the \_\_get\_rad\_\_() function works.

\end{fulllineitems}

\index{test\_22() (in module DictionarySparseMatrix)@\spxentry{test\_22()}\spxextra{in module DictionarySparseMatrix}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:DictionarySparseMatrix.test_22}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{DictionarySparseMatrix.}}\sphinxbfcode{\sphinxupquote{test\_22}}}{}{}
Test the set\_item() function for setting columns in a DSM

\end{fulllineitems}



\chapter{Reflection}
\label{\detokenize{index:module-reflection}}\label{\detokenize{index:reflection}}\index{reflection (module)@\spxentry{reflection}\spxextra{module}}
Code to Reflect a line in an edge without using Shapely
\index{errorcheck() (in module reflection)@\spxentry{errorcheck()}\spxextra{in module reflection}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:reflection.errorcheck}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{reflection.}}\sphinxbfcode{\sphinxupquote{errorcheck}}}{\emph{err}, \emph{ray}, \emph{ref}, \emph{normedge}}{}
Take the input ray and output ray and the normal to the edge,
check that both vectors have the same angle to the normal

\end{fulllineitems}

\index{refangle() (in module reflection)@\spxentry{refangle()}\spxextra{in module reflection}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:reflection.refangle}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{reflection.}}\sphinxbfcode{\sphinxupquote{refangle}}}{\emph{line}, \emph{obst}}{}
Find the reflection angle for the line reflection on the surface obst

\end{fulllineitems}

\index{test3() (in module reflection)@\spxentry{test3()}\spxextra{in module reflection}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{index:reflection.test3}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{reflection.}}\sphinxbfcode{\sphinxupquote{test3}}}{}{}
angle test

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}
Write an rst file for the notation.
\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{d}
\item\relax\sphinxstyleindexentry{DictionarySparseMatrix}\sphinxstyleindexpageref{index:\detokenize{module-DictionarySparseMatrix}}
\indexspace
\bigletter{p}
\item\relax\sphinxstyleindexentry{ParameterInput}\sphinxstyleindexpageref{index:\detokenize{module-ParameterInput}}
\indexspace
\bigletter{r}
\item\relax\sphinxstyleindexentry{Rays}\sphinxstyleindexpageref{index:\detokenize{module-Rays}}
\item\relax\sphinxstyleindexentry{RayTracerMainProgram}\sphinxstyleindexpageref{index:\detokenize{module-RayTracerMainProgram}}
\item\relax\sphinxstyleindexentry{reflection}\sphinxstyleindexpageref{index:\detokenize{module-reflection}}
\item\relax\sphinxstyleindexentry{Room}\sphinxstyleindexpageref{index:\detokenize{module-Room}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}