% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{DSMRayTracerDoc Documentation}
\date{Aug 30, 2019}
\release{0}
\author{Hayley}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}



\chapter{Main Program}
\label{index:welcome-to-dsmraytracerdoc-s-documentation}\label{index:main-program}\label{index:module-RayTracerMainProgram}\index{RayTracerMainProgram (module)}
Code to trace rays around a room. This code uses:
\begin{itemize}
\item {} 
the function {\hyperref[index:RayTracerMainProgram.RayTracer]{\sphinxcrossref{\sphinxcode{RayTracer()}}}} to compute the points for   the ray trajectories.

\item {} 
the function {\hyperref[index:RayTracerMainProgram.MeshProgram]{\sphinxcrossref{\sphinxcode{MeshProgram()}}}} to compute the points for   the ray trajectories and iterate along the rays storing the   information in a {\hyperref[index:DictionarySparseMatrix.DS]{\sphinxcrossref{\sphinxcode{DictionarySparseMatrix.DS}}}} and outputing   the points and mesh.

\item {} 
the function {\hyperref[index:RayTracerMainProgram.power_grid]{\sphinxcrossref{\sphinxcode{power\_grid()}}}} which loads the last saved   and loads the antenna and obstacle physical parameters from   {\hyperref[index:ParameterInput.ObstacleCoefficients]{\sphinxcrossref{\sphinxcode{ParameterInput.ObstacleCoefficients()}}}}. It uses these and   the functions {\hyperref[index:RayTracerMainProgram.RefCoefComputation]{\sphinxcrossref{\sphinxcode{RefCoefComputation()}}}} which output Rper   and Rpar the perpendicular and parallel to polarisation reflection   coefficients, and the function {\hyperref[index:RayTracerMainProgram.RefCombine]{\sphinxcrossref{\sphinxcode{RefCombine()}}}} to   get the loss from reflection for each ray segment entering each grid   point. This is then combine with the distance of each raysegments   travel from the mesh and the antenna gains to get the Power in   decibels.

\item {} 
The ray points from {\hyperref[index:RayTracerMainProgram.RayTracer]{\sphinxcrossref{\sphinxcode{RayTracer()}}}} are saved as:
`RayPoints\textbf{Nra}Refs\textbf{Nre}n.npy' with \textbf{Nra} replaced by the     number of rays and \textbf{Nre} replaced by the number of reflections.

\item {} 
The ray points from {\hyperref[index:RayTracerMainProgram.MeshProgram]{\sphinxcrossref{\sphinxcode{MeshProgram()}}}} are saved as:
`RayMeshPoints\textbf{Nra}Refs\textbf{Nre}n.npy' with \textbf{Nra} replaced     by the     number of rays and \textbf{Nre} replaced by the number of reflections.     The mesh is saved as `DSM\textbf{Nra}Refs\textbf{Nre}m.npy'.

\end{itemize}
\index{MeshProgram() (in module RayTracerMainProgram)}

\begin{fulllineitems}
\phantomsection\label{index:RayTracerMainProgram.MeshProgram}\pysiglinewithargsret{\sphinxcode{RayTracerMainProgram.}\sphinxbfcode{MeshProgram}}{}{}
Refect rays and output the Mesh containing ray information.

Parameters for the raytracer are input in {\hyperref[index:module\string-ParameterInput]{\sphinxcrossref{\sphinxcode{ParameterInput}}}}
The raytracing parameters defined in this module are saved and then loaded.
\begin{itemize}
\item {} 
`Raytracing.npy' - An array of 4 floats which is saved to   {[}Nra (number of rays), Nre (number of reflections),   h (relative meshwidth),   L (room length scale, the longest axis has been rescaled to 1 and this   is it's original length){]}

\item {} 
`Obstacles.npy'  - An array for 3x3x1 arrays containing co-ordinates   forming triangles which form the obstacles. This is saved to Oblist   (The obstacles which are within the outerboundary )

\item {} 
`Origin.npy'     - A 3x1 array for the co-ordinate of the source.   This is saved to Tx  (The location of the source antenna and origin   of every ray)

\item {} 
`OuterBoundary.npy' - An array for 3x3x1 arrays containing   co-ordinates forming triangles which form the obstacles. This is   saved to OuterBoundary   (The Obstacles forming the outer boundary of   the room )

\end{itemize}

Put the two arrays of obstacles into one array

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Oblist}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Oblist}\PYG{p}{,}\PYG{n}{OuterBoundary}\PYG{p}{]}
\end{Verbatim}
\begin{itemize}
\item {} 
`Directions.npy' - An Nrax3x1 array containing the vectors which   correspond to the initial direction of each ray. This is save to Direc.

\end{itemize}

A room is initialised with \emph{Oblist} using the py:class:\sphinxtitleref{Room.room}   class in {\hyperref[index:module\string-Room]{\sphinxcrossref{\sphinxcode{Room}}}}.

The number of obstacles and the number of x, y and z steps is found

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Nob}\PYG{o}{=}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{Nob}
\PYG{n}{Nx}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{maxxleng}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{Ny}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{maxyleng}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{n}{h}\PYG{p}{)}
\PYG{n}{Nz}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{maxzleng}\PYG{p}{(}\PYG{p}{)}\PYG{o}{/}\PYG{n}{h}\PYG{p}{)}
\end{Verbatim}

Initialise a \sphinxtitleref{DSM}.   {\hyperref[index:DictionarySparseMatrix.DS]{\sphinxcrossref{\sphinxcode{DictionarySparseMatrix.DS}}}} with the   number of spaces in the x, y and z axis Nx, Ny, Nz, the number of   obstacles Nob, the number of reflections Nre and the number of rays Nra.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Mesh}\PYG{o}{=}\PYG{n}{DSM}\PYG{o}{.}\PYG{n}{DS}\PYG{p}{(}\PYG{n}{Nx}\PYG{p}{,}\PYG{n}{Ny}\PYG{p}{,}\PYG{n}{Nz}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Nob}\PYG{o}{*}\PYG{n}{Nre}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{Nre}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Nra}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}

Find the reflection points of the rays and store the distance and   reflection angles of the rays in the Mesh. Use the   py:func:\sphinxtitleref{Room.room.ray\_mesh\_bounce} function.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Rays}\PYG{p}{,} \PYG{n}{Mesh}\PYG{o}{=}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{ray\PYGZus{}mesh\PYGZus{}bounce}\PYG{p}{(}\PYG{n}{Tx}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Nre}\PYG{p}{)}\PYG{p}{,}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Nra}\PYG{p}{)}\PYG{p}{,}\PYG{n}{Direc}\PYG{p}{,}\PYG{n}{Mesh}\PYG{p}{)}
\end{Verbatim}

Save the reflection points in Rays to   `RayMeshPoints\textbf{Nra}Refs\textbf{Nre}n.npy' making the   substitution for \textbf{Nra} and \textbf{Nre} with their parameter values.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Mesh

\end{description}\end{quote}

\end{fulllineitems}

\index{RayTracer() (in module RayTracerMainProgram)}

\begin{fulllineitems}
\phantomsection\label{index:RayTracerMainProgram.RayTracer}\pysiglinewithargsret{\sphinxcode{RayTracerMainProgram.}\sphinxbfcode{RayTracer}}{}{}
Refect rays and output the points of reflection.

Parameters for the raytracer are input in   {\hyperref[index:ParameterInput.DeclareParameters]{\sphinxcrossref{\sphinxcode{ParameterInput.DeclareParameters()}}}} The raytracing   parameters defined in this function are saved and then loaded.
\begin{itemize}
\item {} 
`Raytracing.npy' - An array of 4 floats which is saved to   {[}Nra (number of rays), Nre (number of reflections),   h (relative meshwidth),   L (room length scale, the longest axis has been rescaled to 1 and this   is it's original length){]}

\item {} 
`Obstacles.npy'  - An array for 3x3x1 arrays containing co-ordinates   forming triangles which form the obstacles. This is saved to Oblist   (The obstacles which are within the outerboundary )

\item {} 
`Origin.npy'     - A 3x1 array for the co-ordinate of the source.   This is saved to Tx  (The location of the source antenna and origin   of every ray)

\item {} 
`OuterBoundary.npy' - An array for 3x3x1 arrays containing   co-ordinates forming triangles which form the obstacles. This is   saved to OuterBoundary   (The Obstacles forming the outer boundary of   the room )

\end{itemize}

Put the two arrays of obstacles into one array

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Oblist}\PYG{o}{=}\PYG{p}{[}\PYG{n}{Oblist}\PYG{p}{,}\PYG{n}{OuterBoundary}\PYG{p}{]}
\end{Verbatim}
\begin{itemize}
\item {} 
`Directions.npy' - An Nrax3x1 array containing the vectors which   correspond to the initial direction of each ray. This is save to Direc.

\end{itemize}

A room is initialised with \emph{Oblist} using the \sphinxcode{room}   class in {\hyperref[index:module\string-Room]{\sphinxcrossref{\sphinxcode{Room}}}}.

Find the reflection points of the rays using   \sphinxcode{room.ray\_bounce()} function.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Rays}\PYG{p}{,} \PYG{n}{Mesh}\PYG{o}{=}\PYG{n}{Room}\PYG{o}{.}\PYG{n}{ray\PYGZus{}bounce}\PYG{p}{(}\PYG{n}{Tx}\PYG{p}{,}\PYG{n}{Nre}\PYG{p}{,}\PYG{n}{Nra}\PYG{p}{,}\PYG{n}{Direc}\PYG{p}{)}
\end{Verbatim}

Save the reflection points in Rays to   `RayPoints\textbf{Nra}Refs\textbf{Nre}n.npy' making the   substitution for \textbf{Nra} and \textbf{Nre} with their parameter values.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
0 to mark a successful run

\end{description}\end{quote}

\end{fulllineitems}

\index{RefCoefComputation() (in module RayTracerMainProgram)}

\begin{fulllineitems}
\phantomsection\label{index:RayTracerMainProgram.RefCoefComputation}\pysiglinewithargsret{\sphinxcode{RayTracerMainProgram.}\sphinxbfcode{RefCoefComputation}}{\emph{Mesh}}{}
Compute the mesh of reflection coefficients.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{Mesh}} -- The DS mesh which contains the angles and distances rays   have travelled.

\end{description}\end{quote}

Load the physical parameters using {\hyperref[index:module\string-ParameterInput]{\sphinxcrossref{\sphinxcode{ParameterInput}}}}.  {\hyperref[index:ParameterInput.ObstacleCoefficients]{\sphinxcrossref{\sphinxcode{ObstacleCoefficients()}}}}
* Znobrat - is the vector of characteristic impedances for obstacles   divided by the characteristic impedance of air.
* refindex - if the vector of refractive indexes for the obstacles.

Compute the Reflection coefficients (RefCoefper,Refcoefpar) using:
{\hyperref[index:module\string-DictionarySparseMatrix]{\sphinxcrossref{\sphinxcode{DictionarySparseMatrix}}}}.  \sphinxcode{ref\_coef((Mesh,Znobrat,refindex)()}
:return: (RefCoefper,Refcoefpar)

\end{fulllineitems}

\index{RefCombine() (in module RayTracerMainProgram)}

\begin{fulllineitems}
\phantomsection\label{index:RayTracerMainProgram.RefCombine}\pysiglinewithargsret{\sphinxcode{RayTracerMainProgram.}\sphinxbfcode{RefCombine}}{\emph{Rper}, \emph{Rpar}}{}
Combine reflection coefficients to get the loss from reflection   coefficient for each ray segment.

Take in the DS's ({\hyperref[index:module\string-DictionarySparseMatrix]{\sphinxcrossref{\sphinxcode{DictionarySparseMatrix}}}}. \sphinxcode{DS})  corresponding to the reflection coefficients for all the ray   interactions ({\hyperref[index:module\string-DictionarySparseMatrix]{\sphinxcrossref{\sphinxcode{DictionarySparseMatrix}}}}. \sphinxcode{ref\_coef(Mesh)()}).

Use the function {\hyperref[index:module\string-DictionarySparseMatrix]{\sphinxcrossref{\sphinxcode{DictionarySparseMatrix}}}}. \sphinxcode{DS}.   \sphinxcode{dict\_col\_mult()} to multiple reflection coefficients in the same column.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Combper}\PYG{o}{=}\PYG{p}{[}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{Rper}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{Rper}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{Rper}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{Rper}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{Rper}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{Rper}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}
\PYG{p}{]}
\end{Verbatim}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Combpar}\PYG{o}{=}\PYG{p}{[}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{Rpar}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{Rpar}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{Rpar}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{Rpar}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{Rpar}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{Rpar}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}
\PYG{p}{]}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{Rper}} -- The mesh corresponding to reflection coefficients   perpendicular to the polarisation.

\item {} 
\textbf{\texttt{Rpar}} -- The mesh corresponding to reflection coefficients   parallel to the polarisation.

\end{itemize}

\item[{Return type}] \leavevmode
DS(Nx,Ny,Nz,1,nb)

\item[{Returns}] \leavevmode
Combper, Combpar

\end{description}\end{quote}

\end{fulllineitems}

\index{power\_grid() (in module RayTracerMainProgram)}

\begin{fulllineitems}
\phantomsection\label{index:RayTracerMainProgram.power_grid}\pysiglinewithargsret{\sphinxcode{RayTracerMainProgram.}\sphinxbfcode{power\_grid}}{}{}
Calculate the field on a grid using enviroment parameters and the   ray Mesh.

Loads:
\begin{itemize}
\item {} 
(\emph{Nra}= number of rays, \emph{Nre}= number of reflections,   \emph{h}= meshwidth, \emph{L}= room length scale)={}`Paramters/Raytracing.npy{}`

\item {} 
(\emph{Nob}=number of obstacles)={}`Parameters/Nob.npy{}`

\item {} 
(\emph{Gt}=transmitter gains)={}`Parameters/TxGains.npy{}`

\item {} 
(\emph{freq}= frequency)={}`Parameters/frequency.npy{}`

\item {} 
(\emph{Freespace}= permittivity, permeabilty   and spead of light)={}`Parameters/Freespace.npy{}`

\item {} 
(\emph{Znobrat}= Znob/Z0, the ratio of the impedance of obstacles and   the impedance in freespace.) = \sphinxtitleref{Parameters/Znobrat.npy}

\item {} 
(\emph{refindex}= the refractive index of the obstacles)=  Paramerters/refindex.npy{}`

\item {} 
(\emph{Mesh})={}`DSM\textbf{Nra}Refs\textbf{Nre}m.npy{}`

\end{itemize}

Method:
* Initialise Grid using the number of x, y, and z steps in \emph{Mesh}.
* Use the function \sphinxcode{DictionarySparseMatrix.DS.power\_compute()}
to compute the power.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
Nx Ny x Nz numpy array of floats.

\item[{Returns}] \leavevmode
Grid

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Input the parameters}
\label{index:module-ParameterInput}\label{index:input-the-parameters}\index{ParameterInput (module)}
The code saves the values for the parameters in a ray tracer
\index{DeclareParameters() (in module ParameterInput)}

\begin{fulllineitems}
\phantomsection\label{index:ParameterInput.DeclareParameters}\pysiglinewithargsret{\sphinxcode{ParameterInput.}\sphinxbfcode{DeclareParameters}}{}{}
All input parameters for the ray-launching method are entered in
this function which will then save them inside a Parameters folder.
\begin{itemize}
\item {} 
Nra - Number of rays

\begin{notice}{note}{Note:}
Due to need of integer steps the input number of rays can not
always be used if everything is equally spaced.
\end{notice}

\item {} 
Nre - Number of reflections

\item {} 
Ns - Number of steps to split longest axis.

\item {} 
l1 - Interior obstacle scale

\item {} 
l2 - Boundary scale.

\item {} 
triangle1 - First interior obstacle

\item {} 
...

\item {} 
triangleN - Last interior obstacle

\item {} 
OuterBoundary1 - First obstacle forming the boundary of the   environment

\item {} 
...

\item {} 
OuterBoundaryN - Last obstacle forming the boundary of the   environment.

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
0 if successfully completed.

\end{description}\end{quote}

\end{fulllineitems}

\index{ObstacleCoefficients() (in module ParameterInput)}

\begin{fulllineitems}
\phantomsection\label{index:ParameterInput.ObstacleCoefficients}\pysiglinewithargsret{\sphinxcode{ParameterInput.}\sphinxbfcode{ObstacleCoefficients}}{}{}
Input the paramters for obstacles and the antenna. To ensure   arrays are of the right length for compatibility for the   ray-launcher retrieve the ray-launching parameters in   {\hyperref[index:ParameterInput.DeclareParameters]{\sphinxcrossref{\sphinxcode{DeclareParameters()}}}}

Load:
\begin{itemize}
\item {} 
`Obstacles.npy'     -Co-ordinates of obstacles in the room

\item {} 
`OuterBoundary.npy' - Co-ordinates of the walls of the room

\item {} 
`Raytracing.npy'    -{[}Nra (number of rays), Nre (number of reflections),   h (relative meshwidth){]}

\end{itemize}

Calculate:
\begin{itemize}
\item {} 
Nob=len({[}Obstacles,OuterBoundary{]})

\end{itemize}

Input:
\begin{itemize}
\item {} 
\sphinxtitleref{Freespace} -{[}mu0 (permeability of air),   eps0 (permittivity of air),Z0 (characteristic impedance of air),   c (speed of light){]}

\item {} 
\sphinxtitleref{frequency} - \(\omega\) angular frequency of the wave out   the antenna.

\item {} 
\sphinxtitleref{mur}       - \(\mu_r\) The relative permeability for all obstacles.   This should be an array with the same number of terms as the number   of obstacles Nob.

\item {} 
\sphinxtitleref{epsr}     - \(\epsilon_r\) The relative permittivity for each obstacle.   This should be an array with the same number of terms as the number   of obstacles Nob.

\item {} 
\sphinxtitleref{sigma}     - \(\sigma\) The electrical conductivity of the obstacles.   This should be an array with the same number of terms as the number   of obstacles.

\item {} 
\sphinxtitleref{Gt}        - The gains of the antenna. The should be an array with   the same number of terms as the number of rays Nra.

\end{itemize}

Calculate:
\begin{itemize}
\item {} 
\sphinxtitleref{eps0}   - \(\epsilon_0=\frac{1}{\mu_0 c^2}\)  permittivity of   freespace.

\item {} 
\sphinxtitleref{Z0}     - \(Z_0=\sqrt{\frac{\mu_0}{\epsilon_0}}\) characteristic   impedance of freespace.

\item {} 
\sphinxtitleref{refindex} - The refreactive index   \(n=\sqrt{\mu_r\epsilon_r}\)

\item {} 
\sphinxtitleref{Znobrat}- The relative impedance of the obstacles given by,
\(\hat{Z}_{Nob}=\frac{Z_{Nob}}{Z_0}\). The impedance of each     obstacle \(Z_{Nob}\) is given by     \(Z_{Nob}=\sqrt{\frac{i\omega\mu_0\mu_r}{\sigma+i\epsilon_0\epsilon_r}}\).

\end{itemize}

The Znobrat and refindex terms are then reformatted so that they   repeat Nre times with an extra term. The extra term corresponds to   the line of sight path. This makes them the same length as a column   in a matrix in a {\hyperref[index:DictionarySparseMatrix.DS]{\sphinxcrossref{\sphinxcode{DictionarySparseMatrix.DS}}}}.   Each term corresponds to a possible obstacle reflection combination.

The Gains matrix is also reformated to that it repeats (Nre+1) times.   This corresponds to every possible ray reflection number combination   This makes them the same length as a row in a matrix in a   {\hyperref[index:DictionarySparseMatrix.DS]{\sphinxcrossref{\sphinxcode{DictionarySparseMatrix.DS}}}}.   Each term corresponds to a possible obstacle reflection combination.

Save:
* \sphinxtitleref{frequency.npy}- The angular frequency \(\omega\).
* \sphinxtitleref{refindex.npy} - The refractive index of the obstacles.
* \sphinxtitleref{Znobrat.npy}  - The relative characteristic impedance.
* \sphinxtitleref{TxGains.npy}  - The gains of the antenna.
* \sphinxtitleref{Freespace.npy}- The freespace parameters.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Freespace}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{array}\PYG{p}{(}\PYG{p}{[}\PYG{n}{mu0}\PYG{p}{,}\PYG{n}{eps0}\PYG{p}{,}\PYG{n}{Z0}\PYG{p}{,}\PYG{n}{c}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
0 if successfully completed.

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Rays}
\label{index:module-Rays}\label{index:rays}\index{Rays (module)}
Code to construct the ray-tracing objects rays
\index{Ray (class in Rays)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{Rays.}\sphinxbfcode{Ray}}{\emph{s}, \emph{origin}, \emph{direc}}{}
A ray is a representation of the the trajectory of a reflecting   line and its reflections.
Ray.points is an array of co-ordinates representing
the collision points with the last term being the direction the ray ended in.
And Ray.reflections is an array containing tuples of the angles of incidence
and the number referring to the position of the obstacle in the obstacle list
\index{mesh\_multiref() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.mesh_multiref}\pysiglinewithargsret{\sphinxbfcode{mesh\_multiref}}{\emph{s}, \emph{room}, \emph{Nre}, \emph{Mesh}, \emph{Nra}, \emph{nra}}{}
Takes a ray and finds the first Nre reflections within a room.
As each reflection is found the ray is stepped through and
information added to the Mesh.
:param room: Obstacle co-ordinates, {\hyperref[index:module\string-Room]{\sphinxcrossref{\sphinxcode{Room}}}}. \sphinxcode{room}.
:param Nre: Number of reflections, integer.
:param Mesh: A grid with corresponding sparse matrices, this     is a {\hyperref[index:module\string-DictionarySparseMatrix]{\sphinxcrossref{\sphinxcode{DictionarySparseMatrix}}}}. \sphinxcode{DS} object.
:param Nra: Total number of rays, integer.

Method:
\begin{itemize}
\item {} 
Create a temporary vector vec.

\item {} 
For each ray segment use     \sphinxcode{mesh\_singleray(room,Mesh,dist,vec,Nra,Nre,nra)()} to      segment storing r*calcvec in the Mesh. With r being the distance      ray travelled to get  centre of the grid point the ray has gone      through.

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Mesh

\end{description}\end{quote}

\end{fulllineitems}

\index{mesh\_singleray() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.mesh_singleray}\pysiglinewithargsret{\sphinxbfcode{mesh\_singleray}}{\emph{s}, \emph{room}, \emph{Mesh}, \emph{dist}, \emph{calcvec}, \emph{Nra}, \emph{Nre}, \emph{nra}}{}
Iterate between two intersection points and store the ray     information in the Mesh
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{room}} -- {\hyperref[index:module\string-Room]{\sphinxcrossref{\sphinxcode{Room}}}}. \sphinxcode{room} object which     contains the co-ordinates of the obstacles.

\item {} 
\textbf{\texttt{Mesh}} -- {\hyperref[index:module\string-DictionarySparseMatrix]{\sphinxcrossref{\sphinxcode{DictionarySparseMatrix}}}}. \sphinxcode{DS}     which will store all of the ray information.

\item {} 
\textbf{\texttt{dist}} -- A scalar variable which is the distance the ray     travelled at the start of the ray segment.

\item {} 
\textbf{\texttt{calcvec}} -- A vector containing \(e^{i     heta}\) terms     for reflection angles :math:{}`  heta{}`. These terms are stored     in row nre*Nob+nob with nre being the current reflection number,     Nob the maximum obstacle number and nob the number of the     obstacle which was hit with the corresponding angle.

\item {} 
\textbf{\texttt{Nra}} -- Total number of rays.

\item {} 
\textbf{\texttt{Nre}} -- Maximum number of reflections.

\item {} 
\textbf{\texttt{nra}} -- Current ray number.

\end{itemize}

\end{description}\end{quote}

Method:
\begin{itemize}
\item {} 
Calculate \(\theta\) the reflection angle using     \sphinxcode{reflect\_angle(room)()}.

\item {} 
Find the number of steps \(Ns\) to the end of the ray segment     using \sphinxcode{number\_steps(meshwidth)()}.

\item {} 
Compute an array of normal vectors representing the ray cone.

\item {} 
Check the reflection number:
* If 0 then the \(calcvec[0]\) term is 1.
* ElseIf 1 then set \(calcvec[0]=0\) and       \(calcvec[nre*Nob+nob]=e^{i \theta}\).
* Else set \(calcvec[nre*Nob+nob]=e^{i \theta}\).

\item {} 
Step along the ray, For \(m1\in[0,Ns):\)
* Check if the ray point is outside the domain.
* Calculate the co-ordinate of the centre.
* Recalculate distance to be for the centre point       \(Mesh[i1,j1,k1,:,col]=np.sqrt(np.dot((p0-p2),(p0-p2)))*calcvec\).
* For each normal:
\begin{quote}
\begin{itemize}
\item {} 
Find the next cone point \(p3\) from the previous point         \(p1\), using the distance through a grid cube         \(\alpha\). This is given by:math:\sphinxtitleref{p3=p1+m2*alpha*norm}.

\item {} 
Find the co-ordinate for the centre of the grid point z

\end{itemize}

corresponding to the \(p3\)`s.
* Find the distance to this centre point.
* Set the column \(nra*Nre+nre\) of the mesh term at         these grid points to the distance times the vector of         reflection angles.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Mesh}\PYG{p}{[}\PYG{n}{cpos}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cpos}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{n}{cpos}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{p}{,}\PYG{p}{:}\PYG{p}{,}\PYG{n}{col}\PYG{p}{]}\PYG{o}{=}\PYG{n}{r2}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{calcvec}
\end{Verbatim}
\end{quote}
\begin{itemize}
\item {} 
Find the co-ordinate for the next ray point.       \(p1=p1+alpha*direc\).

\end{itemize}

\end{itemize}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
Mesh, dist, calcvec

\end{description}\end{quote}

\end{fulllineitems}

\index{multiref() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.multiref}\pysiglinewithargsret{\sphinxbfcode{multiref}}{\emph{s}, \emph{room}, \emph{Nre}}{}
Takes a ray and finds the first five reflections within a room.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{room}} -- {\hyperref[index:Room.room]{\sphinxcrossref{\sphinxcode{Room.room}}}} object which     contains all the obstacles in the room.

\item {} 
\textbf{\texttt{Nre}} -- The number of reflections. Integer value.

\end{itemize}

\end{description}\end{quote}

Using the function \sphinxcode{reflect\_calc(room)()} find the     co-ordinate of the reflected ray. Store this in s.points     and return whether the function was successful.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
3x1 numpy array.

\item[{Returns}] \leavevmode
end=1 if unsuccessful, 0 is successful.

\end{description}\end{quote}

\end{fulllineitems}

\index{normal\_mat() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.normal_mat}\pysiglinewithargsret{\sphinxbfcode{normal\_mat}}{\emph{s}, \emph{Ncones}, \emph{Nra}, \emph{d}, \emph{dist}, \emph{h}}{}
Form a matrix of vectors representing the plane which is      normal to d
\begin{itemize}
\item {} 
Normalise the direction of the ray \(d=d/||d||\)

\item {} 
Calculate angle spacing between rays      :math:{\color{red}\bfseries{}{}`}deltheta=2arcsin(

\end{itemize}
\begin{description}
\item[{rac\{1\}\{Ncones\}){}`}] \leavevmode\begin{itemize}
\item {} 
Calculate the number of normals.      :math:{\color{red}\bfseries{}{}`}Nnor=1+

\end{itemize}

\item[{rac\{(2pi)\}\{deltheta\}{}`}] \leavevmode\begin{itemize}
\item {} 
Create an array of all the angles.

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{anglevec}\PYG{o}{=}\PYG{n}{np}\PYG{o}{.}\PYG{n}{linspace}\PYG{p}{(}\PYG{l+m+mf}{0.0}\PYG{p}{,}\PYG{l+m+mi}{2}\PYG{o}{*}\PYG{n}{ma}\PYG{o}{.}\PYG{n}{pi}\PYG{p}{,}\PYG{n}{num}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Nnor}\PYG{p}{)}\PYG{p}{,} \PYG{n}{endpoint}\PYG{o}{=}\PYG{k+kc}{False}\PYG{p}{)}
\end{Verbatim}
\begin{itemize}
\item {} 
The dot product of the direction and the normal needs to be 0.     Choose \((1,1,-(dx+dy)/dz)\) as the first vector      (unless dz==0). Use this to compute another vector in the plane.      This forms a co-ordinate axis for the normal vectors.

\end{itemize}

If dz==0 then instead choose the vector \((0,0,1)\) and      repeat the process for the additional axis vector.
.. code:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{1}\PYG{p}{)}
\PYG{n}{y}\PYG{o}{=}\PYG{n}{N}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]} \PYG{n}{x} \PYG{n}{d}
\PYG{n}{y}\PYG{o}{=}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{o}{/}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{y}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{p}{)}\PYG{o}{*}\PYG{n}{y}
\end{Verbatim}
\begin{itemize}
\item {} 
Use the ais vectors as multiples of \(\cos(\theta)\)      \(\sin(\theta)\) to form equally space vectors.

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{N}\PYG{o}{=}\PYG{n}{cos}\PYG{p}{(}\PYG{n}{anglevec}\PYG{p}{)}\PYG{o}{*} \PYG{n}{N}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{o}{+}\PYG{n}{sin}\PYG{p}{(}\PYG{n}{anglevec}\PYG{p}{)}\PYG{o}{*}\PYG{n}{y}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{returns}] \leavevmode
N

\end{description}\end{quote}

\end{description}

\end{fulllineitems}

\index{number\_cone\_steps() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.number_cone_steps}\pysiglinewithargsret{\sphinxbfcode{number\_cone\_steps}}{\emph{s}, \emph{h}, \emph{dist}, \emph{Nra}}{}
find the number of steps taken along one normal in the cone

\end{fulllineitems}

\index{number\_steps() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.number_steps}\pysiglinewithargsret{\sphinxbfcode{number\_steps}}{\emph{s}, \emph{meshwidth}}{}
The number of steps along the ray between intersection points

\end{fulllineitems}

\index{obst\_collision\_point() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.obst_collision_point}\pysiglinewithargsret{\sphinxbfcode{obst\_collision\_point}}{\emph{s}, \emph{surface}}{}
intersection of the ray with a wall\_segment

\end{fulllineitems}

\index{ray\_length() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.ray_length}\pysiglinewithargsret{\sphinxbfcode{ray\_length}}{\emph{s}, \emph{inter}}{}
The length of the ray upto the intersection

\end{fulllineitems}

\index{raytest() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.raytest}\pysiglinewithargsret{\sphinxbfcode{raytest}}{\emph{s}, \emph{room}, \emph{err}}{}
Checks the reflection function for errors

\end{fulllineitems}

\index{ref\_angle() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.ref_angle}\pysiglinewithargsret{\sphinxbfcode{ref\_angle}}{\emph{s}, \emph{room}}{}
Find the reflection angle of the most recent intersected ray.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{room}} -- {\hyperref[index:module\string-Room]{\sphinxcrossref{\sphinxcode{Room}}}}. \sphinxcode{room} object which     contains all the obstacles in the room.

\end{description}\end{quote}

Use the ray number stored in s.points{[}-2{]}{[}-1{]} to retrieve     the obstacle number then retrieve that obstacle from room.

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{norm}\PYG{o}{=}\PYG{n}{edge1} \PYG{n}{x} \PYG{n}{edge2}

\PYG{n}{c} \PYG{o}{=} \PYG{p}{(}\PYG{n}{ray\PYGZus{}direc} \PYG{o}{.} \PYG{n}{norm} \PYG{p}{)} \PYG{o}{/} \PYG{p}{(}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{ray\PYGZus{}direc}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}} \PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{n}{norm}\PYG{o}{\textbar{}}\PYG{o}{\textbar{}}\PYG{p}{)}

\PYG{n}{theta}\PYG{o}{=}\PYG{n}{arccos}\PYG{p}{(}\PYG{n}{c}\PYG{p}{)}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
\href{https://docs.python.org/3/library/functions.html\#float}{float}

\item[{Returns}] \leavevmode
theta

\end{description}\end{quote}

\end{fulllineitems}

\index{reflect\_calc() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.reflect_calc}\pysiglinewithargsret{\sphinxbfcode{reflect\_calc}}{\emph{s}, \emph{room}}{}
Finds the reflection of the ray inside a room.

Method:
\begin{itemize}
\item {} 
If: the previous collision point was \emph{None} then don't find the     next one. Return: 1

\item {} 
Else: Compute the next collision point.
\begin{itemize}
\item {} 
If: the collision point doesn't exist. Return: 1

\item {} 
Else: use the collision point to compute the reflected ray.       Return: 0

\end{itemize}

\end{itemize}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
0 or 1 indicator of success.

\item[{Returns}] \leavevmode
0 if  reflection was computed 1 if not.

\end{description}\end{quote}

\end{fulllineitems}

\index{room\_collision\_point() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.room_collision_point}\pysiglinewithargsret{\sphinxbfcode{room\_collision\_point}}{\emph{s}, \emph{room}}{}
The closest intersection out of the possible intersections with
the wall\_segments in room. Returns the intersection point and the
wall intersected with

\end{fulllineitems}


\end{fulllineitems}



\chapter{Room}
\label{index:module-Room}\label{index:room}\index{Room (module)}
Code to construct the mesh of the room
\index{room (class in Room)}

\begin{fulllineitems}
\phantomsection\label{index:Room.room}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{Room.}\sphinxbfcode{room}}{\emph{s}, \emph{obst}}{}
A room is where the obstacle co-ordinates are contained.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{obst}} -- is a Nobx3x{[}3x1{]} array, where Nob is the number of     obstacles.

\end{description}\end{quote}

obst{[}j{]} is a 3x{[}3x1{]} array which is 3, 3D co-ordinates   which form a triangle.

This array of triangles forms the obstacles in the room.
\begin{description}
\item[{Attributes of room:}] \leavevmode\begin{itemize}
\item {} 
s.obst=obst

\item {} 
.points{[}3*j{]}=obst{[}j{]}{[}0{]}

\item {} 
s.maxlength is a 4x1 array initialised as empty. Once assigned     this is the maximum length in theroom and in the x, y, and z axis.

\item {} 
s.bounds is a 3x2 array     \(s.bounds= [ [minx, miny, minz], [maxx,maxy,maxz]]\)

\item {} 
s.inside\_points is an initial empty array. Points which are known     to be inside obstacles are added to this array later.

\item {} 
s.time is an array with the time the room was created.

\item {} 
s.meshwidth is initialised as zero but is stored once asked for     using get\_meshwidth.

\end{itemize}

\end{description}
\index{coordinate() (Room.room method)}

\begin{fulllineitems}
\phantomsection\label{index:Room.room.coordinate}\pysiglinewithargsret{\sphinxbfcode{coordinate}}{\emph{s}, \emph{h}, \emph{i}, \emph{j}, \emph{k}}{}
Find the co-ordinate of the point at the centre of the element.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{h}} -- the meshwdith. Once assigned this matches s.meshwidth

\item {} 
\textbf{\texttt{i}} -- the first index or an array corresponding to the first     index for multiple points.

\item {} 
\textbf{\texttt{j}} -- the second index or an array corresponding to the second     index for multiple points.

\item {} 
\textbf{\texttt{k}} -- the third index or an array corresponding to the third     index for multiple points.

\end{itemize}

\end{description}\end{quote}

If there is only 1 i, 1 j, and 1 k,

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{p}\PYG{o}{=}\PYG{p}{[}\PYG{n}{minx}\PYG{p}{,}\PYG{n}{miny}\PYG{p}{,}\PYG{n}{minz}\PYG{p}{]} \PYG{o}{+}\PYG{n}{h}\PYG{o}{*}\PYG{p}{[}\PYG{n}{i}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{j}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{k}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{]}
\end{Verbatim}

ElseIf there's arrays for i,j, and k,

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{p}\PYG{o}{=}\PYG{p}{[}\PYG{p}{[}\PYG{n}{minx}\PYG{p}{,}\PYG{n}{miny}\PYG{p}{,}\PYG{n}{minz}\PYG{p}{]} \PYG{o}{+}\PYG{n}{h}\PYG{o}{*}\PYG{p}{[}\PYG{n}{i0}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{j0}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{k0}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{]}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
  \PYG{p}{[}\PYG{n}{minx}\PYG{p}{,}\PYG{n}{miny}\PYG{p}{,}\PYG{n}{minz}\PYG{p}{]} \PYG{o}{+}\PYG{n}{h}\PYG{o}{*}\PYG{p}{[}\PYG{o+ow}{in}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{jn}\PYG{o}{+}\PYG{l+m+mf}{0.5}\PYG{p}{,}\PYG{n}{kn}\PYG{o}{+}\PYG{l+m+mf}{0.5} \PYG{p}{]}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
p

\end{description}\end{quote}

\end{fulllineitems}

\index{maxleng() (Room.room method)}

\begin{fulllineitems}
\phantomsection\label{index:Room.room.maxleng}\pysiglinewithargsret{\sphinxbfcode{maxleng}}{\emph{s}, \emph{a=0}}{}
Get the maximum length in the room or axis.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{a}} -- the axis or room. a=0 maximum length in room, a=1 for     x-axis, a=2 for y-axis a=3 for z-axis.

\end{description}\end{quote}

If the maxlength{[}a{]} hasn't been found yet find it by comparing the     between points in s.points.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
s.maxlength{[}a{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{position() (Room.room method)}

\begin{fulllineitems}
\phantomsection\label{index:Room.room.position}\pysiglinewithargsret{\sphinxbfcode{position}}{\emph{s}, \emph{p}, \emph{h}}{}
Find the indexing position in a mesh with width h for point p     lying in the room s.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{p}} -- ={[}x,y,z{]} the co-ordinate of the point p or an array of

\end{description}\end{quote}

\(points p=[[x0,y0,z0],...,[xn,yn,zn]]\)
:param h: is the meshwidth, once assigned this matches s.meshwidth

If p is one point,

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{o}{=}\PYG{p}{(}\PYG{n}{p}\PYG{o}{\PYGZhy{}}\PYG{p}{[}\PYG{n}{minx}\PYG{p}{,}\PYG{n}{miny}\PYG{p}{,}\PYG{n}{minz}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{n}{h}\PYG{p}{,}
\end{Verbatim}

If p is an array of points,

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{o}{=}\PYG{p}{[}\PYG{p}{(}\PYG{n}{p0}\PYG{o}{\PYGZhy{}}\PYG{p}{[}\PYG{n}{minx}\PYG{p}{,}\PYG{n}{miny}\PYG{p}{,}\PYG{n}{minz}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{n}{h}\PYG{p}{,}\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}\PYG{p}{(}\PYG{n}{pn}\PYG{o}{\PYGZhy{}}\PYG{p}{[}\PYG{n}{minx}\PYG{p}{,}\PYG{n}{miny}\PYG{p}{,}\PYG{n}{minz}\PYG{p}{]}\PYG{p}{)}\PYG{o}{/}\PYG{o}{/}\PYG{n}{h}\PYG{p}{]}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{ray\_bounce() (Room.room method)}

\begin{fulllineitems}
\phantomsection\label{index:Room.room.ray_bounce}\pysiglinewithargsret{\sphinxbfcode{ray\_bounce}}{\emph{s}, \emph{Tx}, \emph{Nre}, \emph{Nra}, \emph{directions}}{}
Trace ray's uniformly emitted from an origin around a room.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{Nra}} -- Number of rays

\item {} 
\textbf{\texttt{Nre}} -- number of reflections Nre

\item {} 
\textbf{\texttt{directions}} -- A Nra*3 array of the initial directions     for each ray.

\end{itemize}

\end{description}\end{quote}

The multiref function is used to find the Nre reflections for     the Nra rays with the obstacles s.obst.

\(raylist=[[p00,p01,...,p0Nre],[p10,...,p1Nre],...,[pNra0,...,pNraNre]]\)
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
An array of the ray points.

\item[{Returns}] \leavevmode
raylist

\end{description}\end{quote}

\end{fulllineitems}

\index{ray\_mesh\_bounce() (Room.room method)}

\begin{fulllineitems}
\phantomsection\label{index:Room.room.ray_mesh_bounce}\pysiglinewithargsret{\sphinxbfcode{ray\_mesh\_bounce}}{\emph{s}, \emph{Tx}, \emph{Nre}, \emph{Nra}, \emph{directions}, \emph{Mesh}}{}
Traces ray's uniformly emitted from an origin around a room.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{Tx}} -- the co-ordinate of the transmitter location

\item {} 
\textbf{\texttt{Nra}} -- Number of rays

\item {} 
\textbf{\texttt{Nre}} -- number of reflections

\item {} 
\textbf{\texttt{directions}} -- Nra*3 array of the initial direction for     each ray.

\item {} 
\textbf{\texttt{Mesh}} -- a Nx*Ny*Nz*na*nb array (actually a dictionary of     sparse matrices using class DS but built to have similar     structure to an array).

\end{itemize}

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{na}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{n}{Nob}\PYG{o}{*}\PYG{n}{Nre}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}\PYG{p}{,} \PYG{n}{nb}\PYG{o}{=}\PYG{n+nb}{int}\PYG{p}{(}\PYG{p}{(}\PYG{n}{Nre}\PYG{p}{)}\PYG{o}{*}\PYG{p}{(}\PYG{n}{Nra}\PYG{p}{)}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{)}
\end{Verbatim}

The rays are reflected Nre times with the obstacles s.obst.     The points of intersection with the obstacles are stored in z
raylist. This is done using the mesh\_multiref function.
As each intersection is found the mesh\_multiref function     forms the line segment between intersection points and the     corresponding ray cone. All mesh elements in the ray cone store     the reflection angles and the distance along the ray cone from the     source to the centre of each mesh element. This is stored in Mesh.
See \sphinxcode{Rays.mesh\_multiref()} for more details on the     reflections and storage.

When complete the time in s.time() is assigned to the time taken     to complete the function.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
raylist, Mesh

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Mesh}
\label{index:module-DictionarySparseMatrix}\label{index:mesh}\index{DictionarySparseMatrix (module)}\index{DS (class in DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{DS}}{\emph{s}, \emph{Nx=1}, \emph{Ny=1}, \emph{Nz=1}, \emph{na=1}, \emph{nb=1}, \emph{dt=\textless{}class `numpy.complex128'\textgreater{}}}{}
The DS class is a dictionary of sparse matrices.
The keys for the dictionary are (i,j,k) such that i is in {[}0,Nx{]},
j is in {[}0, Ny{]}, and k is in {[}0,Nz{]}.
SM=DS{[}x,y,z{]} is a na*nb sparse matrix, initialised with complex128 data type.
\(na=(Nob*Nre+1)\)
\(nb=((Nre)*(Nra)+1)\)
\index{asin() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.asin}\pysiglinewithargsret{\sphinxbfcode{asin}}{\emph{s}}{}
Finds

\(\theta=\arcsin(x)\) for all terms \(x != 0\) in     the DS s. Since all angles     \(\theta\) are in \([0,\pi /2]\),     \(\arcsin(x)\) is not a problem.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
DSM with the same dimensions as s, with     \(\arcsin(s)=\theta\) in      the same positions as the corresponding theta terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{cos() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.cos}\pysiglinewithargsret{\sphinxbfcode{cos}}{\emph{s}}{}
Finds \(\cos(\theta)\) for all terms     \(\theta != 0\) in the DS s.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A DSM with the same dimensions with     \(\cos(\theta)\) in the      same position as the corresponding theta terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{dense() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.dense}\pysiglinewithargsret{\sphinxbfcode{dense}}{\emph{s}}{}
Fills the DSM s.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A dense Nx x Ny x Nz x na x nb array with matching nonzero terms to      the sparse matrix s and zeroes elsewhere.

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_DSM\_divideby\_vec() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.dict_DSM_divideby_vec}\pysiglinewithargsret{\sphinxbfcode{dict\_DSM\_divideby\_vec}}{\emph{s}, \emph{vec}}{}
Divide every column of the DSM s elementwise with the vector vec.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{vec}} -- a row vector with length na.

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{DSM}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{/}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
a DSM `out' with the same dimensions as s.

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_col\_mult() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.dict_col_mult}\pysiglinewithargsret{\sphinxbfcode{dict\_col\_mult}}{\emph{s}}{}
Multiply all nonzero terms in a column.

In every grid point x,y,z of s there is a sparse matrix SM.     Take the product of all nonzero terms in each column and     keep these in a vector v.
Construct a new DS of size Nx x Ny x Nz x 1 x nb=s.shape{[}1{]}.    Call this out. out{[}x,y,z{]} should be the v corresponding     to the SM in s at x,y,z.
\begin{description}
\item[{Method:}] \leavevmode\begin{itemize}
\item {} 
Find the {\hyperref[index:DictionarySparseMatrix.DS]{\sphinxcrossref{\sphinxcode{DS}}}}. {\hyperref[index:DictionarySparseMatrix.DS.nonzero]{\sphinxcrossref{\sphinxcode{nonzero()}}}} indices of s.

\item {} 
For each nonzero x,y,z grid point find the       nonzero() indices of the SM. Do this by column so       that the output has pairs going through       each nonzero column and matching the nonzero row       number. Use function {\hyperref[index:DictionarySparseMatrix.nonzero_bycol]{\sphinxcrossref{\sphinxcode{nonzero\_bycol()}}}}.

\item {} 
Go through each of these indice pairs for the SM.       Check if the column index is new. If so assign       the column in out to the matching       value in the SM. If the column number is not       new then multiply the value in the column in       out by the corresponding value in the SM.

\end{itemize}

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{o}{=}\PYG{p}{[}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{p}{[}\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n}{prod}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{column} \PYG{n}{nb} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}
\PYG{p}{]}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
DS of size Nx x Ny x Nz x 1 x nb

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_row\_vec\_multiply() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.dict_row_vec_multiply}\pysiglinewithargsret{\sphinxbfcode{dict\_row\_vec\_multiply}}{\emph{s}, \emph{vec}}{}
Multiply every row of the DSM s elementwise with the
vector vec.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{vec}} -- a row vector with length na.

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{j}\PYG{p}{]}\PYG{o}{*}\PYG{n}{DSM}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\end{Verbatim}

Multiplication is done using     {\hyperref[index:DictionarySparseMatrix.DS]{\sphinxcrossref{\sphinxcode{DS}}}}. \sphinxcode{dict\_vec\_multiply(vec)()}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A DSM `out' with the same dimensions as s.

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_scal\_mult() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.dict_scal_mult}\pysiglinewithargsret{\sphinxbfcode{dict\_scal\_mult}}{\emph{s}, \emph{scal}}{}
Multiply every term of the DSM s by scal.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{scal}} -- scalar variable

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{scal}\PYG{o}{*}\PYG{n}{DSM}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
DS(Nx,Ny,Nz,na,nb)

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_vec\_divideby\_DSM() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.dict_vec_divideby_DSM}\pysiglinewithargsret{\sphinxbfcode{dict\_vec\_divideby\_DSM}}{\emph{s}, \emph{vec}}{}
Every column of the DSM s divides elementwise the vector vec.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{vec}} -- a row vector with length na.

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{/}\PYG{n}{DSM}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
a DSM `out' with the same dimensions as s.

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_vec\_multiply() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.dict_vec_multiply}\pysiglinewithargsret{\sphinxbfcode{dict\_vec\_multiply}}{\emph{s}, \emph{vec}}{}
Multiply every column of the DSM s elementwise with the     vector vec.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{vec}} -- a row vector with length na.

\end{description}\end{quote}

For integers \(x,y,z,k\) and \(j\) such that,
\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\),

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}\PYG{o}{=}\PYG{n}{vec}\PYG{p}{[}\PYG{n}{k}\PYG{p}{]}\PYG{o}{*}\PYG{n}{DSM}\PYG{p}{[}\PYG{n}{x}\PYG{p}{,}\PYG{n}{y}\PYG{p}{,}\PYG{n}{z}\PYG{p}{,}\PYG{n}{k}\PYG{p}{,}\PYG{n}{j}\PYG{p}{]}
\end{Verbatim}

Multiplication is done using     {\hyperref[index:DictionarySparseMatrix.DS]{\sphinxcrossref{\sphinxcode{DS}}}}. \sphinxcode{dict\_vec\_multiply(vec)()}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
A DSM `out' with the same dimensions as s.

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{nonzero() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.nonzero}\pysiglinewithargsret{\sphinxbfcode{nonzero}}{\emph{s}}{}
Find the indices of the nonzero terms in the DSM s.
\begin{quote}

\begin{notice}{note}{Note:}
The indices are found by iterating through all           keys (x,y,z) for the DSM s and finding the nonzero           indices of the corresponding sparse matrix.           These indices are then combinded           with the x,y,z key and stacked to create a 5xN           array of all the nonzero terms in the DSM,           where N is the number of nonzero           terms.
\end{notice}
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
indices={[} {[}x1,y1,z1,k1,j1{]},...,{[}xn,yn,zn,kn,jn{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{nonzeroMat() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.nonzeroMat}\pysiglinewithargsret{\sphinxbfcode{nonzeroMat}}{\emph{s}, \emph{cor}}{}
Find the indices of the nonzero terms for part of the DSM s.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{cor}} -- the part of s that you want the nonzero indices for.

\end{description}\end{quote}

The indices are found by using the {\hyperref[index:DictionarySparseMatrix.DS.nonzero]{\sphinxcrossref{\sphinxcode{nonzero()}}}} function on s{[}cor{]}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
indices={[} {[}x1,y1,z1,k1,j1{]},...,{[}xn,yn,zn,kn,jn{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{row\_sum() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.row_sum}\pysiglinewithargsret{\sphinxbfcode{row\_sum}}{\emph{s}}{}
Sum all nonzero terms in a row.

In every grid point x,y,z of s there is a sparse matrix SM.
Construct a new DS of size Nx x Ny x Nz x na=s.shape{[}0{]} x 1.
Call this out.
out{[}x,y,z{]} should be the corresponding na x1 SM to the SM in s at x,y,z.
\begin{description}
\item[{Method:}] \leavevmode\begin{itemize}
\item {} 
Find the {\hyperref[index:DictionarySparseMatrix.DS]{\sphinxcrossref{\sphinxcode{DS}}}}. {\hyperref[index:DictionarySparseMatrix.DS.nonzero]{\sphinxcrossref{\sphinxcode{nonzero()}}}} indices of s{}`

\item {} 
Go through each of these indice. Check if the       row index is new. If so assign the row in out to the matching       value in the SM. If the row number is not new then sum the       value in the column in out by the corresponding value in the SM.

\end{itemize}

\end{description}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{o}{=}\PYG{p}{[}
\PYG{p}{[}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{row} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{row} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{row} \PYG{n}{na} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{,}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{p}{]}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{p}{[}\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{row} \PYG{l+m+mi}{0} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{row} \PYG{l+m+mi}{1} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{p}{,}
\PYG{o}{.}\PYG{o}{.}\PYG{o}{.}\PYG{p}{,}
\PYG{n+nb}{sum}\PYG{p}{(}\PYG{n}{nonzero} \PYG{n}{terms} \PYG{o+ow}{in} \PYG{n}{row} \PYG{n}{na} \PYG{o+ow}{in} \PYG{n}{s}\PYG{p}{[}\PYG{n}{Nx}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Ny}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,}\PYG{n}{Nz}\PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{]}
\PYG{p}{]}
\PYG{p}{]}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
DS of size Nx x Ny x Nz x na x  1

\item[{Returns}] \leavevmode
out

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_dict() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.save_dict}\pysiglinewithargsret{\sphinxbfcode{save\_dict}}{\emph{s}, \emph{filename\_}}{}
Save the DSM s.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filename}} -- the name of the file to save to.

\item[{Returns}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}

\index{sin() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.sin}\pysiglinewithargsret{\sphinxbfcode{sin}}{\emph{s}}{}
Finds \(\sin(\theta)\) for all terms     \(\theta != 0\) in the DS s.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A DSM with the same dimensions with     \(\sin(\theta)\) in the      same position as the corresponding theta terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{sparse\_angles() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.sparse_angles}\pysiglinewithargsret{\sphinxbfcode{sparse\_angles}}{\emph{s}}{}
Finds the angles \(\theta\) which are the arguments     of the nonzero complex terms in the DSM s.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A DSM with the same dimensions with     \(\theta\) in the same      position as the corresponding complex terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{stopcheck() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.stopcheck}\pysiglinewithargsret{\sphinxbfcode{stopcheck}}{\emph{s}, \emph{i}, \emph{j}, \emph{k}, \emph{p1}, \emph{h}}{}
Check if the index {[}i,j,k{]} is valid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{i}} -- is the index for the x axis.

\item {} 
\textbf{\texttt{j}} -- is the index for the y axis.

\item {} 
\textbf{\texttt{k}} -- is the index for the z axis.

\item {} 
\textbf{\texttt{p1}} -- is the point at the end of the ray.

\item {} 
\textbf{\texttt{h}} -- is the mesh width

\end{itemize}

\item[{Returns}] \leavevmode
1 if valid, 0 if not.

\end{description}\end{quote}

\begin{notice}{note}{Todo}

add the inside check to this function
\end{notice}

\begin{notice}{note}{Todo}

add the check for the end of the ray.
\end{notice}

\end{fulllineitems}

\index{stopchecklist() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.stopchecklist}\pysiglinewithargsret{\sphinxbfcode{stopchecklist}}{\emph{s}, \emph{ps}, \emph{p1}, \emph{h}, \emph{p3}, \emph{n}}{}
Check if the list of points is valid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{ps}} -- the indices for the points in the list

\item {} 
\textbf{\texttt{p1}} -- the end of the ray

\item {} 
\textbf{\texttt{h}} -- the meshwidth

\item {} 
\textbf{\texttt{p3}} -- the points on the cone vectors

\item {} 
\textbf{\texttt{n}} -- the normal vectors forming the cone.

\end{itemize}

\end{description}\end{quote}

start=0 if no points were valid if at least 1 point was valid,
ps={[}{[}i1,j1,k1{]},...,{[}in,jn,kn{]}{]} the indices of the valid points,
p3={[}{[}x1,y1,z1{]},...,{[}xn,yn,zn{]}{]} co-ordinates of the valid points,
N={[}n0,...,nN{]} the normal vectors corresponding to the valid points.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
start, ps, p3, N

\end{description}\end{quote}

\end{fulllineitems}

\index{togrid() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.togrid}\pysiglinewithargsret{\sphinxbfcode{togrid}}{\emph{s}}{}
Computethe matrix norm at each grid point and return a     3d numpy array.
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
Nx x Ny x Nz numpy array

\item[{Returns}] \leavevmode
Grid

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{load\_dict() (in module DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.load_dict}\pysiglinewithargsret{\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{load\_dict}}{\emph{filename\_}}{}
Load a DS as a dictionary and construct the DS again.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filename}} -- the name of the DS saved

\end{description}\end{quote}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{Nx}\PYG{o}{=}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{Keys}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{Keys}\PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Ny}\PYG{o}{=}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{Keys}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{Keys}\PYG{p}{[}\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{p}{)}
\PYG{n}{Nz}\PYG{o}{=}\PYG{n+nb}{max}\PYG{p}{(}\PYG{n}{Keys}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}\PYG{o}{\PYGZhy{}}\PYG{n+nb}{min}\PYG{p}{(}\PYG{n}{Keys}\PYG{p}{[}\PYG{l+m+mi}{2}\PYG{p}{]}\PYG{p}{)}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}

\index{nonzero\_bycol() (in module DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.nonzero_bycol}\pysiglinewithargsret{\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{nonzero\_bycol}}{\emph{SM}}{}
Find the index pairs for the nonzero terms in a sparse matrix.
Go through each column and find the nonzero rows.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{SM}} -- sparse matrix.

\item[{Returns}] \leavevmode
{[}{[}i(0j0),i(1j0),...,i(nj0),...,i(njn){]},    {[}j0,...,j0,...,jn,...,jn{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{parnonzero() (in module DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.parnonzero}\pysiglinewithargsret{\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{parnonzero}}{\emph{nj}, \emph{DS}}{}
Parallel version of a program with a dummy DS and a function for   finding the indices of the nonzero terms in a mesh.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{nj}} -- number of processes.

\item {} 
\textbf{\texttt{DS}} -- the mesh

\end{itemize}

\end{description}\end{quote}

Pool the nj processes
Specify what needs to be done.
Combine the information.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
5xn array which n is the number of nonzero terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{phase\_calc() (in module DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.phase_calc}\pysiglinewithargsret{\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{phase\_calc}}{\emph{RadMesh}, \emph{khat}, \emph{L}}{}
Compute \(\exp(i
rac{\hat{k}\hat{r}}{L^2})\)   for a Mesh of \(r\)
\begin{quote}

The phase is usually expressed at \(exp(ikr)\).
Since \(\hat{k}\) and \(\hat{r}\) are nondimensional lengths   scaled by the room length L the power of \(L^{-2}\) must be used.

Exponentials are not defined on DS, instead use   \(\exp(i       heta)=\cos(     heta)+i\sin(    heta)\).

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{S1}\PYG{o}{=}\PYG{n}{RadMesh}\PYG{o}{.}\PYG{n}{dict\PYGZus{}scal\PYGZus{}mult}\PYG{p}{(}\PYG{n}{khat}\PYG{p}{)}
\PYG{n}{S2}\PYG{o}{=}\PYG{n}{S1}\PYG{o}{.}\PYG{n}{dict\PYGZus{}scal\PYGZus{}mult}\PYG{p}{(}\PYG{l+m+mf}{1.0}\PYG{o}{/}\PYG{p}{(}\PYG{n}{L}\PYG{o}{*}\PYG{o}{*}\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{p}{)}
\PYG{n}{out}\PYG{o}{=}\PYG{n}{S1}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{p}{)}\PYG{o}{+}\PYG{n}{S1}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{dict\PYGZus{}scal\PYGZus{}mult}\PYG{p}{(}\PYG{l+m+mi}{1}\PYG{n}{j}\PYG{p}{)}
\end{Verbatim}
\begin{quote}\begin{description}
\item[{rtype}] \leavevmode
DS of size Nx x Ny x Nz x na x 1

\item[{return}] \leavevmode
out

\end{description}\end{quote}
\end{quote}

\end{fulllineitems}

\index{power\_compute() (in module DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.power_compute}\pysiglinewithargsret{\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{power\_compute}}{\emph{Mesh}, \emph{Grid}, \emph{Znobrat}, \emph{refindex}, \emph{Antpar}, \emph{Gt}}{}
Compute the field from a Mesh of ray information and the physical   parameters.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{Mesh}} -- The {\hyperref[index:DictionarySparseMatrix.DS]{\sphinxcrossref{\sphinxcode{DS}}}} mesh of ray information.

\item {} 
\textbf{\texttt{Znobrat}} -- An Nob x Nre+1 array containing tiles of the impedance     of obstacles divided by the impedance of air.

\item {} 
\textbf{\texttt{refindex}} -- An Nob x Nre+1 array containing tiles of the refractive    index of obstacles.

\end{itemize}

\end{description}\end{quote}

Method:
\begin{itemize}
\item {} 
First compute the reflection coefficients using     \sphinxcode{ref\_coef(Mesh,Znobrat,refindex)()}

\item {} 
Combine the reflection coefficients that correspond to the same     ray using {\hyperref[index:DictionarySparseMatrix.DS]{\sphinxcrossref{\sphinxcode{DS}}}}. \sphinxcode{dict\_col\_mult()}. This     multiplies reflection coefficients in the same column.

\item {} 
Extract the distance each ray had travelled using     {\hyperref[index:DictionarySparseMatrix.DS]{\sphinxcrossref{\sphinxcode{DS}}}}. \sphinxcode{\_\_get\_rad\_\_()}

\item {} 
Multiply by the gains for the corresponding ray.

\item {} 
Multiply terms by the phases     \(\exp(i\hat{k} \hat{r})^{L^{-2}}\). With \(L\) being     the room length scale. \(\hat{r}\) being the relative distance     travelled which is the actual distance divided by the room length     scale, and \(\hat{k}\) is the relative wavenumber which is the     actual wavenumber times the room length scale.

\item {} 
Multiply by the gains corresponding to each ray.

\item {} 
Divide by the distance corresponding to each ray segment.

\item {} 
Sum all the ray segments in a grid point.

\item {} 
Multiply the grid by the transmitted field times the wavelngth     divided by the room length scale. \(\frac{\lambda}{L 4 \pi}\)

\item {} 
Multiply by initial polarisation vectors and combine.

\item {} 
Ignore dividing by initial phi as when converting to power in db     this disappears.

\item {} 
Take the amplitude and square.

\item {} 
Take \(10log10()\) to get the db Power.

\end{itemize}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
Nx x Ny x Nz numpy array of real values.

\item[{Returns}] \leavevmode
Grid

\end{description}\end{quote}

\end{fulllineitems}

\index{ref\_coef() (in module DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.ref_coef}\pysiglinewithargsret{\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{ref\_coef}}{\emph{Mesh}, \emph{Znobrat}, \emph{refindex}}{}
Find the reflection coefficients.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{Mesh}} -- The DS mesh which contains terms re\textasciicircum{}(itheta) with theta   the reflection angle of incidence.

\end{description}\end{quote}

Method:
\begin{quote}
\begin{itemize}
\item {} 
Gets the mesh of angles using {\hyperref[index:DictionarySparseMatrix.DS]{\sphinxcrossref{\sphinxcode{DS}}}}. \sphinxcode{sparse\_angles()}

\item {} 
Gets the indices of the nonzero terms using {\hyperref[index:DictionarySparseMatrix.DS]{\sphinxcrossref{\sphinxcode{DS}}}}. \sphinxcode{nonzero()}

\item {} 
Initialise sin(thetai), cos(thetai) and cos(thetat) meshes.

\item {} 
Compute cos(thetai),sin(thetai), cos(thetat)

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{cthi}\PYG{o}{=}\PYG{n}{AngDSM}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{SIN}\PYG{o}{=}\PYG{n}{AngDSM}\PYG{o}{.}\PYG{n}{sin}\PYG{p}{(}\PYG{p}{)}
\PYG{n}{Div}\PYG{o}{=}\PYG{n}{SIN}\PYG{o}{.}\PYG{n}{dict\PYGZus{}DSM\PYGZus{}divideby\PYGZus{}vec}\PYG{p}{(}\PYG{n}{refindex}\PYG{p}{)}
\PYG{n}{ctht}\PYG{o}{=}\PYG{n}{Div}\PYG{o}{.}\PYG{n}{asin}\PYG{p}{(}\PYG{p}{)}\PYG{o}{.}\PYG{n}{cos}\PYG{p}{(}\PYG{p}{)}
\end{Verbatim}
\begin{itemize}
\item {} 
Compute the reflection coefficients.

\end{itemize}

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{S1}\PYG{o}{=}\PYG{p}{(}\PYG{n}{cthi}\PYG{p}{)}\PYG{o}{.}\PYG{n}{dict\PYGZus{}vec\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{Znobrat}\PYG{p}{)}
\PYG{n}{S2}\PYG{o}{=}\PYG{p}{(}\PYG{n}{ctht}\PYG{p}{)}\PYG{o}{.}\PYG{n}{dict\PYGZus{}vec\PYGZus{}multiply}\PYG{p}{(}\PYG{n}{Znobrat}\PYG{p}{)}
\PYG{n}{Rper}\PYG{o}{=}\PYG{p}{(}\PYG{n}{S1}\PYG{o}{\PYGZhy{}}\PYG{n}{ctht}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{S1}\PYG{o}{+}\PYG{n}{ctht}\PYG{p}{)}
\PYG{n}{Rpar}\PYG{o}{=}\PYG{p}{(}\PYG{n}{cthi}\PYG{o}{\PYGZhy{}}\PYG{n}{S2}\PYG{p}{)}\PYG{o}{/}\PYG{p}{(}\PYG{n}{cthi}\PYG{o}{+}\PYG{n}{S2}\PYG{p}{)}
\end{Verbatim}
\end{quote}
\begin{quote}\begin{description}
\item[{Return type}] \leavevmode
Rper=DS(Nx,Ny,Nz,na,nb),Rpar=DS(Nx,Ny,Nz,na,nb)

\item[{Returns}] \leavevmode
Rper, Rpar

\end{description}\end{quote}

\end{fulllineitems}

\index{test\_14() (in module DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.test_14}\pysiglinewithargsret{\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{test\_14}}{}{}
This is a test of the reflection coefficient function.
It sets test versions for the input parameters required and fills a DS   with dummy values.
It then computes the reflection coefficients associated with those   dummy parameters and values.

\end{fulllineitems}

\index{test\_15() (in module DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.test_15}\pysiglinewithargsret{\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{test\_15}}{}{}
Testing multiplying nonzero terms in columns

\end{fulllineitems}

\index{test\_17() (in module DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.test_17}\pysiglinewithargsret{\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{test\_17}}{}{}
Test the {\hyperref[index:DictionarySparseMatrix.parnonzero]{\sphinxcrossref{\sphinxcode{parnonzero()}}}} function which should find   nonzero() indices in parallel.

\end{fulllineitems}

\index{test\_18() (in module DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.test_18}\pysiglinewithargsret{\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{test\_18}}{}{}
Testing the save and load pickle functions.

\end{fulllineitems}

\index{test\_19() (in module DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.test_19}\pysiglinewithargsret{\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{test\_19}}{}{}
Test the \sphinxcode{nonzero\_bycol(SM)()} function.
Initialise a dummy sparse matrix SM.
\begin{description}
\item[{In \sphinxcode{nonzero\_bycol(SM)()}:}] \leavevmode\begin{itemize}
\item {} 
Transpose the matrix.

\item {} 
Find the nonzero indices.

\item {} 
Swap the rows and columns in the indices.

\item {} 
Return the indices

\end{itemize}

\end{description}

Check these match the nonzero terms in SM.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
0 if successful 1 if not.

\end{description}\end{quote}

\end{fulllineitems}

\index{test\_20() (in module DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.test_20}\pysiglinewithargsret{\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{test\_20}}{}{}
Test the dict\_col\_mult() function.
Use a dummy DS with each matrix upper triangular with the number in   every position the row.
Check that the col\_mult that comes out is the column number +1   factorial.

\end{fulllineitems}

\index{test\_21() (in module DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.test_21}\pysiglinewithargsret{\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{test\_21}}{}{}
Test if the \_\_get\_rad\_\_() function works.

\end{fulllineitems}



\chapter{Reflection}
\label{index:reflection}\label{index:module-reflection}\index{reflection (module)}
Code to Reflect a line in an edge without using Shapely
\index{errorcheck() (in module reflection)}

\begin{fulllineitems}
\phantomsection\label{index:reflection.errorcheck}\pysiglinewithargsret{\sphinxcode{reflection.}\sphinxbfcode{errorcheck}}{\emph{err}, \emph{ray}, \emph{ref}, \emph{normedge}}{}
Take the input ray and output ray and the normal to the edge,
check that both vectors have the same angle to the normal

\end{fulllineitems}

\index{refangle() (in module reflection)}

\begin{fulllineitems}
\phantomsection\label{index:reflection.refangle}\pysiglinewithargsret{\sphinxcode{reflection.}\sphinxbfcode{refangle}}{\emph{line}, \emph{obst}}{}
Find the reflection angle for the line reflection on the surface obst

\end{fulllineitems}

\index{test3() (in module reflection)}

\begin{fulllineitems}
\phantomsection\label{index:reflection.test3}\pysiglinewithargsret{\sphinxcode{reflection.}\sphinxbfcode{test3}}{}{}
angle test

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}
Write an rst file for the notation.
\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{d}
\item {\texttt{DictionarySparseMatrix}}, \pageref{index:module-DictionarySparseMatrix}
\indexspace
\bigletter{p}
\item {\texttt{ParameterInput}}, \pageref{index:module-ParameterInput}
\indexspace
\bigletter{r}
\item {\texttt{Rays}}, \pageref{index:module-Rays}
\item {\texttt{RayTracerMainProgram}}, \pageref{index:module-RayTracerMainProgram}
\item {\texttt{reflection}}, \pageref{index:module-reflection}
\item {\texttt{Room}}, \pageref{index:module-Room}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
