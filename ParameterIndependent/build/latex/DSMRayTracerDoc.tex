% Generated by Sphinx.
\def\sphinxdocclass{report}
\newif\ifsphinxKeepOldNames \sphinxKeepOldNamestrue
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage{iftex}

\ifPDFTeX
  \usepackage[utf8]{inputenc}
\fi
\ifdefined\DeclareUnicodeCharacter
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Sonny]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}
\usepackage{eqparbox}


\addto\captionsenglish{\renewcommand{\figurename}{Fig.\@ }}
\addto\captionsenglish{\renewcommand{\tablename}{Table }}
\SetupFloatingEnvironment{literal-block}{name=Listing }

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\title{DSMRayTracerDoc Documentation}
\date{Aug 13, 2019}
\release{0}
\author{Hayley}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@ch\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@mb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cpf\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\renewcommand\PYGZsq{\textquotesingle}

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{Main Program}
\label{index:welcome-to-dsmraytracerdoc-s-documentation}\label{index:main-program}\label{index:module-RayTracerMainProgram}\index{RayTracerMainProgram (module)}
Code to trace rays around a room. This code computes the trajectories only.

This is something I want to say that is not in the docstring.


\chapter{Input the parameters}
\label{index:input-the-parameters}\label{index:module-ParameterInput}\index{ParameterInput (module)}
The code saves the values for the parameters in a ray tracer
\index{ObstacleCoefficients() (in module ParameterInput)}

\begin{fulllineitems}
\phantomsection\label{index:ParameterInput.ObstacleCoefficients}\pysiglinewithargsret{\sphinxcode{ParameterInput.}\sphinxbfcode{ObstacleCoefficients}}{}{}
Retrieve the information saved in Declare parameters. Then define the obstacle coefficients.

\end{fulllineitems}



\chapter{Rays}
\label{index:module-Rays}\label{index:rays}\index{Rays (module)}
Code to construct the ray-tracing objects rays
\index{Ray (class in Rays)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{Rays.}\sphinxbfcode{Ray}}{\emph{s}, \emph{origin}, \emph{direc}}{}
A ray is a representation of the the trajectory of a reflecting line
and its reflections. Ray.points is an array of co-ordinates representing
the collision points with the last term being the direction the ray ended in.
And Ray.reflections is an array containing tuples of the angles of incidence
and the number referring to the position of the obstacle in the obstacle list
\index{mesh\_multiref() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.mesh_multiref}\pysiglinewithargsret{\sphinxbfcode{mesh\_multiref}}{\emph{s}, \emph{room}, \emph{Nre}, \emph{Mesh}, \emph{Nra}, \emph{nra}}{}
Takes a ray and finds the first Nre reflections within a room.
As each reflection is found the ray is stepped through and
information added to the Mesh.
Inputs: Room- Obstacle co-ordinates, Nre- Number of reflections,
Mesh- 3D array with each element corresponding to a sparse matrix.
Nra- Total number of rays.

\end{fulllineitems}

\index{mesh\_singleray() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.mesh_singleray}\pysiglinewithargsret{\sphinxbfcode{mesh\_singleray}}{\emph{s}, \emph{room}, \emph{Mesh}, \emph{dist}, \emph{calcvec}, \emph{Nra}, \emph{Nre}, \emph{nra}}{}
Iterate between two intersection points and store the ray information in the Mesh

\end{fulllineitems}

\index{multiref() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.multiref}\pysiglinewithargsret{\sphinxbfcode{multiref}}{\emph{s}, \emph{room}, \emph{m}}{}
Takes a ray and finds the first five reflections within a room

\end{fulllineitems}

\index{normal\_mat() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.normal_mat}\pysiglinewithargsret{\sphinxbfcode{normal\_mat}}{\emph{s}, \emph{Ncones}, \emph{Nra}, \emph{d}, \emph{dist}, \emph{h}}{}
Form a matrix of vectors representing the plane which is normal to d

\end{fulllineitems}

\index{number\_cone\_steps() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.number_cone_steps}\pysiglinewithargsret{\sphinxbfcode{number\_cone\_steps}}{\emph{s}, \emph{h}, \emph{dist}, \emph{Nra}}{}
find the number of steps taken along one normal in the cone

\end{fulllineitems}

\index{number\_steps() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.number_steps}\pysiglinewithargsret{\sphinxbfcode{number\_steps}}{\emph{s}, \emph{meshwidth}}{}
The number of steps along the ray between intersection points

\end{fulllineitems}

\index{obst\_collision\_point() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.obst_collision_point}\pysiglinewithargsret{\sphinxbfcode{obst\_collision\_point}}{\emph{s}, \emph{surface}}{}
intersection of the ray with a wall\_segment

\end{fulllineitems}

\index{ray\_length() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.ray_length}\pysiglinewithargsret{\sphinxbfcode{ray\_length}}{\emph{s}, \emph{inter}}{}
The length of the ray upto the intersection

\end{fulllineitems}

\index{raytest() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.raytest}\pysiglinewithargsret{\sphinxbfcode{raytest}}{\emph{s}, \emph{room}, \emph{err}}{}
Checks the reflection for errors

\end{fulllineitems}

\index{ref\_angle() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.ref_angle}\pysiglinewithargsret{\sphinxbfcode{ref\_angle}}{\emph{s}, \emph{room}}{}
Find the reflection angle of the most recent intersected ray.

\end{fulllineitems}

\index{reflect\_calc() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.reflect_calc}\pysiglinewithargsret{\sphinxbfcode{reflect\_calc}}{\emph{s}, \emph{room}}{}
finds the reflection of the ray inside a room

\end{fulllineitems}

\index{room\_collision\_point() (Rays.Ray method)}

\begin{fulllineitems}
\phantomsection\label{index:Rays.Ray.room_collision_point}\pysiglinewithargsret{\sphinxbfcode{room\_collision\_point}}{\emph{s}, \emph{room}}{}
The closest intersection out of the possible intersections with
the wall\_segments in room. Returns the intersection point and the
wall intersected with

\end{fulllineitems}


\end{fulllineitems}



\chapter{Room}
\label{index:room}\label{index:module-Room}\index{Room (module)}
Code to construct the mesh of the room


\chapter{Mesh}
\label{index:module-DictionarySparseMatrix}\label{index:mesh}\index{DictionarySparseMatrix (module)}\index{DS (class in DictionarySparseMatrix)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS}\pysiglinewithargsret{\sphinxstrong{class }\sphinxcode{DictionarySparseMatrix.}\sphinxbfcode{DS}}{\emph{s}, \emph{Nx=1}, \emph{Ny=1}, \emph{Nz=1}, \emph{na=1}, \emph{nb=1}}{}
The DS class is a dictionary of sparse matrices.
The keys for the dictionary are (i,j,k) such that i is in {[}0,Nx{]},
j is in {[}0, Ny{]}, and k is in {[}0,Nz{]}.
\index{asin() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.asin}\pysiglinewithargsret{\sphinxbfcode{asin}}{\emph{s}}{}
Finds arcsin(s) for all terms theta != 0 in the DS s. Since     all angles are in {[}0,pi/2{]} arcsin is not a problem.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
DSM with the same dimensions as s, with arcsin(s)=theta in      the same positions as the corresponding theta terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{cos() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.cos}\pysiglinewithargsret{\sphinxbfcode{cos}}{\emph{s}}{}
Finds cos(theta) for all terms theta != 0 in the DS s.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A DSM with the same dimensions with cos(theta) in the      same position as the corresponding theta terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{dense() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.dense}\pysiglinewithargsret{\sphinxbfcode{dense}}{\emph{s}}{}
Fills the DSM s.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A dense Nx*Ny*Nz*na*nb array with matching nonzero terms to      the sparse matrix s and zeroes elsewhere.

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_DSM\_divideby\_vec() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.dict_DSM_divideby_vec}\pysiglinewithargsret{\sphinxbfcode{dict\_DSM\_divideby\_vec}}{\emph{s}, \emph{vec}}{}
Divide every column of the DSM s elementwise with the vector vec.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{vec}} -- a row vector with length na.

\item[{Return type}] \leavevmode
a DSM `out' with the same dimensions as s.

\item[{Returns}] \leavevmode
out{[}x,y,z,k,j{]}=DSM{[}x,y,z,k,j{]}/vec{[}k{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{dict\_vec\_divideby\_DSM() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.dict_vec_divideby_DSM}\pysiglinewithargsret{\sphinxbfcode{dict\_vec\_divideby\_DSM}}{\emph{s}, \emph{vec}}{}
Every column of the DSM s divides elementwise the vector vec.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{vec}} -- a row vector with length na.

\item[{Return type}] \leavevmode
a DSM `out' with the same dimensions as s.

\item[{Returns}] \leavevmode
out{[}x,y,z,k,j{]}=vec{[}k{]}/DSM{[}x,y,z,k,j{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{nonzero() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.nonzero}\pysiglinewithargsret{\sphinxbfcode{nonzero}}{\emph{s}}{}
Find the indices of the nonzero terms in the DSM s.
\begin{quote}

\begin{notice}{note}{Note:}
The indices are found by iterating through all keys (x,y,z)           for the DSM s and finding the nonzero indices of the           corresponding sparse matrix. These indices are then combinded           with the x,y,z key and stacked to create an 5xN array of all           the nonzero terms in the DSM, where N is the number of nonzero           terms.
\end{notice}
\end{quote}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
indices={[} {[}x1,y1,z1,k1,j1{]},...,{[}xn,yn,zn,kn,jn{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{nonzeroMat() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.nonzeroMat}\pysiglinewithargsret{\sphinxbfcode{nonzeroMat}}{\emph{s}, \emph{cor}}{}
Find the indices of the nonzero terms for part of the DSM s.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{cor}} -- the part of s that you want the nonzero indices for.

\end{description}\end{quote}

The indices are found by using the :func: nonzero() function on s{[}cor{]}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
indices={[} {[}x1,y1,z1,k1,j1{]},...,{[}xn,yn,zn,kn,jn{]}{]}

\end{description}\end{quote}

\end{fulllineitems}

\index{save\_dict() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.save_dict}\pysiglinewithargsret{\sphinxbfcode{save\_dict}}{\emph{s}, \emph{filename\_}}{}
Save the DSM s.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{filename}} -- the name of the file to save to.

\item[{Returns}] \leavevmode
nothing

\end{description}\end{quote}

\end{fulllineitems}

\index{sin() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.sin}\pysiglinewithargsret{\sphinxbfcode{sin}}{\emph{s}}{}
Finds sin(theta) for all terms theta != 0 in the DS s.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A DSM with the same dimensions with sin(theta) in the      same position as the corresponding theta terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{sparse\_angles() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.sparse_angles}\pysiglinewithargsret{\sphinxbfcode{sparse\_angles}}{\emph{s}}{}
Finds the angles theta which are the arguments of the nonzero      complex terms in the DSM s.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A DSM with the same dimensions with theta in the same      position as the corresponding complex terms.

\end{description}\end{quote}

\end{fulllineitems}

\index{stopcheck() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.stopcheck}\pysiglinewithargsret{\sphinxbfcode{stopcheck}}{\emph{s}, \emph{i}, \emph{j}, \emph{k}, \emph{p1}, \emph{h}}{}
Check if the index {[}i,j,k{]} is valid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{i}} -- is the index for the x axis.

\item {} 
\textbf{\texttt{j}} -- is the index for the y axis.

\item {} 
\textbf{\texttt{k}} -- is the index for the z axis.

\item {} 
\textbf{\texttt{p1}} -- is the point at the end of the ray.

\item {} 
\textbf{\texttt{h}} -- is the mesh width

\end{itemize}

\item[{Returns}] \leavevmode
0 if valid, 1 if not.

\end{description}\end{quote}

\begin{notice}{note}{Todo}

add the inside check to this function
\end{notice}

\begin{notice}{note}{Todo}

add the check for the end of the ray.
\end{notice}

\end{fulllineitems}

\index{stopchecklist() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.stopchecklist}\pysiglinewithargsret{\sphinxbfcode{stopchecklist}}{\emph{s}, \emph{ps}, \emph{p1}, \emph{h}, \emph{p3}, \emph{n}}{}
Check if the list of points is valid.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{\texttt{ps}} -- the indices for the points in the list

\item {} 
\textbf{\texttt{p1}} -- the end of the ray

\item {} 
\textbf{\texttt{h}} -- the meshwidth

\item {} 
\textbf{\texttt{p3}} -- the points on the cone vectors

\item {} 
\textbf{\texttt{n}} -- the normal vectors forming the cone.

\end{itemize}

\end{description}\end{quote}

start=0 if no points were valid if at least 1 point was valid,
ps={[}{[}i1,j1,k1{]},...,{[}in,jn,kn{]}{]} the indices of the valid points,
p3={[}{[}x1,y1,z1{]},...,{[}xn,yn,zn{]}{]} co-ordinates of the valid points,
N={[}n0,...,Nn{]} the normal vectors corresponding to the valid points.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
start, ps, p3, N

\end{description}\end{quote}

\end{fulllineitems}

\index{vec\_multiply() (DictionarySparseMatrix.DS method)}

\begin{fulllineitems}
\phantomsection\label{index:DictionarySparseMatrix.DS.vec_multiply}\pysiglinewithargsret{\sphinxbfcode{vec\_multiply}}{\emph{s}, \emph{vec}}{}
Multiply every column of the DSM s elementwise with the
vector vec.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{\texttt{a}} -- vec: a row vector with length na.

\item[{Return type}] \leavevmode
A DSM `out' with the same dimensions as s.

\item[{Returns}] \leavevmode
out{[}x,y,z,k,j{]}=vec{[}k{]}*DSM{[}x,y,z,k,j{]}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Reflection}
\label{index:module-reflection}\label{index:reflection}\index{reflection (module)}
Code to Reflect a line in an edge without using Shapely
\index{errorcheck() (in module reflection)}

\begin{fulllineitems}
\phantomsection\label{index:reflection.errorcheck}\pysiglinewithargsret{\sphinxcode{reflection.}\sphinxbfcode{errorcheck}}{\emph{err}, \emph{ray}, \emph{ref}, \emph{normedge}}{}
Take the input ray and output ray and the normal to the edge,
check that both vectors have the same angle to the normal

\end{fulllineitems}

\index{refangle() (in module reflection)}

\begin{fulllineitems}
\phantomsection\label{index:reflection.refangle}\pysiglinewithargsret{\sphinxcode{reflection.}\sphinxbfcode{refangle}}{\emph{line}, \emph{obst}}{}
Find the reflection angle for the line reflection on the surface obst

\end{fulllineitems}

\index{test3() (in module reflection)}

\begin{fulllineitems}
\phantomsection\label{index:reflection.test3}\pysiglinewithargsret{\sphinxcode{reflection.}\sphinxbfcode{test3}}{}{}
angle test

\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{d}
\item {\texttt{DictionarySparseMatrix}}, \pageref{index:module-DictionarySparseMatrix}
\indexspace
\bigletter{p}
\item {\texttt{ParameterInput}}, \pageref{index:module-ParameterInput}
\indexspace
\bigletter{r}
\item {\texttt{Rays}}, \pageref{index:module-Rays}
\item {\texttt{RayTracerMainProgram}}, \pageref{index:module-RayTracerMainProgram}
\item {\texttt{reflection}}, \pageref{index:module-reflection}
\item {\texttt{Room}}, \pageref{index:module-Room}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
