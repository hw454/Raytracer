
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Welcome to DSMRayTracerDoc’s documentation! &#8212; DSMRayTracerDoc 0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="welcome-to-dsmraytracerdoc-s-documentation">
<h1>Welcome to DSMRayTracerDoc’s documentation!<a class="headerlink" href="#welcome-to-dsmraytracerdoc-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
</div>
<div class="section" id="module-RayTracerMainProgram">
<span id="main-program"></span><h1>Main Program<a class="headerlink" href="#module-RayTracerMainProgram" title="Permalink to this headline">¶</a></h1>
<p>Code to trace rays around a room. This code uses:</p>
<ul class="simple">
<li><p>the function <a class="reference internal" href="#RayTracerMainProgram.RayTracer" title="RayTracerMainProgram.RayTracer"><code class="xref py py-func docutils literal notranslate"><span class="pre">RayTracer()</span></code></a> to compute the points for   the ray trajectories.</p></li>
<li><p>the function <a class="reference internal" href="#RayTracerMainProgram.MeshProgram" title="RayTracerMainProgram.MeshProgram"><code class="xref py py-func docutils literal notranslate"><span class="pre">MeshProgram()</span></code></a> to compute the points for   the ray trajectories and iterate along the rays storing the   information in a <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DictionarySparseMatrix.DS</span></code></a> and outputing   the points and mesh.</p></li>
<li><p>the function <a class="reference internal" href="#RayTracerMainProgram.power_grid" title="RayTracerMainProgram.power_grid"><code class="xref py py-func docutils literal notranslate"><span class="pre">power_grid()</span></code></a> which loads the last saved   and loads the antenna and obstacle physical parameters from   <a class="reference internal" href="#ParameterInput.ObstacleCoefficients" title="ParameterInput.ObstacleCoefficients"><code class="xref py py-func docutils literal notranslate"><span class="pre">ParameterInput.ObstacleCoefficients()</span></code></a>. It uses these and   the functions <a class="reference internal" href="#RayTracerMainProgram.RefCoefComputation" title="RayTracerMainProgram.RefCoefComputation"><code class="xref py py-func docutils literal notranslate"><span class="pre">RefCoefComputation()</span></code></a> which output Rper   and Rpar the perpendicular and parallel to polarisation reflection   coefficients, and the function <a class="reference internal" href="#RayTracerMainProgram.RefCombine" title="RayTracerMainProgram.RefCombine"><code class="xref py py-func docutils literal notranslate"><span class="pre">RefCombine()</span></code></a> to   get the loss from reflection for each ray segment entering each grid   point. This is then combine with the distance of each raysegments   travel from the mesh and the antenna gains to get the Power in   decibels.</p></li>
<li><p>The ray points from <a class="reference internal" href="#RayTracerMainProgram.RayTracer" title="RayTracerMainProgram.RayTracer"><code class="xref py py-func docutils literal notranslate"><span class="pre">RayTracer()</span></code></a> are saved as:
‘RayPoints<strong>Nra</strong>Refs<strong>Nre</strong>n.npy’ with <strong>Nra</strong> replaced by the     number of rays and <strong>Nre</strong> replaced by the number of reflections.</p></li>
<li><p>The ray points from <a class="reference internal" href="#RayTracerMainProgram.MeshProgram" title="RayTracerMainProgram.MeshProgram"><code class="xref py py-func docutils literal notranslate"><span class="pre">MeshProgram()</span></code></a> are saved as:
‘RayMeshPoints<strong>Nra</strong>Refs<strong>Nre</strong>n.npy’ with <strong>Nra</strong> replaced     by the     number of rays and <strong>Nre</strong> replaced by the number of reflections.     The mesh is saved as ‘DSM<strong>Nra</strong>Refs<strong>Nre</strong>m.npy’.</p></li>
</ul>
<dl class="function">
<dt id="RayTracerMainProgram.MeshProgram">
<code class="sig-prename descclassname">RayTracerMainProgram.</code><code class="sig-name descname">MeshProgram</code><span class="sig-paren">(</span><em class="sig-param">plottype=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#MeshProgram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.MeshProgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Refect rays and output the Mesh containing ray information.</p>
<p>Parameters for the raytracer are input in <a class="reference internal" href="#module-ParameterInput" title="ParameterInput"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ParameterInput</span></code></a>
The raytracing parameters defined in this module are saved and then loaded.</p>
<ul class="simple">
<li><p>‘Raytracing.npy’ - An array of 4 floats which is saved to   [Nra (number of rays), Nre (number of reflections),   h (relative meshwidth),   L (room length scale, the longest axis has been rescaled to 1 and this   is it’s original length)]</p></li>
<li><p>‘Obstacles.npy’  - An array for 3x3x1 arrays containing co-ordinates   forming triangles which form the obstacles. This is saved to Oblist   (The obstacles which are within the outerboundary )</p></li>
<li><p>‘Origin.npy’     - A 3x1 array for the co-ordinate of the source.   This is saved to Tx  (The location of the source antenna and origin   of every ray)</p></li>
<li><p>‘OuterBoundary.npy’ - An array for 3x3x1 arrays containing   co-ordinates forming triangles which form the obstacles. This is   saved to OuterBoundary   (The Obstacles forming the outer boundary of   the room )</p></li>
</ul>
<p>Put the two arrays of obstacles into one array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Oblist</span><span class="o">=</span><span class="p">[</span><span class="n">Oblist</span><span class="p">,</span><span class="n">OuterBoundary</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p>‘Directions.npy’ - An Nrax3x1 array containing the vectors which   correspond to the initial direction of each ray. This is save to Direc.</p></li>
</ul>
<p>A room is initialised with <em>Oblist</em> using the py:class:<cite>Room.room</cite>   class in <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Room</span></code></a>.</p>
<p>The number of obstacles and the number of x, y and z steps is found</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Nob</span><span class="o">=</span><span class="n">Room</span><span class="o">.</span><span class="n">Nob</span>
<span class="n">Nx</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Room</span><span class="o">.</span><span class="n">maxxleng</span><span class="p">()</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
<span class="n">Ny</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Room</span><span class="o">.</span><span class="n">maxyleng</span><span class="p">()</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
<span class="n">Nz</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Room</span><span class="o">.</span><span class="n">maxzleng</span><span class="p">()</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<p>Initialise a <cite>DSM</cite>.   <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DictionarySparseMatrix.DS</span></code></a> with the   number of spaces in the x, y and z axis Nx, Ny, Nz, the number of   obstacles Nob, the number of reflections Nre and the number of rays Nra.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Mesh</span><span class="o">=</span><span class="n">DSM</span><span class="o">.</span><span class="n">DS</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">Nob</span><span class="o">*</span><span class="n">Nre</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nb">int</span><span class="p">((</span><span class="n">Nre</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Nra</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Find the reflection points of the rays and store the distance and   reflection angles of the rays in the Mesh. Use the   py:func:<cite>Room.room.ray_mesh_bounce</cite> function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Rays</span><span class="p">,</span> <span class="n">Mesh</span><span class="o">=</span><span class="n">Room</span><span class="o">.</span><span class="n">ray_mesh_bounce</span><span class="p">(</span><span class="n">Tx</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">Nre</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">Nra</span><span class="p">),</span><span class="n">Direc</span><span class="p">,</span><span class="n">Mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>Save the reflection points in Rays to   ‘RayMeshPoints<strong>Nra</strong>Refs<strong>Nre</strong>n.npy’ making the   substitution for <strong>Nra</strong> and <strong>Nre</strong> with their parameter values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="RayTracerMainProgram.Quality">
<code class="sig-prename descclassname">RayTracerMainProgram.</code><code class="sig-name descname">Quality</code><span class="sig-paren">(</span><em class="sig-param">plottype=''</em>, <em class="sig-param">Roomnum=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#Quality"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.Quality" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the field on a grid using enviroment parameters and the   ray Mesh.</p>
<p>Loads:</p>
<ul class="simple">
<li><p>(<em>Nra</em>= number of rays, <em>Nre</em>= number of reflections,   <em>h</em>= meshwidth, <em>L</em>= room length scale)=`Paramters/Raytracing.npy`</p></li>
<li><p>(<em>Nob</em>=number of obstacles)=`Parameters/Nob.npy`</p></li>
<li><p>(<em>Gt</em>=transmitter gains)=`Parameters/TxGains.npy`</p></li>
<li><p>(<em>freq</em>= frequency)=`Parameters/frequency.npy`</p></li>
<li><p>(<em>Freespace</em>= permittivity, permeabilty   and spead of light)=`Parameters/Freespace.npy`</p></li>
<li><p>(<em>Znobrat</em>= Znob/Z0, the ratio of the impedance of obstacles and   the impedance in freespace.) = <cite>Parameters/Znobrat.npy</cite></p></li>
<li><p>(<em>refindex</em>= the refractive index of the obstacles)=  Paramerters/refindex.npy`</p></li>
<li><p>(<em>Mesh</em>)=`DSM<strong>Nra</strong>Refs<strong>Nre</strong>m.npy`</p></li>
</ul>
<p>Method:
* Initialise Grid using the number of x, y, and z steps in <em>Mesh</em>.
* Use the function <code class="xref py py-func docutils literal notranslate"><span class="pre">DictionarySparseMatrix.DS.power_compute()</span></code>
to compute the power.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Nx Ny x Nz numpy array of floats.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Grid</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="RayTracerMainProgram.RayTracer">
<code class="sig-prename descclassname">RayTracerMainProgram.</code><code class="sig-name descname">RayTracer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#RayTracer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.RayTracer" title="Permalink to this definition">¶</a></dt>
<dd><p>Refect rays and output the points of reflection.</p>
<p>Parameters for the raytracer are input in   <a class="reference internal" href="#ParameterInput.DeclareParameters" title="ParameterInput.DeclareParameters"><code class="xref py py-func docutils literal notranslate"><span class="pre">ParameterInput.DeclareParameters()</span></code></a> The raytracing   parameters defined in this function are saved and then loaded.</p>
<ul class="simple">
<li><p>‘Raytracing.npy’ - An array of 4 floats which is saved to   [Nra (number of rays), Nre (number of reflections),   h (relative meshwidth),   L (room length scale, the longest axis has been rescaled to 1 and this   is it’s original length)]</p></li>
<li><p>‘Obstacles.npy’  - An array for 3x3x1 arrays containing co-ordinates   forming triangles which form the obstacles. This is saved to Oblist   (The obstacles which are within the outerboundary )</p></li>
<li><p>‘Origin.npy’     - A 3x1 array for the co-ordinate of the source.   This is saved to Tx  (The location of the source antenna and origin   of every ray)</p></li>
<li><p>‘OuterBoundary.npy’ - An array for 3x3x1 arrays containing   co-ordinates forming triangles which form the obstacles. This is   saved to OuterBoundary   (The Obstacles forming the outer boundary of   the room )</p></li>
</ul>
<p>Put the two arrays of obstacles into one array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Oblist</span><span class="o">=</span><span class="p">[</span><span class="n">Oblist</span><span class="p">,</span><span class="n">OuterBoundary</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p>‘Directions.npy’ - An Nrax3x1 array containing the vectors which   correspond to the initial direction of each ray. This is save to Direc.</p></li>
</ul>
<p>A room is initialised with <em>Oblist</em> using the <code class="xref py py-class docutils literal notranslate"><span class="pre">room</span></code>   class in <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Room</span></code></a>.</p>
<p>Find the reflection points of the rays using   <code class="xref py py-func docutils literal notranslate"><span class="pre">room.ray_bounce()</span></code> function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Rays</span><span class="p">,</span> <span class="n">Mesh</span><span class="o">=</span><span class="n">Room</span><span class="o">.</span><span class="n">ray_bounce</span><span class="p">(</span><span class="n">Tx</span><span class="p">,</span><span class="n">Nre</span><span class="p">,</span><span class="n">Nra</span><span class="p">,</span><span class="n">Direc</span><span class="p">)</span>
</pre></div>
</div>
<p>Save the reflection points in Rays to   ‘RayPoints<strong>Nra</strong>Refs<strong>Nre</strong>n.npy’ making the   substitution for <strong>Nra</strong> and <strong>Nre</strong> with their parameter values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 to mark a successful run</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="RayTracerMainProgram.RefCoefComputation">
<code class="sig-prename descclassname">RayTracerMainProgram.</code><code class="sig-name descname">RefCoefComputation</code><span class="sig-paren">(</span><em class="sig-param">Mesh</em>, <em class="sig-param">plottype=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#RefCoefComputation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.RefCoefComputation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mesh of reflection coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Mesh</strong> – The DS mesh which contains the angles and distances rays   have travelled.</p>
</dd>
</dl>
<p>Load the physical parameters using
<a class="reference internal" href="#ParameterInput.ObstacleCoefficients" title="ParameterInput.ObstacleCoefficients"><code class="xref py py-func docutils literal notranslate"><span class="pre">ParameterInput.ObstacleCoefficients()</span></code></a></p>
<ul class="simple">
<li><p>Znobrat - is the vector of characteristic impedances for obstacles   divided by the characteristic impedance of air.</p></li>
<li><p>refindex - if the vector of refractive indexes for the obstacles.</p></li>
</ul>
<p>Compute the Reflection coefficients (RefCoefper,Refcoefpar) using:   <a class="reference internal" href="#DictionarySparseMatrix.ref_coef" title="DictionarySparseMatrix.ref_coef"><code class="xref py py-func docutils literal notranslate"><span class="pre">DictionarySparseMatrix.ref_coef()</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>(<a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DictionarySparseMatrix.DS</span></code></a> (Nx,Ny,Nz,na,nb)    , <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DictionarySparseMatrix.DS</span></code></a> (Nx,Ny,Nz,na,nb))</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>(RefCoefper,Refcoefpar)</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="RayTracerMainProgram.RefCombine">
<code class="sig-prename descclassname">RayTracerMainProgram.</code><code class="sig-name descname">RefCombine</code><span class="sig-paren">(</span><em class="sig-param">Rper</em>, <em class="sig-param">Rpar</em>, <em class="sig-param">plottype=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#RefCombine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.RefCombine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine reflection coefficients to get the loss from reflection   coefficient for each ray segment.</p>
<p>Take in the DS’s (<a class="reference internal" href="#module-DictionarySparseMatrix" title="DictionarySparseMatrix"><code class="xref py py-mod docutils literal notranslate"><span class="pre">DictionarySparseMatrix</span></code></a>. <code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code>)  corresponding to the reflection coefficients for all the ray   interactions (<a class="reference internal" href="#module-DictionarySparseMatrix" title="DictionarySparseMatrix"><code class="xref py py-mod docutils literal notranslate"><span class="pre">DictionarySparseMatrix</span></code></a>. <code class="xref py py-func docutils literal notranslate"><span class="pre">ref_coef(Mesh)()</span></code>).</p>
<p>Use the function <a class="reference internal" href="#module-DictionarySparseMatrix" title="DictionarySparseMatrix"><code class="xref py py-mod docutils literal notranslate"><span class="pre">DictionarySparseMatrix</span></code></a>. <code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code>.   <code class="xref py py-func docutils literal notranslate"><span class="pre">dict_col_mult()</span></code> to multiple reflection coefficients in the same column.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Combper</span><span class="o">=</span><span class="p">[</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">Rper</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">Rper</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">Rper</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">],</span>
<span class="o">...</span><span class="p">,</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">Rper</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">Rper</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">Rper</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Combpar</span><span class="o">=</span><span class="p">[</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">Rpar</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">Rpar</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">Rpar</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">],</span>
<span class="o">...</span><span class="p">,</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">Rpar</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">Rpar</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">Rpar</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Rper</strong> – The mesh corresponding to reflection coefficients   perpendicular to the polarisation.</p></li>
<li><p><strong>Rpar</strong> – The mesh corresponding to reflection coefficients   parallel to the polarisation.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(<a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DictionarySparseMatrix.DS</span></code></a> (Nx,Ny,Nz,1,nb),   <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DictionarySparseMatrix.DS</span></code></a> (Nx,Ny,Nz,na,nb))</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Combper, Combpar</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="RayTracerMainProgram.StdProgram">
<code class="sig-prename descclassname">RayTracerMainProgram.</code><code class="sig-name descname">StdProgram</code><span class="sig-paren">(</span><em class="sig-param">plottype</em>, <em class="sig-param">index=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#StdProgram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.StdProgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Refect rays and input object information output the power.</p>
<p>Parameters for the raytracer are input in <a class="reference internal" href="#module-ParameterInput" title="ParameterInput"><code class="xref py py-mod docutils literal notranslate"><span class="pre">ParameterInput</span></code></a>
The raytracing parameters defined in this module are saved and then loaded.</p>
<ul class="simple">
<li><p>‘Raytracing.npy’ - An array of 4 floats which is saved to   [Nra (number of rays), Nre (number of reflections),   h (relative meshwidth),   L (room length scale, the longest axis has been rescaled to 1 and this   is it’s original length)]</p></li>
<li><p>‘Obstacles.npy’  - An array for 3x3x1 arrays containing co-ordinates   forming triangles which form the obstacles. This is saved to Oblist   (The obstacles which are within the outerboundary )</p></li>
<li><p>‘Origin.npy’     - A 3x1 array for the co-ordinate of the source.   This is saved to Tx  (The location of the source antenna and origin   of every ray)</p></li>
<li><p>‘OuterBoundary.npy’ - An array for 3x3x1 arrays containing   co-ordinates forming triangles which form the obstacles. This is   saved to OuterBoundary   (The Obstacles forming the outer boundary of   the room )</p></li>
</ul>
<p>Put the two arrays of obstacles into one array</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Oblist</span><span class="o">=</span><span class="p">[</span><span class="n">Oblist</span><span class="p">,</span><span class="n">OuterBoundary</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li><p>‘Directions.npy’ - An Nrax3x1 array containing the vectors which   correspond to the initial direction of each ray. This is save to Direc.</p></li>
</ul>
<p>A room is initialised with <em>Oblist</em> using the py:class:<cite>Room.room</cite>   class in <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Room</span></code></a>.</p>
<p>The number of obstacles and the number of x, y and z steps is found</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Nob</span><span class="o">=</span><span class="n">Room</span><span class="o">.</span><span class="n">Nob</span>
<span class="n">Nx</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Room</span><span class="o">.</span><span class="n">maxxleng</span><span class="p">()</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
<span class="n">Ny</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Room</span><span class="o">.</span><span class="n">maxyleng</span><span class="p">()</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
<span class="n">Nz</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Room</span><span class="o">.</span><span class="n">maxzleng</span><span class="p">()</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<p>Initialise a <cite>DSM</cite>.   <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DictionarySparseMatrix.DS</span></code></a> with the   number of spaces in the x, y and z axis Nx, Ny, Nz, the number of   obstacles Nob, the number of reflections Nre and the number of rays Nra.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Mesh</span><span class="o">=</span><span class="n">DSM</span><span class="o">.</span><span class="n">DS</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">Nob</span><span class="o">*</span><span class="n">Nre</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nb">int</span><span class="p">((</span><span class="n">Nre</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Nra</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Find the reflection points of the rays and store the power Use the   py:func:<cite>Room.room.ray_mesh_bounce</cite> function.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Rays</span><span class="p">,</span> <span class="n">Mesh</span><span class="o">=</span><span class="n">Room</span><span class="o">.</span><span class="n">ray_mesh_power_bounce</span><span class="p">(</span><span class="n">Tx</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">Nre</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">Nra</span><span class="p">),</span><span class="n">Direc</span><span class="p">,</span><span class="n">Mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>Save the reflection points in Rays to   ‘RayMeshPoints<strong>Nra</strong>Refs<strong>Nre</strong>n.npy’ making the   substitution for <strong>Nra</strong> and <strong>Nre</strong> with their parameter values.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="RayTracerMainProgram.plot_grid">
<code class="sig-prename descclassname">RayTracerMainProgram.</code><code class="sig-name descname">plot_grid</code><span class="sig-paren">(</span><em class="sig-param">plottype=''</em>, <em class="sig-param">index=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#plot_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.plot_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots slices of a 3D power grid.</p>
<p>Loads <cite>Power_grid.npy</cite> and for each z step plots a heatmap of the   values at the (x,y) position.</p>
</dd></dl>

<dl class="function">
<dt id="RayTracerMainProgram.power_grid">
<code class="sig-prename descclassname">RayTracerMainProgram.</code><code class="sig-name descname">power_grid</code><span class="sig-paren">(</span><em class="sig-param">plottype=''</em>, <em class="sig-param">Roomnum=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#power_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.power_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the field on a grid using enviroment parameters and the   ray Mesh.</p>
<p>Loads:</p>
<ul class="simple">
<li><p>(<em>Nra</em>= number of rays, <em>Nre</em>= number of reflections,   <em>h</em>= meshwidth, <em>L</em>= room length scale)=`Paramters/Raytracing.npy`</p></li>
<li><p>(<em>Nob</em>=number of obstacles)=`Parameters/Nob.npy`</p></li>
<li><p>(<em>Gt</em>=transmitter gains)=`Parameters/TxGains.npy`</p></li>
<li><p>(<em>freq</em>= frequency)=`Parameters/frequency.npy`</p></li>
<li><p>(<em>Freespace</em>= permittivity, permeabilty   and spead of light)=`Parameters/Freespace.npy`</p></li>
<li><p>(<em>Znobrat</em>= Znob/Z0, the ratio of the impedance of obstacles and   the impedance in freespace.) = <cite>Parameters/Znobrat.npy</cite></p></li>
<li><p>(<em>refindex</em>= the refractive index of the obstacles)=  Paramerters/refindex.npy`</p></li>
<li><p>(<em>Mesh</em>)=`DSM<strong>Nra</strong>Refs<strong>Nre</strong>m.npy`</p></li>
</ul>
<p>Method:
* Initialise Grid using the number of x, y, and z steps in <em>Mesh</em>.
* Use the function <code class="xref py py-func docutils literal notranslate"><span class="pre">DictionarySparseMatrix.DS.power_compute()</span></code>
to compute the power.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Nx Ny x Nz numpy array of floats.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Grid</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-ParameterInput">
<span id="input-of-the-parameters"></span><h1>Input of the parameters<a class="headerlink" href="#module-ParameterInput" title="Permalink to this headline">¶</a></h1>
<p>The code saves the values for the parameters in a ray tracer</p>
<dl class="function">
<dt id="ParameterInput.BoxBuild">
<code class="sig-prename descclassname">ParameterInput.</code><code class="sig-name descname">BoxBuild</code><span class="sig-paren">(</span><em class="sig-param">xmi</em>, <em class="sig-param">xma</em>, <em class="sig-param">ymi</em>, <em class="sig-param">yma</em>, <em class="sig-param">zmi</em>, <em class="sig-param">zma</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ParameterInput.html#BoxBuild"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ParameterInput.BoxBuild" title="Permalink to this definition">¶</a></dt>
<dd><p>Input the inimum and maximum x,y, and z co-ordinates which will form a Box.
:param xmi: The minimum x co-ordinate.
:param xma: The maximum x co-ordinate.
:param ymi:The minimum y co-ordinate.
:param yma: The maximum y co-ordinate.
:param zmi: The minimum z co-ordinate.
:param zma: The maximum z co-ordinate.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Box</span><span class="o">=</span><span class="p">[</span><span class="n">T0</span><span class="p">,</span><span class="n">T1</span><span class="p">,</span><span class="o">...</span><span class="n">T12</span><span class="p">]</span>
<span class="n">TJ</span><span class="o">=</span><span class="p">[</span><span class="n">p0J</span><span class="p">,</span><span class="n">p1J</span><span class="p">,</span><span class="n">p2J</span><span class="p">]</span>
<span class="n">p0J</span><span class="o">=</span><span class="p">[</span><span class="n">x0J</span><span class="p">,</span><span class="n">y0J</span><span class="p">,</span><span class="n">z0J</span><span class="p">]</span>
<span class="n">p1J</span><span class="o">=</span><span class="p">[</span><span class="n">x1J</span><span class="p">,</span><span class="n">y1J</span><span class="p">,</span><span class="n">z1J</span><span class="p">]</span>
<span class="n">p2J</span><span class="o">=</span><span class="p">[</span><span class="n">x2J</span><span class="p">,</span><span class="n">y2J</span><span class="p">,</span><span class="n">x2J</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>12 x 3 x 3 numpy array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Box</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ParameterInput.DeclareParameters">
<code class="sig-prename descclassname">ParameterInput.</code><code class="sig-name descname">DeclareParameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ParameterInput.html#DeclareParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ParameterInput.DeclareParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>All input parameters for the ray-launching method are entered in
this function which will then save them inside a Parameters folder.</p>
<ul>
<li><p>Nra - Number of rays</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Due to need of integer steps the input number of rays can not
always be used if everything is equally spaced.</p>
</div>
</li>
<li><p>Nre - Number of reflections</p></li>
<li><p>Ns - Number of steps to split longest axis.</p></li>
<li><p>l1 - Interior obstacle scale</p></li>
<li><p>l2 - Boundary scale.</p></li>
<li><p>triangle1 - First interior obstacle</p></li>
<li><p>…</p></li>
<li><p>triangleN - Last interior obstacle</p></li>
<li><p>OuterBoundary1 - First obstacle forming the boundary of the   environment</p></li>
<li><p>…</p></li>
<li><p>OuterBoundaryN - Last obstacle forming the boundary of the   environment.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 if successfully completed.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="ParameterInput.ObstacleCoefficients">
<code class="sig-prename descclassname">ParameterInput.</code><code class="sig-name descname">ObstacleCoefficients</code><span class="sig-paren">(</span><em class="sig-param">index=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ParameterInput.html#ObstacleCoefficients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ParameterInput.ObstacleCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Input the paramters for obstacles and the antenna. To ensure   arrays are of the right length for compatibility for the   ray-launcher retrieve the ray-launching parameters in   <a class="reference internal" href="#ParameterInput.DeclareParameters" title="ParameterInput.DeclareParameters"><code class="xref py py-func docutils literal notranslate"><span class="pre">DeclareParameters()</span></code></a></p>
<p>Load:</p>
<ul class="simple">
<li><p>‘Obstacles.npy’     -Co-ordinates of obstacles in the room</p></li>
<li><p>‘OuterBoundary.npy’ - Co-ordinates of the walls of the room</p></li>
<li><p>‘Raytracing.npy’    -[Nra (number of rays), Nre (number of reflections),   h (relative meshwidth)]</p></li>
</ul>
<p>Calculate:</p>
<ul class="simple">
<li><p>Nob=len([Obstacles,OuterBoundary])</p></li>
</ul>
<p>Input:</p>
<ul class="simple">
<li><p><cite>Freespace</cite> -[mu0 (permeability of air),   eps0 (permittivity of air),Z0 (characteristic impedance of air),   c (speed of light)]</p></li>
<li><p><cite>frequency</cite> - <span class="math notranslate nohighlight">\(\omega\)</span> angular frequency of the wave out   the antenna.</p></li>
<li><p><cite>mur</cite>       - <span class="math notranslate nohighlight">\(\mu_r\)</span> The relative permeability for all obstacles.   This should be an array with the same number of terms as the number   of obstacles Nob.</p></li>
<li><p><cite>epsr</cite>     - <span class="math notranslate nohighlight">\(\epsilon_r\)</span> The relative permittivity for each obstacle.   This should be an array with the same number of terms as the number   of obstacles Nob.</p></li>
<li><p><cite>sigma</cite>     - <span class="math notranslate nohighlight">\(\sigma\)</span> The electrical conductivity of the obstacles.   This should be an array with the same number of terms as the number   of obstacles.</p></li>
<li><p><cite>Gt</cite>        - The gains of the antenna. The should be an array with   the same number of terms as the number of rays Nra.</p></li>
</ul>
<p>Calculate:</p>
<ul class="simple">
<li><p><cite>eps0</cite>   - <span class="math notranslate nohighlight">\(\epsilon_0=\frac{1}{\mu_0 c^2}\)</span>  permittivity of   freespace.</p></li>
<li><p><cite>Z0</cite>     - <span class="math notranslate nohighlight">\(Z_0=\sqrt{\frac{\mu_0}{\epsilon_0}}\)</span> characteristic   impedance of freespace.</p></li>
<li><p><cite>refindex</cite> - The refreactive index   <span class="math notranslate nohighlight">\(n=\sqrt{\mu_r\epsilon_r}\)</span></p></li>
<li><p><cite>Znobrat</cite>- The relative impedance of the obstacles given by,
<span class="math notranslate nohighlight">\(\hat{Z}_{Nob}=\frac{Z_{Nob}}{Z_0}\)</span>. The impedance of each     obstacle <span class="math notranslate nohighlight">\(Z_{Nob}\)</span> is given by     <span class="math notranslate nohighlight">\(Z_{Nob}=\sqrt{\frac{i\omega\mu_0\mu_r}{\sigma+i\epsilon_0\epsilon_r}}\)</span>.</p></li>
</ul>
<p>The Znobrat and refindex terms are then reformatted so that they   repeat Nre times with an extra term. The extra term corresponds to   the line of sight path. This makes them the same length as a column   in a matrix in a <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DictionarySparseMatrix.DS</span></code></a>.   Each term corresponds to a possible obstacle reflection combination.</p>
<p>The Gains matrix is also reformated to that it repeats (Nre+1) times.   This corresponds to every possible ray reflection number combination   This makes them the same length as a row in a matrix in a   <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DictionarySparseMatrix.DS</span></code></a>.   Each term corresponds to a possible obstacle reflection combination.</p>
<p>Save:
* <cite>frequency.npy</cite>- The angular frequency <span class="math notranslate nohighlight">\(\omega\)</span>.
* <cite>refindex.npy</cite> - The refractive index of the obstacles.
* <cite>Znobrat.npy</cite>  - The relative characteristic impedance.
* <cite>TxGains.npy</cite>  - The gains of the antenna.
* <cite>Freespace.npy</cite>- The freespace parameters.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Freespace</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu0</span><span class="p">,</span><span class="n">eps0</span><span class="p">,</span><span class="n">Z0</span><span class="p">,</span><span class="n">c</span><span class="p">])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 if successfully completed.</p>
</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-Rays">
<span id="rays"></span><h1>Rays<a class="headerlink" href="#module-Rays" title="Permalink to this headline">¶</a></h1>
<p>Code to construct the ray-tracing objects rays</p>
<dl class="class">
<dt id="Rays.Ray">
<em class="property">class </em><code class="sig-prename descclassname">Rays.</code><code class="sig-name descname">Ray</code><span class="sig-paren">(</span><em class="sig-param">origin</em>, <em class="sig-param">direc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray" title="Permalink to this definition">¶</a></dt>
<dd><p>A ray is a representation of the the trajectory of a reflecting   line and its reflections.
Ray.points is an array of co-ordinates representing
the collision points with the last term being the direction the ray ended in.
And Ray.reflections is an array containing tuples of the angles of incidence
and the number referring to the position of the obstacle in the obstacle list</p>
<dl class="method">
<dt id="Rays.Ray.mesh_multiref">
<code class="sig-name descname">mesh_multiref</code><span class="sig-paren">(</span><em class="sig-param">room</em>, <em class="sig-param">Nre</em>, <em class="sig-param">Mesh</em>, <em class="sig-param">Nra</em>, <em class="sig-param">nra</em>, <em class="sig-param">deltheta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.mesh_multiref"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.mesh_multiref" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a ray and finds the first Nre reflections within a room.
As each reflection is found the ray is stepped through and
information added to the Mesh.
:param room: Obstacle co-ordinates, <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Room</span></code></a>. <code class="xref py py-class docutils literal notranslate"><span class="pre">room</span></code>.
:param Nre: Number of reflections, integer.
:param Mesh: A grid with corresponding sparse matrices, this     is a <a class="reference internal" href="#module-DictionarySparseMatrix" title="DictionarySparseMatrix"><code class="xref py py-mod docutils literal notranslate"><span class="pre">DictionarySparseMatrix</span></code></a>. <code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code> object.
:param Nra: Total number of rays, integer.</p>
<p>Method:</p>
<ul class="simple">
<li><p>Create a temporary vector vec.</p></li>
<li><p>For each ray segment use     <code class="xref py py-func docutils literal notranslate"><span class="pre">mesh_singleray(room,Mesh,dist,vec,Nra,Nre,nra)()</span></code> to      segment storing r*calcvec in the Mesh. With r being the distance      ray travelled to get  centre of the grid point the ray has gone      through.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.mesh_power_multiref">
<code class="sig-name descname">mesh_power_multiref</code><span class="sig-paren">(</span><em class="sig-param">room</em>, <em class="sig-param">Nre</em>, <em class="sig-param">Mesh</em>, <em class="sig-param">Nra</em>, <em class="sig-param">it</em>, <em class="sig-param">Znobrat</em>, <em class="sig-param">refindex</em>, <em class="sig-param">Antpar</em>, <em class="sig-param">refcoef</em>, <em class="sig-param">deltheta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.mesh_power_multiref"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.mesh_power_multiref" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a ray and finds the first Nre reflections within a room.
As each reflection is found the ray is stepped through and
information added to the Mesh.
:param room: Obstacle co-ordinates, <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Room</span></code></a>. <code class="xref py py-class docutils literal notranslate"><span class="pre">room</span></code>.
:param Nre: Number of reflections, integer.
:param Grid: a Nx*Ny*Nz array which will contain power values
:param Nra: total number of rays.
:param it: current ray number.
:param Znobrat: The array with the ratio of the impedance of an     obstacle over the impedance of air.
:param refindex: Array with the refractive indices of an obstacle.
:param Antpar: array with antenna parameters - scaled wavenumber, wavelength, lengthscale.
:param Gt: transmitter gains.</p>
<p>Method:</p>
<ul class="simple">
<li><p>Start with the initial power.</p></li>
<li><p>For each ray segment use     <code class="xref py py-func docutils literal notranslate"><span class="pre">mesh_power_singleray(room,Mesh,dist,vec,Nra,Nre,nra)()</span></code> to      store the power along the ray.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>grid</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.mesh_power_singleray">
<code class="sig-name descname">mesh_power_singleray</code><span class="sig-paren">(</span><em class="sig-param">room</em>, <em class="sig-param">_Grid</em>, <em class="sig-param">dist</em>, <em class="sig-param">RefCoef</em>, <em class="sig-param">Nra</em>, <em class="sig-param">nre</em>, <em class="sig-param">Nre</em>, <em class="sig-param">nra</em>, <em class="sig-param">refindex</em>, <em class="sig-param">Znobrat</em>, <em class="sig-param">khat</em>, <em class="sig-param">L</em>, <em class="sig-param">deltheta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.mesh_power_singleray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.mesh_power_singleray" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate between two intersection points and store the ray     information in the Mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>room</strong> – <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Room</span></code></a>. <code class="xref py py-class docutils literal notranslate"><span class="pre">room</span></code> object which     contains the co-ordinates of the obstacles.</p></li>
<li><p><strong>Grid</strong> – <a class="reference internal" href="#module-DictionarySparseMatrix" title="DictionarySparseMatrix"><code class="xref py py-mod docutils literal notranslate"><span class="pre">DictionarySparseMatrix</span></code></a>. <code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code>     which will store the field in the parallel and perdenicular to     polarisation components at each <span class="math notranslate nohighlight">\((x,y,z)\)</span> position.</p></li>
<li><p><strong>dist</strong> – A scalar variable which is the distance the ray     travelled at the start of the ray segment.</p></li>
<li><p><strong>RefCoef</strong> – A vector containing the product of the reflection     coefficients in the perpendicular and parallel directions to the     polarisation.</p></li>
<li><p><strong>Nra</strong> – Total number of rays.</p></li>
<li><p><strong>Nre</strong> – Maximum number of reflections.</p></li>
<li><p><strong>nra</strong> – Current ray number.</p></li>
</ul>
</dd>
</dl>
<p>Method:</p>
<ul>
<li><p>Calculate <span class="math notranslate nohighlight">\(\theta\)</span> the reflection angle using     <code class="xref py py-func docutils literal notranslate"><span class="pre">reflect_angle(room)()</span></code>.</p></li>
<li><p>Find the number of steps <span class="math notranslate nohighlight">\(Ns\)</span> to the end of the ray segment     using <code class="xref py py-func docutils literal notranslate"><span class="pre">number_steps(meshwidth)()</span></code>.</p></li>
<li><p>Compute an array of normal vectors representing the ray cone.</p></li>
<li><p>Check the reflection number:</p>
<ul class="simple">
<li><p>If 0 then the <span class="math notranslate nohighlight">\(RefCoef\)</span> term is 1.</p></li>
<li><p>Else set <span class="math notranslate nohighlight">\(RefCoef\)</span></p></li>
</ul>
</li>
<li><p>Step along the ray, For <span class="math notranslate nohighlight">\(m1\in[0,Ns):\)</span></p>
<ul>
<li><p>Check if the ray point is outside the domain.</p></li>
<li><p>Calculate the co-ordinate of the centre.</p></li>
<li><p>Recalculate distance to be for the centre point       <span class="math notranslate nohighlight">\(Mesh[i1,j1,k1,:,col]=np.sqrt(np.dot((p0-p2),(p0-p2)))*calcvec\)</span>.</p></li>
<li><p>For each normal:</p>
<ul class="simple">
<li><p>Find the next cone point <span class="math notranslate nohighlight">\(p3\)</span> from the previous point         <span class="math notranslate nohighlight">\(p1\)</span>, using the distance through a grid cube         <span class="math notranslate nohighlight">\(\alpha\)</span>. This is given by:math:<cite>p3=p1+m2*alpha*norm</cite>.</p></li>
<li><p>Find the co-ordinate for the centre of the grid point z         corresponding to the <span class="math notranslate nohighlight">\(p3\)</span>’s.</p></li>
<li><p>Find the distance to this centre point.</p></li>
<li><p>Set the column <span class="math notranslate nohighlight">\(nra*Nre+nre\)</span> of the mesh term at         these grid points to the distance times the vector of         reflection angles.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Grid</span><span class="p">[</span><span class="n">cpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">cpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">cpos</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span><span class="o">+=</span><span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="n">ikr</span><span class="p">}(</span><span class="mi">1</span><span class="o">/</span><span class="n">r2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">RefCoef</span>
</pre></div>
</div>
</li>
<li><p>Find the co-ordinate for the next ray point.       <span class="math notranslate nohighlight">\(p1=p1+alpha*direc\)</span>.</p></li>
</ul>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Mesh, dist, calcvec</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.mesh_singleray">
<code class="sig-name descname">mesh_singleray</code><span class="sig-paren">(</span><em class="sig-param">room</em>, <em class="sig-param">Mesh</em>, <em class="sig-param">dist</em>, <em class="sig-param">calcvec</em>, <em class="sig-param">Nra</em>, <em class="sig-param">Nre</em>, <em class="sig-param">nra</em>, <em class="sig-param">deltheta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.mesh_singleray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.mesh_singleray" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate between two intersection points and store the ray     information in the Mesh</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>room</strong> – <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal notranslate"><span class="pre">Room</span></code></a>. <code class="xref py py-class docutils literal notranslate"><span class="pre">room</span></code> object which     contains the co-ordinates of the obstacles.</p></li>
<li><p><strong>Mesh</strong> – <a class="reference internal" href="#module-DictionarySparseMatrix" title="DictionarySparseMatrix"><code class="xref py py-mod docutils literal notranslate"><span class="pre">DictionarySparseMatrix</span></code></a>. <code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code>     which will store all of the ray information.</p></li>
<li><p><strong>dist</strong> – A scalar variable which is the distance the ray     travelled at the start of the ray segment.</p></li>
<li><p><strong>calcvec</strong> – A vector containing <span class="math notranslate nohighlight">\(e^{i     heta}\)</span> terms     for reflection angles :math:`  heta`. These terms are stored     in row nre*Nob+nob with nre being the current reflection number,     Nob the maximum obstacle number and nob the number of the     obstacle which was hit with the corresponding angle.</p></li>
<li><p><strong>Nra</strong> – Total number of rays.</p></li>
<li><p><strong>Nre</strong> – Maximum number of reflections.</p></li>
<li><p><strong>nra</strong> – Current ray number.</p></li>
</ul>
</dd>
</dl>
<p>Method:</p>
<ul>
<li><p>Calculate <span class="math notranslate nohighlight">\(\theta\)</span> the reflection angle using     <code class="xref py py-func docutils literal notranslate"><span class="pre">reflect_angle(room)()</span></code>.</p></li>
<li><p>Find the number of steps <span class="math notranslate nohighlight">\(Ns\)</span> to the end of the ray segment     using <code class="xref py py-func docutils literal notranslate"><span class="pre">number_steps(meshwidth)()</span></code>.</p></li>
<li><p>Compute an array of normal vectors representing the ray cone.</p></li>
<li><p>Check the reflection number:</p>
<ul class="simple">
<li><p>If 0 then the <span class="math notranslate nohighlight">\(calcvec[0]\)</span> term is exp(1j*pi*0.5).</p></li>
<li><p>Else set <span class="math notranslate nohighlight">\(calcvec[nre*Nob+nob]=e^{i \theta}\)</span>.</p></li>
</ul>
</li>
<li><p>Step along the ray, For <span class="math notranslate nohighlight">\(m1\in[0,Ns):\)</span></p>
<ul>
<li><p>Check if the ray point is outside the domain.</p></li>
<li><p>Calculate the co-ordinate of the centre.</p></li>
<li><p>Recalculate distance to be for the centre point       <span class="math notranslate nohighlight">\(Mesh[i1,j1,k1,:,col]=np.sqrt(np.dot((p0-p2),(p0-p2)))*calcvec\)</span>.</p></li>
<li><p>For each normal:</p>
<ul class="simple">
<li><p>Find the next cone point <span class="math notranslate nohighlight">\(p3\)</span> from the previous point         <span class="math notranslate nohighlight">\(p1\)</span>, using the distance through a grid cube         <span class="math notranslate nohighlight">\(\alpha\)</span>. This is given by:math:<cite>p3=p1+m2*alpha*norm</cite>.</p></li>
<li><p>Find the co-ordinate for the centre of the grid point z         corresponding to the <span class="math notranslate nohighlight">\(p3\)</span>’s.</p></li>
<li><p>Find the distance to this centre point.</p></li>
<li><p>Set the column <span class="math notranslate nohighlight">\(nra*Nre+nre\)</span> of the mesh term at         these grid points to the distance times the vector of         reflection angles.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Mesh</span><span class="p">[</span><span class="n">cpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">cpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">cpos</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="p">],:,</span><span class="n">col</span><span class="p">]</span><span class="o">=</span><span class="n">r2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">calcvec</span>
</pre></div>
</div>
</li>
<li><p>Find the co-ordinate for the next ray point.       <span class="math notranslate nohighlight">\(p1=p1+alpha*direc\)</span>.</p></li>
</ul>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Mesh, dist, calcvec</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.multiref">
<code class="sig-name descname">multiref</code><span class="sig-paren">(</span><em class="sig-param">room</em>, <em class="sig-param">Nre</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.multiref"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.multiref" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a ray and finds the first five reflections within a room.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>room</strong> – <a class="reference internal" href="#Room.room" title="Room.room"><code class="xref py py-class docutils literal notranslate"><span class="pre">Room.room</span></code></a> object which     contains all the obstacles in the room.</p></li>
<li><p><strong>Nre</strong> – The number of reflections. Integer value.</p></li>
</ul>
</dd>
</dl>
<p>Using the function <code class="xref py py-func docutils literal notranslate"><span class="pre">reflect_calc(room)()</span></code> find the     co-ordinate of the reflected ray. Store this in s.points     and return whether the function was successful.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>3x1 numpy array.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>end=1 if unsuccessful, 0 is successful.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.raytest">
<code class="sig-name descname">raytest</code><span class="sig-paren">(</span><em class="sig-param">room</em>, <em class="sig-param">err</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.raytest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.raytest" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks the reflection function for errors using the test     functions in <a class="reference internal" href="#module-reflection" title="reflection"><code class="xref py py-mod docutils literal notranslate"><span class="pre">reflection</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.reflect_calc">
<code class="sig-name descname">reflect_calc</code><span class="sig-paren">(</span><em class="sig-param">room</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.reflect_calc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.reflect_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the reflection of the ray inside a room.</p>
<p>Method:</p>
<ul class="simple">
<li><p>If: the previous collision point was <em>None</em> then don’t find the     next one. Return: 1</p></li>
<li><p>Else: Compute the next collision point,</p>
<ul>
<li><p>If: the collision point doesn’t exist. Return: 1</p></li>
<li><p>Else:  save the collision point in the <a class="reference internal" href="#Rays.Ray" title="Rays.Ray"><code class="xref py py-class docutils literal notranslate"><span class="pre">Ray</span></code></a> points.       Return: 0</p></li>
</ul>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>0 or 1 indicator of success.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>0 if  reflection was computed 1 if not.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="Rays.no_cone_steps">
<code class="sig-prename descclassname">Rays.</code><code class="sig-name descname">no_cone_steps</code><span class="sig-paren">(</span><em class="sig-param">h</em>, <em class="sig-param">dist</em>, <em class="sig-param">delangle</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#no_cone_steps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.no_cone_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>find the number of steps taken along one normal in the cone</p>
</dd></dl>

<dl class="function">
<dt id="Rays.no_cones">
<code class="sig-prename descclassname">Rays.</code><code class="sig-name descname">no_cones</code><span class="sig-paren">(</span><em class="sig-param">h</em>, <em class="sig-param">dist</em>, <em class="sig-param">delangle</em>, <em class="sig-param">refangle</em>, <em class="sig-param">nref</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#no_cones"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.no_cones" title="Permalink to this definition">¶</a></dt>
<dd><p>find the number of steps taken along one normal in the cone</p>
</dd></dl>

<dl class="function">
<dt id="Rays.no_steps">
<code class="sig-prename descclassname">Rays.</code><code class="sig-name descname">no_steps</code><span class="sig-paren">(</span><em class="sig-param">alpha</em>, <em class="sig-param">segleng</em>, <em class="sig-param">dist</em>, <em class="sig-param">delangle</em>, <em class="sig-param">refangle=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#no_steps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.no_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of steps along the ray between intersection points</p>
</dd></dl>

<dl class="function">
<dt id="Rays.singleray_test">
<code class="sig-prename descclassname">Rays.</code><code class="sig-name descname">singleray_test</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#singleray_test"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.singleray_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the stepping through a single ray.</p>
</dd></dl>

</div>
<div class="section" id="module-Room">
<span id="room"></span><h1>Room<a class="headerlink" href="#module-Room" title="Permalink to this headline">¶</a></h1>
<p>Code to construct the mesh of the room</p>
<dl class="class">
<dt id="Room.room">
<em class="property">class </em><code class="sig-prename descclassname">Room.</code><code class="sig-name descname">room</code><span class="sig-paren">(</span><em class="sig-param">obst</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room" title="Permalink to this definition">¶</a></dt>
<dd><p>A room is where the obstacle co-ordinates are contained.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>obst</strong> – is a Nobx3x[3x1] array, where Nob is the number of     obstacles.</p>
</dd>
</dl>
<p>obst[j] is a 3x[3x1] array which is 3, 3D co-ordinates   which form a triangle.</p>
<p>This array of triangles forms the obstacles in the room.</p>
<dl class="simple">
<dt>Attributes of room:</dt><dd><ul class="simple">
<li><p>s.obst=obst</p></li>
<li><p>.points[3*j]=obst[j][0]</p></li>
<li><p>s.maxlength is a 4x1 array initialised as empty. Once assigned     this is the maximum length in theroom and in the x, y, and z axis.</p></li>
<li><p>s.bounds is a 3x2 array     <span class="math notranslate nohighlight">\(s.bounds= [ [minx, miny, minz], [maxx,maxy,maxz]]\)</span></p></li>
<li><p>s.inside_points is an initial empty array. Points which are known     to be inside obstacles are added to this array later.</p></li>
<li><p>s.time is an array with the time the room was created.</p></li>
<li><p>s.meshwidth is initialised as zero but is stored once asked for     using get_meshwidth.</p></li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="Room.room.coordinate">
<code class="sig-name descname">coordinate</code><span class="sig-paren">(</span><em class="sig-param">h</em>, <em class="sig-param">i</em>, <em class="sig-param">j</em>, <em class="sig-param">k</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room.coordinate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room.coordinate" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the co-ordinate of the point at the centre of the element.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>h</strong> – the meshwdith. Once assigned this matches s.meshwidth</p></li>
<li><p><strong>i</strong> – the first index or an array corresponding to the first     index for multiple points.</p></li>
<li><p><strong>j</strong> – the second index or an array corresponding to the second     index for multiple points.</p></li>
<li><p><strong>k</strong> – the third index or an array corresponding to the third     index for multiple points.</p></li>
</ul>
</dd>
</dl>
<p>If there is only 1 i, 1 j, and 1 k,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="n">minx</span><span class="p">,</span><span class="n">miny</span><span class="p">,</span><span class="n">minz</span><span class="p">]</span> <span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mf">0.5</span><span class="p">]</span>
</pre></div>
</div>
<p>ElseIf there’s arrays for i,j, and k,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">=</span><span class="p">[[</span><span class="n">minx</span><span class="p">,</span><span class="n">miny</span><span class="p">,</span><span class="n">minz</span><span class="p">]</span> <span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">j0</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">k0</span><span class="o">+</span><span class="mf">0.5</span><span class="p">],</span><span class="o">...</span><span class="p">,</span>
  <span class="p">[</span><span class="n">minx</span><span class="p">,</span><span class="n">miny</span><span class="p">,</span><span class="n">minz</span><span class="p">]</span> <span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="p">[</span><span class="ow">in</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">jn</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">kn</span><span class="o">+</span><span class="mf">0.5</span> <span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>p</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Room.room.maxleng">
<code class="sig-name descname">maxleng</code><span class="sig-paren">(</span><em class="sig-param">a=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room.maxleng"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room.maxleng" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the maximum length in the room or axis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>a</strong> – the axis or room. a=0 maximum length in room, a=1 for     x-axis, a=2 for y-axis a=3 for z-axis.</p>
</dd>
</dl>
<p>If the maxlength[a] hasn’t been found yet find it by comparing the     between points in s.points.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>s.maxlength[a]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Room.room.position">
<code class="sig-name descname">position</code><span class="sig-paren">(</span><em class="sig-param">p</em>, <em class="sig-param">h</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room.position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room.position" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the indexing position in a mesh with width h for point p     lying in the room s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>p</strong> – =[x,y,z] the co-ordinate of the point p or an array     of <span class="math notranslate nohighlight">\(points p=[[x0,y0,z0],...,[xn,yn,zn]]\)</span></p></li>
<li><p><strong>h</strong> – is the meshwidth, once assigned this matches s.meshwidth</p></li>
</ul>
</dd>
</dl>
<p>If p is one point,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="p">[</span><span class="n">minx</span><span class="p">,</span><span class="n">miny</span><span class="p">,</span><span class="n">minz</span><span class="p">])</span><span class="o">//</span><span class="n">h</span><span class="p">,</span>
</pre></div>
</div>
<p>If p is an array of points,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="o">=</span><span class="p">[(</span><span class="n">p0</span><span class="o">-</span><span class="p">[</span><span class="n">minx</span><span class="p">,</span><span class="n">miny</span><span class="p">,</span><span class="n">minz</span><span class="p">])</span><span class="o">//</span><span class="n">h</span><span class="p">,</span><span class="o">...</span><span class="p">,(</span><span class="n">pn</span><span class="o">-</span><span class="p">[</span><span class="n">minx</span><span class="p">,</span><span class="n">miny</span><span class="p">,</span><span class="n">minz</span><span class="p">])</span><span class="o">//</span><span class="n">h</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Room.room.ray_bounce">
<code class="sig-name descname">ray_bounce</code><span class="sig-paren">(</span><em class="sig-param">Tx</em>, <em class="sig-param">Nre</em>, <em class="sig-param">Nra</em>, <em class="sig-param">directions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room.ray_bounce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room.ray_bounce" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace ray’s uniformly emitted from an origin around a room.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Nra</strong> – Number of rays</p></li>
<li><p><strong>Nre</strong> – number of reflections Nre</p></li>
<li><p><strong>directions</strong> – A Nra*3 array of the initial directions     for each ray.</p></li>
</ul>
</dd>
</dl>
<p>The multiref function is used to find the Nre reflections for     the Nra rays with the obstacles s.obst.</p>
<p><span class="math notranslate nohighlight">\(raylist=[[p00,p01,...,p0Nre],[p10,...,p1Nre],...,[pNra0,...,pNraNre]]\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>An array of the ray points.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>raylist</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Room.room.ray_mesh_bounce">
<code class="sig-name descname">ray_mesh_bounce</code><span class="sig-paren">(</span><em class="sig-param">Tx</em>, <em class="sig-param">Nre</em>, <em class="sig-param">Nra</em>, <em class="sig-param">directions</em>, <em class="sig-param">Mesh</em>, <em class="sig-param">deltheta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room.ray_mesh_bounce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room.ray_mesh_bounce" title="Permalink to this definition">¶</a></dt>
<dd><p>Traces ray’s uniformly emitted from an origin around a room.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Tx</strong> – the co-ordinate of the transmitter location</p></li>
<li><p><strong>Nra</strong> – Number of rays</p></li>
<li><p><strong>Nre</strong> – number of reflections</p></li>
<li><p><strong>directions</strong> – Nra*3 array of the initial direction for     each ray.</p></li>
<li><p><strong>Mesh</strong> – a Nx*Ny*Nz*na*nb array (actually a dictionary of     sparse matrices using class DS but built to have similar     structure to an array).</p></li>
</ul>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">na</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Nob</span><span class="o">*</span><span class="n">Nre</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nb</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">Nre</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Nra</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The rays are reflected Nre times with the obstacles s.obst.     The points of intersection with the obstacles are stored in z
raylist. This is done using the mesh_multiref function.
As each intersection is found the mesh_multiref function     forms the line segment between intersection points and the     corresponding ray cone. All mesh elements in the ray cone store     the reflection angles and the distance along the ray cone from the     source to the centre of each mesh element. This is stored in Mesh.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">Rays.mesh_multiref()</span></code> for more details on the     reflections and storage.</p>
<p>When complete the time in s.time() is assigned to the time taken     to complete the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>raylist, Mesh</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="Room.room.ray_mesh_power_bounce">
<code class="sig-name descname">ray_mesh_power_bounce</code><span class="sig-paren">(</span><em class="sig-param">Tx</em>, <em class="sig-param">Nre</em>, <em class="sig-param">Nra</em>, <em class="sig-param">directions</em>, <em class="sig-param">Grid</em>, <em class="sig-param">Znobrat</em>, <em class="sig-param">refindex</em>, <em class="sig-param">Antpar</em>, <em class="sig-param">Gt</em>, <em class="sig-param">Pol</em>, <em class="sig-param">deltheta</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room.ray_mesh_power_bounce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room.ray_mesh_power_bounce" title="Permalink to this definition">¶</a></dt>
<dd><p>Traces ray’s uniformly emitted from an origin around a room.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Tx</strong> – the co-ordinate of the transmitter location</p></li>
<li><p><strong>Nra</strong> – Number of rays</p></li>
<li><p><strong>Nre</strong> – number of reflections</p></li>
<li><p><strong>directions</strong> – Nra*3 array of the initial direction for     each ray.</p></li>
<li><p><strong>Grid</strong> – a Nx*Ny*Nz array which will contain power values</p></li>
<li><p><strong>Znobrat</strong> – The array with the ratio of the impedance of an     obstacle over the impedance of air.</p></li>
<li><p><strong>refindex</strong> – Array with the refractive indices of an obstacle.</p></li>
<li><p><strong>Antpar</strong> – array with antenna parameters - scaled wavenumber, wavelength, lengthscale.</p></li>
<li><p><strong>Gt</strong> – transmitter gains.</p></li>
</ul>
</dd>
</dl>
<p>The rays are reflected Nre times with the obstacles s.obst.     The points of intersection with the obstacles are stored in z
raylist. This is done using the mesh_multiref function.
As each intersection is found the mesh_multiref function     forms the line segment between intersection points and the     corresponding ray cone. All mesh elements in the ray cone store     the power. This is stored in Grid.
See <code class="xref py py-func docutils literal notranslate"><span class="pre">Rays.mesh_multiref()</span></code> for more details on the     reflections and storage.</p>
<p>When complete the time in s.time() is assigned to the time taken     to complete the function.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>raylist, Grid</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-DictionarySparseMatrix">
<span id="mesh"></span><h1>Mesh<a class="headerlink" href="#module-DictionarySparseMatrix" title="Permalink to this headline">¶</a></h1>
<p>Code for the dictionary of sparse matrices class <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a> which indexes like a multidimensional array but the array is sparse.  To exploit <code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy.sparse.dok_matrix`=SM</span> <span class="pre">the</span> <span class="pre">`DS</span></code> uses a key for  each x,y, z position and associates a SM.</p>
<p>This module also contains functions which are not part of the class  but act on it.</p>
<dl class="class">
<dt id="DictionarySparseMatrix.DS">
<em class="property">class </em><code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">DS</code><span class="sig-paren">(</span><em class="sig-param">Nx=1</em>, <em class="sig-param">Ny=1</em>, <em class="sig-param">Nz=1</em>, <em class="sig-param">na=1</em>, <em class="sig-param">nb=1</em>, <em class="sig-param">dt=&lt;class 'numpy.complex128'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS" title="Permalink to this definition">¶</a></dt>
<dd><p>The DS class is a dictionary of sparse matrices.
The keys for the dictionary are (i,j,k) such that i is in [0,Nx],
j is in [0, Ny], and k is in [0,Nz].
SM=DS[x,y,z] is a na*nb sparse matrix, initialised with complex128 data type.
<span class="math notranslate nohighlight">\(na=(Nob*Nre+1)\)</span>
<span class="math notranslate nohighlight">\(nb=((Nre)*(Nra)+1)\)</span>
The DS is initialised with keys Nx, Ny, and Nz to a dictionary with   keys,
<span class="math notranslate nohighlight">\(\{ (x,y,z) \forall x \in [0,Nx), y \in [0,Ny), z \in [0,Nz)\}.\)</span></p>
<p>With the value at each key being an na*nb SM.</p>
<dl class="class">
<dt id="DictionarySparseMatrix.DS.DS">
<em class="property">class </em><code class="sig-name descname">DS</code><a class="headerlink" href="#DictionarySparseMatrix.DS.DS" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Members</dt>
<dd class="field-odd"><p></p></dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.asin">
<code class="sig-name descname">asin</code><span class="sig-paren">(</span><em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.asin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.asin" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds</p>
<p><span class="math notranslate nohighlight">\(\theta=\arcsin(x)\)</span> for all terms <span class="math notranslate nohighlight">\(x != 0\)</span> in     the DS s. Since all angles     <span class="math notranslate nohighlight">\(\theta\)</span> are in <span class="math notranslate nohighlight">\([0,\pi /2]\)</span>,     <span class="math notranslate nohighlight">\(\arcsin(x)\)</span> is not a problem.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>DSM with the same dimensions as s, with     <span class="math notranslate nohighlight">\(\arcsin(s)=\theta\)</span> in      the same positions as the corresponding theta terms.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.cos">
<code class="sig-name descname">cos</code><span class="sig-paren">(</span><em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.cos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds <span class="math notranslate nohighlight">\(\cos(\theta)\)</span> for all terms     <span class="math notranslate nohighlight">\(\theta != 0\)</span> in the DS s.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A DSM with the same dimensions with     <span class="math notranslate nohighlight">\(\cos(\theta)\)</span> in the      same position as the corresponding theta terms.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.cos_asin">
<code class="sig-name descname">cos_asin</code><span class="sig-paren">(</span><em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.cos_asin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.cos_asin" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds <span class="math notranslate nohighlight">\(\cos( \asin( \theta))\)</span> for all terms     <span class="math notranslate nohighlight">\(\theta != 0\)</span> in the DS s.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A DSM with the same dimensions with     <span class="math notranslate nohighlight">\(\cos( \asin( \theta))\)</span> in the      same position as the corresponding theta terms.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.costhetat">
<code class="sig-name descname">costhetat</code><span class="sig-paren">(</span><em class="sig-param">refindex</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.costhetat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.costhetat" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes in a Mesh of angles with nonzero terms at ind. Computes
cos of thetat at those angles using the refractive index’s.
:param ind: The indices of the nonzero terms.
:param refindex: The refractive index’s of the obstacles in a vector.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SIN</span><span class="o">=</span><span class="n">sin</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">thetat</span><span class="o">=</span><span class="n">asin</span><span class="p">(</span><span class="n">SIN</span><span class="o">/</span><span class="n">refindex</span><span class="p">)</span>
<span class="n">ctht</span><span class="o">=</span><span class="n">cos</span><span class="p">(</span><span class="n">thetat</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DSM</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>ctht</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dense">
<code class="sig-name descname">dense</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dense"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dense" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the DSM s.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A dense Nx x Ny x Nz x na x nb array with matching nonzero terms to      the sparse matrix s and zeroes elsewhere.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_DSM_divideby_vec">
<code class="sig-name descname">dict_DSM_divideby_vec</code><span class="sig-paren">(</span><em class="sig-param">vec</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_DSM_divideby_vec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_DSM_divideby_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide every column of the DSM s elementwise with the vector vec.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vec</strong> – a row vector with length na.</p>
</dd>
</dl>
<p>For integers <span class="math notranslate nohighlight">\(x,y,z,k\)</span> and <span class="math notranslate nohighlight">\(j\)</span> such that,
<span class="math notranslate nohighlight">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">vec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a DSM ‘out’ with the same dimensions as s.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_col_mult_">
<code class="sig-name descname">dict_col_mult_</code><span class="sig-paren">(</span><em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_col_mult_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_col_mult_" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply all nonzero terms in a column.</p>
<p>In every grid point x,y,z of s there is a sparse matrix SM.     Take the product of all nonzero terms in each column and     keep these in a vector v.
Construct a new DS of size Nx x Ny x Nz x 1 x nb=s.shape[1].    Call this out. out[x,y,z] should be the v corresponding     to the SM in s at x,y,z.</p>
<dl class="simple">
<dt>Method:</dt><dd><ul class="simple">
<li><p>Find the <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a>. <a class="reference internal" href="#DictionarySparseMatrix.DS.nonzero" title="DictionarySparseMatrix.DS.nonzero"><code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero()</span></code></a> indices of s.</p></li>
<li><p>For each nonzero x,y,z grid point find the       nonzero() indices of the SM. Do this by column so       that the output has pairs going through       each nonzero column and matching the nonzero row       number. Use function <a class="reference internal" href="#DictionarySparseMatrix.nonzero_bycol" title="DictionarySparseMatrix.nonzero_bycol"><code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero_bycol()</span></code></a>.</p></li>
<li><p>Go through each of these indice pairs for the SM.       Check if the column index is new. If so assign       the column in out to the matching       value in the SM. If the column number is not       new then multiply the value in the column in       out by the corresponding value in the SM.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="o">=</span><span class="p">[</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">],</span>
<span class="o">...</span><span class="p">,</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DS of size Nx x Ny x Nz x 1 x nb</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_row_vec_multiply">
<code class="sig-name descname">dict_row_vec_multiply</code><span class="sig-paren">(</span><em class="sig-param">vec</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_row_vec_multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_row_vec_multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply every row of the DSM s elementwise with the
vector vec.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vec</strong> – a row vector with length na.</p>
</dd>
</dl>
<p>For integers <span class="math notranslate nohighlight">\(x,y,z,k\)</span> and <span class="math notranslate nohighlight">\(j\)</span> such that,
<span class="math notranslate nohighlight">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>Multiplication is done using     <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal notranslate"><span class="pre">dict_vec_multiply(vec)()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A DSM ‘out’ with the same dimensions as s.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_scal_mult">
<code class="sig-name descname">dict_scal_mult</code><span class="sig-paren">(</span><em class="sig-param">scal</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_scal_mult"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_scal_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply every term of the DSM s by scal.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scal</strong> – scalar variable</p>
</dd>
</dl>
<p>For integers <span class="math notranslate nohighlight">\(x,y,z,k\)</span> and <span class="math notranslate nohighlight">\(j\)</span> such that,
<span class="math notranslate nohighlight">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">scal</span><span class="o">*</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS">DS</a>(Nx,Ny,Nz,na,nb)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_vec_divideby_DSM">
<code class="sig-name descname">dict_vec_divideby_DSM</code><span class="sig-paren">(</span><em class="sig-param">vec</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_vec_divideby_DSM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_vec_divideby_DSM" title="Permalink to this definition">¶</a></dt>
<dd><p>Every column of the DSM s divides elementwise the vector vec.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vec</strong> – a row vector with length na.</p>
</dd>
</dl>
<p>For integers <span class="math notranslate nohighlight">\(x,y,z,k\)</span> and <span class="math notranslate nohighlight">\(j\)</span> such that,
<span class="math notranslate nohighlight">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a DSM ‘out’ with the same dimensions as s.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_vec_multiply">
<code class="sig-name descname">dict_vec_multiply</code><span class="sig-paren">(</span><em class="sig-param">vec</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_vec_multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_vec_multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply every column of the DSM s elementwise with the     vector vec.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vec</strong> – a row vector with length na.</p>
</dd>
</dl>
<p>For integers <span class="math notranslate nohighlight">\(x,y,z,k\)</span> and <span class="math notranslate nohighlight">\(j\)</span> such that,
<span class="math notranslate nohighlight">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>Multiplication is done using     <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal notranslate"><span class="pre">dict_vec_multiply(vec)()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A DSM ‘out’ with the same dimensions as s.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.double_dict_col_mult_">
<code class="sig-name descname">double_dict_col_mult_</code><span class="sig-paren">(</span><em class="sig-param">DSM</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.double_dict_col_mult_"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.double_dict_col_mult_" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply all nonzero terms in a column.</p>
<p>In every grid point x,y,z of s there is a sparse matrix SM.     Take the product of all nonzero terms in each column and     keep these in a vector v.
Construct a new DS of size Nx x Ny x Nz x 1 x nb=s.shape[1].    Call this out. out[x,y,z] should be the v corresponding     to the SM in s at x,y,z.</p>
<dl class="simple">
<dt>Method:</dt><dd><ul class="simple">
<li><p>Find the <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a>. <a class="reference internal" href="#DictionarySparseMatrix.DS.nonzero" title="DictionarySparseMatrix.DS.nonzero"><code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero()</span></code></a> indices of s.</p></li>
<li><p>For each nonzero x,y,z grid point find the       nonzero() indices of the SM. Do this by column so       that the output has pairs going through       each nonzero column and matching the nonzero row       number. Use function <a class="reference internal" href="#DictionarySparseMatrix.nonzero_bycol" title="DictionarySparseMatrix.nonzero_bycol"><code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero_bycol()</span></code></a>.</p></li>
<li><p>Go through each of these indice pairs for the SM.       Check if the column index is new. If so assign       the column in out to the matching       value in the SM. If the column number is not       new then multiply the value in the column in       out by the corresponding value in the SM.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="o">=</span><span class="p">[</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">],</span>
<span class="o">...</span><span class="p">,</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DS of size Nx x Ny x Nz x 1 x nb</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.double_dict_vec_multiply">
<code class="sig-name descname">double_dict_vec_multiply</code><span class="sig-paren">(</span><em class="sig-param">DSM2</em>, <em class="sig-param">vec</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.double_dict_vec_multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.double_dict_vec_multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply every column of the DSM s elementwise with the     vector vec.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>vec</strong> – a row vector with length na.</p>
</dd>
</dl>
<p>For integers <span class="math notranslate nohighlight">\(x,y,z,k\)</span> and <span class="math notranslate nohighlight">\(j\)</span> such that,
<span class="math notranslate nohighlight">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>Multiplication is done using     <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal notranslate"><span class="pre">dict_vec_multiply(vec)()</span></code></p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A DSM ‘out’ with the same dimensions as s.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.gain_phase_rad_ref_mul">
<code class="sig-name descname">gain_phase_rad_ref_mul</code><span class="sig-paren">(</span><em class="sig-param">Com1</em>, <em class="sig-param">Com2</em>, <em class="sig-param">G</em>, <em class="sig-param">khat</em>, <em class="sig-param">L</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.gain_phase_rad_ref_mul"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.gain_phase_rad_ref_mul" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Multiply all terms of s element wise with Com1/Rad and each row by Gt.</dt><dd><p>Multiply all terms of s elementwise with Com2/Rad and each row by Gt.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – a row vector with length na.</p></li>
<li><p><strong>Rad</strong> – A DSM with size Nx, Ny,Nz, 1,na</p></li>
<li><p><strong>Com1</strong> – A DSM with size Nx, Ny,Nz, 1,na</p></li>
<li><p><strong>Com2</strong> – A DSM with size Nx, Ny,Nz, 1,na</p></li>
</ul>
</dd>
</dl>
<p>For integers <span class="math notranslate nohighlight">\(x,y,z,k\)</span> and <span class="math notranslate nohighlight">\(j\)</span> such that,
<span class="math notranslate nohighlight">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out1</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Rad</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Com1</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
<span class="n">out2</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Rad</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Com2</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A DSM ‘out’ with the same dimensions as s.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.gain_phase_rad_ref_mul_add">
<code class="sig-name descname">gain_phase_rad_ref_mul_add</code><span class="sig-paren">(</span><em class="sig-param">Com1</em>, <em class="sig-param">Com2</em>, <em class="sig-param">G</em>, <em class="sig-param">khat</em>, <em class="sig-param">L</em>, <em class="sig-param">lam</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.gain_phase_rad_ref_mul_add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.gain_phase_rad_ref_mul_add" title="Permalink to this definition">¶</a></dt>
<dd><dl class="simple">
<dt>Multiply all terms of s element wise with Com1/Rad and each row by Gt.</dt><dd><p>Multiply all terms of s elementwise with Com2/Rad and each row by Gt.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – a row vector with length na.</p></li>
<li><p><strong>Rad</strong> – A DSM with size Nx, Ny,Nz, 1,na</p></li>
<li><p><strong>Com1</strong> – A DSM with size Nx, Ny,Nz, 1,na</p></li>
<li><p><strong>Com2</strong> – A DSM with size Nx, Ny,Nz, 1,na</p></li>
</ul>
</dd>
</dl>
<p>For integers <span class="math notranslate nohighlight">\(x,y,z,k\)</span> and <span class="math notranslate nohighlight">\(j\)</span> such that,
<span class="math notranslate nohighlight">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out1</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">+=</span><span class="n">G</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Rad</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Com1</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
<span class="n">out2</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">+=</span><span class="n">G</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Rad</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Com2</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A np.array ‘out’ of size Nx, Ny,Nz</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.gain_phase_ref_mul">
<code class="sig-name descname">gain_phase_ref_mul</code><span class="sig-paren">(</span><em class="sig-param">Com1</em>, <em class="sig-param">Com2</em>, <em class="sig-param">G</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.gain_phase_ref_mul"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.gain_phase_ref_mul" title="Permalink to this definition">¶</a></dt>
<dd><blockquote>
<div><p>Multiply all terms of s element wise with Com1 and each row by Gt.
Multiply all terms of s elementwise with Com2 and each row by Gt.</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>G</strong> – a row vector with length na.</p></li>
<li><p><strong>Com1</strong> – A DSM with size Nx, Ny,Nz, 1,na</p></li>
<li><p><strong>Com2</strong> – A DSM with size Nx, Ny,Nz, 1,na</p></li>
</ul>
</dd>
</dl>
<p>For integers <span class="math notranslate nohighlight">\(x,y,z,k\)</span> and <span class="math notranslate nohighlight">\(j\)</span> such that,
<span class="math notranslate nohighlight">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out1</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Com1</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
<span class="n">out2</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">Com2</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A DSM ‘out’ with the same dimensions as s.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.nonzero">
<code class="sig-name descname">nonzero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.nonzero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the indices of the nonzero terms in the DSM s.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>The indices are found by iterating through all           keys (x,y,z) for the DSM s and finding the nonzero           indices of the corresponding sparse matrix.           These indices are then combinded           with the x,y,z key and stacked to create a 5xN           array of all the nonzero terms in the DSM,           where N is the number of nonzero           terms.</p>
</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>indices=[ [x1,y1,z1,k1,j1],…,[xn,yn,zn,kn,jn]]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.nonzeroMat">
<code class="sig-name descname">nonzeroMat</code><span class="sig-paren">(</span><em class="sig-param">cor</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.nonzeroMat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.nonzeroMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the indices of the nonzero terms for part of the DSM s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cor</strong> – the part of s that you want the nonzero indices for.</p>
</dd>
</dl>
<p>The indices are found by using the <a class="reference internal" href="#DictionarySparseMatrix.DS.nonzero" title="DictionarySparseMatrix.DS.nonzero"><code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero()</span></code></a> function on s[cor]</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>indices=[ [x1,y1,z1,k1,j1],…,[xn,yn,zn,kn,jn]]</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.phase_calc">
<code class="sig-name descname">phase_calc</code><span class="sig-paren">(</span><em class="sig-param">khat</em>, <em class="sig-param">L</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.phase_calc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.phase_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute <span class="math notranslate nohighlight">\(\exp(i
rac{\hat{k}\hat{r}}{L^2})\)</span>     for a Mesh of <span class="math notranslate nohighlight">\(r\)</span></p>
<blockquote>
<div><dl class="field-list simple">
<dt class="field-odd">meta public</dt>
<dd class="field-odd"><p></p></dd>
</dl>
<p>The phase is usually expressed at <span class="math notranslate nohighlight">\(exp(ikr)\)</span>.
Since <span class="math notranslate nohighlight">\(\hat{k}\)</span> and <span class="math notranslate nohighlight">\(\hat{r}\)</span> are nondimensional lengths     scaled by the room length L the power of <span class="math notranslate nohighlight">\(L^{-2}\)</span> must be used.</p>
<p>Exponentials are not defined on DS, instead use     <span class="math notranslate nohighlight">\(\exp(i   heta)=\cos(     heta)+i\sin(    heta)\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">S1</span><span class="o">=</span><span class="n">RadMesh</span><span class="o">.</span><span class="n">dict_scal_mult</span><span class="p">(</span><span class="n">khat</span><span class="p">)</span>
<span class="n">S2</span><span class="o">=</span><span class="n">S1</span><span class="o">.</span><span class="n">dict_scal_mult</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="n">out</span><span class="o">=</span><span class="n">S1</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span><span class="o">+</span><span class="n">S1</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span><span class="o">.</span><span class="n">dict_scal_mult</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">rtype</dt>
<dd class="field-odd"><p>DS of size Nx x Ny x Nz x na x 1</p>
</dd>
<dt class="field-even">return</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.refcoefbyterm_withmul">
<code class="sig-name descname">refcoefbyterm_withmul</code><span class="sig-paren">(</span><em class="sig-param">m</em>, <em class="sig-param">refindex</em>, <em class="sig-param">lam</em>, <em class="sig-param">L</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.refcoefbyterm_withmul"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.refcoefbyterm_withmul" title="Permalink to this definition">¶</a></dt>
<dd><p>Using the refractive index of obstacles, the wavelength and the
length scaling the unit mesh the reflection coefficents for each ray
are calculated.</p>
<dl class="field-list simple">
<dt class="field-odd">Meta public</dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>m</strong> – The vector of impedance ratios. (Repeated to line up with terms in Mesh).</p></li>
<li><p><strong>refindex</strong> – The vector of refractive indices of obstacles. (Repeated to line up with terms in Mesh).</p></li>
<li><p><strong>lam</strong> – The wavelength</p></li>
<li><p><strong>L</strong> – The length scale for the room.</p></li>
</ul>
</dd>
</dl>
<p>out1 is the combinations of the reflection coefficients for the parallel to polarisation terms.</p>
<p>out2 is the combinations of the reflection coefficients for the perpendicular to polarisation terms.</p>
<ul>
<li><p>out1 and out2 are initialised to be zero everywhere with dimensions (Nx,Ny,Nz,1,nb)</p></li>
<li><p>Go through the non-zero indices (i0,i1,i2,i3,i4). If the row number (i3) is 0 and there are no other terms in the column     this is a line of sight ray.</p></li>
<li><p>If(i3==0):</p>
<ul class="simple">
<li><p>If the term in out1(i0,i1,i2,0,i4) is zero then this and out2(i0,i1,i2,0,i4) should be set to 1.</p></li>
<li><p>If out1(i0,i1,i2,0,i4) is non-zero then this ray is already accounted for and nothing should be done.</p></li>
</ul>
</li>
<li><p>Else:</p>
<blockquote>
<div><ul class="simple">
<li><p>Calculate the reflection coefficients.</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\theta=s[i0,i1,i2,i3,i4]
cthi=\cos(\theta)
ctht=\cos(\arcsin(\sin(\theta)/n))
S1=m[i3]*cthi
S2=mpi3]*ctht
Rpar=(S1-ctht)/(S1+ctht)
Rper=(cthi-S2)/(cthi+S2)\]</div>
</div></blockquote>
<ul class="simple">
<li><p>out1[i0,i1,i2,0,i4]=Rper, out2[i0,i1,i2,0,i4]=Rpar</p></li>
</ul>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>2 DSMs with dimensions (Nx,Ny,Nz,1,nb)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>out1 out2</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.row_sum">
<code class="sig-name descname">row_sum</code><span class="sig-paren">(</span><em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.row_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.row_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum all nonzero terms in a row.</p>
<p>In every grid point x,y,z of s there is a sparse matrix SM.
Construct a new DS of size Nx x Ny x Nz x na=s.shape[0] x 1.
Call this out.
out[x,y,z] should be the corresponding na x1 SM to the SM in s at x,y,z.</p>
<dl class="simple">
<dt>Method:</dt><dd><ul class="simple">
<li><p>Find the <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a>. <a class="reference internal" href="#DictionarySparseMatrix.DS.nonzero" title="DictionarySparseMatrix.DS.nonzero"><code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero()</span></code></a> indices of s`</p></li>
<li><p>Go through each of these indice. Check if the       row index is new. If so assign the row in out to the matching       value in the SM. If the row number is not new then sum the       value in the column in out by the corresponding value in the SM.</p></li>
</ul>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">out</span><span class="o">=</span><span class="p">[</span>
<span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="n">na</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">],</span>
<span class="o">...</span><span class="p">,</span>
<span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="n">na</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>DS of size Nx x Ny x Nz x na x  1</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.save_dict">
<code class="sig-name descname">save_dict</code><span class="sig-paren">(</span><em class="sig-param">filename_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.save_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.save_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the DSM s.</p>
<dl class="field-list simple">
<dt class="field-odd">Meta private</dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">Parameters</dt>
<dd class="field-even"><p><strong>filename</strong> – the name of the file to save to.</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>nothing</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.sin">
<code class="sig-name descname">sin</code><span class="sig-paren">(</span><em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.sin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds <span class="math notranslate nohighlight">\(\sin(\theta)\)</span> for all terms
:meta private:</p>
<p><span class="math notranslate nohighlight">\(\theta != 0\)</span> in the DS s.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>A DSM with the same dimensions with     <span class="math notranslate nohighlight">\(\sin(\theta)\)</span> in the      same position as the corresponding theta terms.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.sparse_angles">
<code class="sig-name descname">sparse_angles</code><span class="sig-paren">(</span><em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.sparse_angles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.sparse_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the angles <span class="math notranslate nohighlight">\(\theta\)</span> which are the arguments     of the nonzero complex terms in the DSM s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>ind</strong> – The non-zero indices of s in the form [[x0,y0,z0,a0,b0],…,[xn,yn,zn,an,bn]]     if ind is not input then the function <a class="reference internal" href="#DictionarySparseMatrix.DS.nonzero" title="DictionarySparseMatrix.DS.nonzero"><code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero()</span></code></a> is run at the start to find it.</p>
</dd>
</dl>
<ul class="simple">
<li><p>Go through the nonzero terms (i0,i1,i2,i3,i4) in s.</p></li>
</ul>
<p><span class="math notranslate nohighlight">\(\theta\)</span>  is the angle of the term at s[i0,i1,i2,i3,i4]</p>
<ul class="simple">
<li><p>AngDSM[i0,i1,i2,i3,i4]=:math:<cite>theta</cite></p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>A DSM with the same dimensions as s</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>AngDSM</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.stopcheck">
<code class="sig-name descname">stopcheck</code><span class="sig-paren">(</span><em class="sig-param">i</em>, <em class="sig-param">j</em>, <em class="sig-param">k</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.stopcheck"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.stopcheck" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the index [i,j,k] is valid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – is the index for the x axis.</p></li>
<li><p><strong>j</strong> – is the index for the y axis.</p></li>
<li><p><strong>k</strong> – is the index for the z axis.</p></li>
<li><p><strong>p1</strong> – is the point at the end of the ray.</p></li>
<li><p><strong>h</strong> – is the mesh width</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>1 if valid, 0 if not.</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>add the inside check to this function</p>
</div>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Todo</p>
<p>add the check for the end of the ray.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Warning</dt>
<dd class="field-odd"><p>This currently only checks a point is     inside a room, it doesn’t account for if you have gone inside an object.</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.stopchecklist">
<code class="sig-name descname">stopchecklist</code><span class="sig-paren">(</span><em class="sig-param">ps</em>, <em class="sig-param">p3</em>, <em class="sig-param">n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.stopchecklist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.stopchecklist" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the list of points is valid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ps</strong> – the indices for the points in the list</p></li>
<li><p><strong>p1</strong> – the end of the ray</p></li>
<li><p><strong>h</strong> – the meshwidth</p></li>
<li><p><strong>p3</strong> – the points on the cone vectors</p></li>
<li><p><strong>n</strong> – the normal vectors forming the cone.</p></li>
</ul>
</dd>
</dl>
<ul class="simple">
<li><p>start=0 if no points were valid.</p></li>
<li><p>if at least 1 point was valid,</p>
<ul>
<li><p>ps=[[i1,j1,k1],…,[in,jn,kn]] the indices of the valid points,</p></li>
<li><p>p3=[[x1,y1,z1],…,[xn,yn,zn]] co-ordinates of the valid points,</p></li>
<li><p>N=[n0,…,nN] the normal vectors corresponding to the valid points.</p></li>
</ul>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>start, ps, p3, N</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.togrid">
<code class="sig-name descname">togrid</code><span class="sig-paren">(</span><em class="sig-param">ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.togrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.togrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the matrix norm at each grid point and return a     3d numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Meta private</dt>
<dd class="field-odd"><p></p></dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>Nx x Ny x Nz numpy array</p>
</dd>
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>Grid</p>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.xyznonzero">
<code class="sig-name descname">xyznonzero</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.xyznonzero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.xyznonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the indices of the nonzero terms in the DSM s.</p>
<dl class="field-list">
<dt class="field-odd">Meta public</dt>
<dd class="field-odd"><div class="admonition note">
<p class="admonition-title">Note</p>
<p>The indices are found by iterating through all           keys (x,y,z) for the DSM s and finding the nonzero           indices of the corresponding sparse matrix.           These indices are then combinded           with the x,y,z key and stacked to create a 5xN           array of all the nonzero terms in the DSM,           where N is the number of nonzero           terms.</p>
</div>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>indices=[ [x1,y1,z1,k1,j1],…,[xn,yn,zn,kn,jn]]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.load_dict">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">load_dict</code><span class="sig-paren">(</span><em class="sig-param">filename_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#load_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.load_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a DS as a dictionary and construct the DS again.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>filename</strong> – the name of the DS saved</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Nx</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">Keys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">Keys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">Ny</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">Keys</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">Keys</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">Nz</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">Keys</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">Keys</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>nothing</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.nonzero_bycol">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">nonzero_bycol</code><span class="sig-paren">(</span><em class="sig-param">SM</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#nonzero_bycol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.nonzero_bycol" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index pairs for the nonzero terms in a sparse matrix.
Go through each column and find the nonzero rows.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>SM</strong> – sparse matrix.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>[[i(0j0),i(1j0),…,i(nj0),…,i(njn)],    [j0,…,j0,…,jn,…,jn]]</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.parnonzero">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">parnonzero</code><span class="sig-paren">(</span><em class="sig-param">nj</em>, <em class="sig-param">DS</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#parnonzero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.parnonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel version of a program with a dummy DS and a function for   finding the indices of the nonzero terms in a mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nj</strong> – number of processes.</p></li>
<li><p><strong>DS</strong> – the mesh</p></li>
</ul>
</dd>
</dl>
<p>Pool the nj processes
Specify what needs to be done.
Combine the information.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>5xn array which n is the number of nonzero terms.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.phase_calc">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">phase_calc</code><span class="sig-paren">(</span><em class="sig-param">RadMesh</em>, <em class="sig-param">khat</em>, <em class="sig-param">L</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#phase_calc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.phase_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute <span class="math notranslate nohighlight">\(\exp(i
rac{\hat{k}\hat{r}}{L^2})\)</span>   for a Mesh of <span class="math notranslate nohighlight">\(r\)</span></p>
<blockquote>
<div><p>The phase is usually expressed at <span class="math notranslate nohighlight">\(exp(ikr)\)</span>.
Since <span class="math notranslate nohighlight">\(\hat{k}\)</span> and <span class="math notranslate nohighlight">\(\hat{r}\)</span> are nondimensional lengths   scaled by the room length L the power of <span class="math notranslate nohighlight">\(L^{-2}\)</span> must be used.</p>
<p>Exponentials are not defined on DS, instead use   <span class="math notranslate nohighlight">\(\exp(i       heta)=\cos(     heta)+i\sin(    heta)\)</span>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">S1</span><span class="o">=</span><span class="n">RadMesh</span><span class="o">.</span><span class="n">dict_scal_mult</span><span class="p">(</span><span class="n">khat</span><span class="p">)</span>
<span class="n">S2</span><span class="o">=</span><span class="n">S1</span><span class="o">.</span><span class="n">dict_scal_mult</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="n">out</span><span class="o">=</span><span class="n">S1</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span><span class="o">+</span><span class="n">S1</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span><span class="o">.</span><span class="n">dict_scal_mult</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">rtype</dt>
<dd class="field-odd"><p>DS of size Nx x Ny x Nz x na x 1</p>
</dd>
<dt class="field-even">return</dt>
<dd class="field-even"><p>out</p>
</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.power_compute">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">power_compute</code><span class="sig-paren">(</span><em class="sig-param">Mesh</em>, <em class="sig-param">Grid</em>, <em class="sig-param">Znobrat</em>, <em class="sig-param">refindex</em>, <em class="sig-param">Antpar</em>, <em class="sig-param">Gt</em>, <em class="sig-param">Pol</em>, <em class="sig-param">Nra</em>, <em class="sig-param">Nre</em>, <em class="sig-param">Ns</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#power_compute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.power_compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the field from a Mesh of ray information and the physical   parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Mesh</strong> – The <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a> mesh of ray information.</p></li>
<li><p><strong>Znobrat</strong> – An Nob x Nre+1 array containing tiles of the impedance   of obstacles divided by the impedance of air.</p></li>
<li><p><strong>refindex</strong> – An Nob x Nre+1 array containing tiles of the refractive  index of obstacles.</p></li>
<li><p><strong>Antpar</strong> – Numpy array containing the wavenumber, wavelength and lengthscale.</p></li>
<li><p><strong>Gt</strong> – Array of the transmitting antenna gains.</p></li>
<li><p><strong>Pol</strong> – 2x1 numpy array containing the polarisation terms.</p></li>
<li><p><strong>Nra</strong> – The number of rays in the ray tracer.</p></li>
<li><p><strong>Nre</strong> – The number of reflections in the ray tracer.</p></li>
<li><p><strong>Ns</strong> – The number of terms on each axis</p></li>
</ul>
</dd>
</dl>
<p>Method:</p>
<blockquote>
<div><ul class="simple">
<li><p>First compute the angles of reflectio using py:func:<cite>Mesh.sparse_angles()</cite></p></li>
<li><p>Compute the combined reflection coefficients using     <code class="xref py py-func docutils literal notranslate"><span class="pre">Mesh.refcoefbyterm_withmu(Nre,refindex,lam,L,</span> <span class="pre">ind=-1)()</span></code></p></li>
<li><p>Combine the reflection coefficients that correspond to the same     ray using <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal notranslate"><span class="pre">dict_col_mult()</span></code>. This     multiplies reflection coefficients in the same column.</p></li>
<li><p>Extract the distance each ray had travelled using     <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal notranslate"><span class="pre">__get_rad__()</span></code></p></li>
<li><p>Multiply by the gains for the corresponding ray.</p></li>
<li><p>Multiply terms by the phases     <span class="math notranslate nohighlight">\(\exp(i\hat{k} \hat{r})^{L^{-2}}\)</span>. With <span class="math notranslate nohighlight">\(L\)</span> being     the room length scale. <span class="math notranslate nohighlight">\(\hat{r}\)</span> being the relative distance     travelled which is the actual distance divided by the room length     scale, and <span class="math notranslate nohighlight">\(\hat{k}\)</span> is the relative wavenumber which is the     actual wavenumber times the room length scale.</p></li>
<li><p>Multiply by the gains corresponding to each ray.</p></li>
<li><p>Divide by the distance corresponding to each ray segment.</p></li>
<li><p>Sum all the ray segments in a grid point.</p></li>
<li><p>Multiply the grid by the transmitted field times the wavelngth     divided by the room length scale. <span class="math notranslate nohighlight">\(\frac{\lambda}{L 4 \pi}\)</span></p></li>
<li><p>Multiply by initial polarisation vectors and combine.</p></li>
<li><p>Ignore dividing by initial phi as when converting to power in db     this disappears.</p></li>
<li><p>Take the amplitude and square.</p></li>
<li><p>Take <span class="math notranslate nohighlight">\(10log10()\)</span> to get the db Power.</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Nx x Ny x Nz numpy array of real values.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Grid</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.quality_compute">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">quality_compute</code><span class="sig-paren">(</span><em class="sig-param">Mesh</em>, <em class="sig-param">Grid</em>, <em class="sig-param">Znobrat</em>, <em class="sig-param">refindex</em>, <em class="sig-param">Antpar</em>, <em class="sig-param">Gt</em>, <em class="sig-param">Pol</em>, <em class="sig-param">Nra</em>, <em class="sig-param">Nre</em>, <em class="sig-param">Ns</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#quality_compute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.quality_compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the field from a Mesh of ray information and the physical   parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Mesh</strong> – The <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a> mesh of ray information.</p></li>
<li><p><strong>Znobrat</strong> – An Nob x Nre+1 array containing tiles of the impedance     of obstacles divided by the impedance of air.</p></li>
<li><p><strong>refindex</strong> – An Nob x Nre+1 array containing tiles of the refractive    index of obstacles.</p></li>
<li><p><strong>Antpar</strong> – Numpy array containing the wavenumber, wavelength and lengthscale.</p></li>
<li><p><strong>Gt</strong> – Array of the transmitting antenna gains.</p></li>
<li><p><strong>Pol</strong> – 2x1 numpy array containing the polarisation terms.</p></li>
</ul>
</dd>
</dl>
<p>Method:</p>
<blockquote>
<div><ul class="simple">
<li><p>First compute the reflection coefficients using     <code class="xref py py-func docutils literal notranslate"><span class="pre">ref_coef(Mesh,Znobrat,refindex)()</span></code></p></li>
<li><p>Combine the reflection coefficients that correspond to the same     ray using <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal notranslate"><span class="pre">dict_col_mult()</span></code>. This     multiplies reflection coefficients in the same column.</p></li>
<li><p>Extract the distance each ray had travelled using     <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal notranslate"><span class="pre">__get_rad__()</span></code></p></li>
<li><p>Multiply by the gains for the corresponding ray.</p></li>
<li><p>Multiply terms by the phases     <span class="math notranslate nohighlight">\(\exp(i\hat{k} \hat{r})^{L^{-2}}\)</span>. With <span class="math notranslate nohighlight">\(L\)</span> being     the room length scale. <span class="math notranslate nohighlight">\(\hat{r}\)</span> being the relative distance     travelled which is the actual distance divided by the room length     scale, and <span class="math notranslate nohighlight">\(\hat{k}\)</span> is the relative wavenumber which is the     actual wavenumber times the room length scale.</p></li>
<li><p>Multiply by the gains corresponding to each ray.</p></li>
<li><p>Divide by the distance corresponding to each ray segment.</p></li>
<li><p>Sum all the ray segments in a grid point.</p></li>
<li><p>Multiply the grid by the transmitted field times the wavelngth     divided by the room length scale. <span class="math notranslate nohighlight">\(\frac{\lambda}{L 4 \pi}\)</span></p></li>
<li><p>Multiply by initial polarisation vectors and combine.</p></li>
<li><p>Ignore dividing by initial phi as when converting to power in db     this disappears.</p></li>
<li><p>Take the amplitude and square.</p></li>
<li><p>Take <span class="math notranslate nohighlight">\(10log10()\)</span> to get the db Power.</p></li>
</ul>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Nx x Ny x Nz numpy array of real values.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Grid</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.ref_coef">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">ref_coef</code><span class="sig-paren">(</span><em class="sig-param">Mesh</em>, <em class="sig-param">Znobrat</em>, <em class="sig-param">refindex</em>, <em class="sig-param">Nra</em>, <em class="sig-param">Nre</em>, <em class="sig-param">Ns</em>, <em class="sig-param">ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#ref_coef"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.ref_coef" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the reflection coefficients.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>Mesh</strong> – The DS mesh which contains terms re^(itheta) with theta   the reflection angle of incidence.</p>
</dd>
</dl>
<p>Method:</p>
<blockquote>
<div><ul class="simple">
<li><p>Gets the mesh of angles using <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal notranslate"><span class="pre">sparse_angles()</span></code></p></li>
<li><p>Gets the indices of the nonzero terms using <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal notranslate"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero()</span></code></p></li>
<li><p>Initialise sin(thetai), cos(thetai) and cos(thetat) meshes.</p></li>
<li><p>Compute cos(thetai),sin(thetai), cos(thetat)</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">cthi</span><span class="o">=</span><span class="n">AngDSM</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span>
<span class="n">SIN</span><span class="o">=</span><span class="n">AngDSM</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span>
<span class="n">Div</span><span class="o">=</span><span class="n">SIN</span><span class="o">.</span><span class="n">dict_DSM_divideby_vec</span><span class="p">(</span><span class="n">refindex</span><span class="p">)</span>
<span class="n">ctht</span><span class="o">=</span><span class="n">Div</span><span class="o">.</span><span class="n">asin</span><span class="p">()</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Compute the reflection coefficients.</p></li>
</ul>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">S1</span><span class="o">=</span><span class="p">(</span><span class="n">cthi</span><span class="p">)</span><span class="o">.</span><span class="n">dict_vec_multiply</span><span class="p">(</span><span class="n">Znobrat</span><span class="p">)</span>
<span class="n">S2</span><span class="o">=</span><span class="p">(</span><span class="n">ctht</span><span class="p">)</span><span class="o">.</span><span class="n">dict_vec_multiply</span><span class="p">(</span><span class="n">Znobrat</span><span class="p">)</span>
<span class="n">Rper</span><span class="o">=</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">ctht</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">S1</span><span class="o">+</span><span class="n">ctht</span><span class="p">)</span>
<span class="n">Rpar</span><span class="o">=</span><span class="p">(</span><span class="n">cthi</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">cthi</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>Rper=DS(Nx,Ny,Nz,na,nb),Rpar=DS(Nx,Ny,Nz,na,nb)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Rper, Rpar</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.stopcheck">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">stopcheck</code><span class="sig-paren">(</span><em class="sig-param">i</em>, <em class="sig-param">j</em>, <em class="sig-param">k</em>, <em class="sig-param">Nx</em>, <em class="sig-param">Ny</em>, <em class="sig-param">Nz</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#stopcheck"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.stopcheck" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the index [i,j,k] is valid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i</strong> – is the index for the x axis.</p></li>
<li><p><strong>j</strong> – is the index for the y axis.</p></li>
<li><p><strong>k</strong> – is the index for the z axis.</p></li>
<li><p><strong>p1</strong> – is the point at the end of the ray.</p></li>
<li><p><strong>h</strong> – is the mesh width</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>1 if valid, 0 if not.</p>
</dd>
</dl>
<div class="admonition-todo admonition" id="id3">
<p class="admonition-title">Todo</p>
<p>add the inside check to this function</p>
</div>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Todo</p>
<p>add the check for the end of the ray.</p>
</div>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.stopchecklist">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">stopchecklist</code><span class="sig-paren">(</span><em class="sig-param">ps</em>, <em class="sig-param">p3</em>, <em class="sig-param">n</em>, <em class="sig-param">Nx</em>, <em class="sig-param">Ny</em>, <em class="sig-param">Nz</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#stopchecklist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.stopchecklist" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the list of points is valid.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ps</strong> – the indices for the points in the list</p></li>
<li><p><strong>p1</strong> – the end of the ray</p></li>
<li><p><strong>h</strong> – the meshwidth</p></li>
<li><p><strong>p3</strong> – the points on the cone vectors</p></li>
<li><p><strong>n</strong> – the normal vectors forming the cone.</p></li>
</ul>
</dd>
</dl>
<p>start=0 if no points were valid if at least 1 point was valid,
ps=[[i1,j1,k1],…,[in,jn,kn]] the indices of the valid points,
p3=[[x1,y1,z1],…,[xn,yn,zn]] co-ordinates of the valid points,
N=[n0,…,nN] the normal vectors corresponding to the valid points.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>start, ps, p3, N</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_14">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">test_14</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_14"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_14" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a test of the reflection coefficient function.
It sets test versions for the input parameters required and fills a DS   with dummy values.
It then computes the reflection coefficients associated with those   dummy parameters and values.</p>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_15">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">test_15</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_15"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_15" title="Permalink to this definition">¶</a></dt>
<dd><p>Testing multiplying nonzero terms in columns</p>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_17">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">test_17</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_17"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_17" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the <a class="reference internal" href="#DictionarySparseMatrix.parnonzero" title="DictionarySparseMatrix.parnonzero"><code class="xref py py-func docutils literal notranslate"><span class="pre">parnonzero()</span></code></a> function which should find   nonzero() indices in parallel.</p>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_18">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">test_18</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_18"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_18" title="Permalink to this definition">¶</a></dt>
<dd><p>Testing the save and load pickle functions.</p>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_19">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">test_19</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_19"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_19" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the <code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero_bycol(SM)()</span></code> function.
Initialise a dummy sparse matrix SM.</p>
<dl class="simple">
<dt>In <code class="xref py py-func docutils literal notranslate"><span class="pre">nonzero_bycol(SM)()</span></code>:</dt><dd><ul class="simple">
<li><p>Transpose the matrix.</p></li>
<li><p>Find the nonzero indices.</p></li>
<li><p>Swap the rows and columns in the indices.</p></li>
<li><p>Return the indices</p></li>
</ul>
</dd>
</dl>
<p>Check these match the nonzero terms in SM.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>0 if successful 1 if not.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_20">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">test_20</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_20"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_20" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the dict_col_mult() function.
Use a dummy DS with each matrix upper triangular with the number in   every position the row.
Check that the col_mult that comes out is the column number +1   factorial.</p>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_21">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">test_21</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_21"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_21" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the __get_rad__() function works.</p>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_22">
<code class="sig-prename descclassname">DictionarySparseMatrix.</code><code class="sig-name descname">test_22</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_22"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_22" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the set_item() function for setting columns in a DSM</p>
</dd></dl>

</div>
<div class="section" id="module-reflection">
<span id="reflection"></span><h1>Reflection<a class="headerlink" href="#module-reflection" title="Permalink to this headline">¶</a></h1>
<p>Code to Reflect a line in an edge without using Shapely</p>
<dl class="function">
<dt id="reflection.errorcheck">
<code class="sig-prename descclassname">reflection.</code><code class="sig-name descname">errorcheck</code><span class="sig-paren">(</span><em class="sig-param">err</em>, <em class="sig-param">ray</em>, <em class="sig-param">ref</em>, <em class="sig-param">normedge</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/reflection.html#errorcheck"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#reflection.errorcheck" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the input ray and output ray and the normal to the edge,
check that both vectors have the same angle to the normal</p>
</dd></dl>

<dl class="function">
<dt id="reflection.refangle">
<code class="sig-prename descclassname">reflection.</code><code class="sig-name descname">refangle</code><span class="sig-paren">(</span><em class="sig-param">line</em>, <em class="sig-param">obst</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/reflection.html#refangle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#reflection.refangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the reflection angle for the line reflection on the surface obst</p>
</dd></dl>

<dl class="function">
<dt id="reflection.test3">
<code class="sig-prename descclassname">reflection.</code><code class="sig-name descname">test3</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/reflection.html#test3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#reflection.test3" title="Permalink to this definition">¶</a></dt>
<dd><p>angle test</p>
</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<p>Write an rst file for the notation.</p>
<ul class="simple">
<li><p><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></p></li>
<li><p><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></p></li>
<li><p><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></p></li>
</ul>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="#">DSMRayTracerDoc</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Hayley.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.4.4</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/index.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>