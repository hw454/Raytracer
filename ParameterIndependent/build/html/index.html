<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Welcome to DSMRayTracerDoc’s documentation! &#8212; DSMRayTracerDoc 0 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="DSMRayTracerDoc 0 documentation" href="#" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="welcome-to-dsmraytracerdoc-s-documentation">
<h1>Welcome to DSMRayTracerDoc&#8217;s documentation!<a class="headerlink" href="#welcome-to-dsmraytracerdoc-s-documentation" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
</div>
</div>
<div class="section" id="module-RayTracerMainProgram">
<span id="main-program"></span><h1>Main Program<a class="headerlink" href="#module-RayTracerMainProgram" title="Permalink to this headline">¶</a></h1>
<p>Code to trace rays around a room. This code uses:</p>
<ul class="simple">
<li>the function <a class="reference internal" href="#RayTracerMainProgram.RayTracer" title="RayTracerMainProgram.RayTracer"><code class="xref py py-func docutils literal"><span class="pre">RayTracer()</span></code></a> to compute the points for   the ray trajectories.</li>
<li>the function <a class="reference internal" href="#RayTracerMainProgram.MeshProgram" title="RayTracerMainProgram.MeshProgram"><code class="xref py py-func docutils literal"><span class="pre">MeshProgram()</span></code></a> to compute the points for   the ray trajectories and iterate along the rays storing the   information in a <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DictionarySparseMatrix.DS</span></code></a> and outputing   the points and mesh.</li>
<li>the function <a class="reference internal" href="#RayTracerMainProgram.power_grid" title="RayTracerMainProgram.power_grid"><code class="xref py py-func docutils literal"><span class="pre">power_grid()</span></code></a> which loads the last saved   and loads the antenna and obstacle physical parameters from   <a class="reference internal" href="#ParameterInput.ObstacleCoefficients" title="ParameterInput.ObstacleCoefficients"><code class="xref py py-func docutils literal"><span class="pre">ParameterInput.ObstacleCoefficients()</span></code></a>. It uses these and   the functions <a class="reference internal" href="#RayTracerMainProgram.RefCoefComputation" title="RayTracerMainProgram.RefCoefComputation"><code class="xref py py-func docutils literal"><span class="pre">RefCoefComputation()</span></code></a> which output Rper   and Rpar the perpendicular and parallel to polarisation reflection   coefficients, and the function <a class="reference internal" href="#RayTracerMainProgram.RefCombine" title="RayTracerMainProgram.RefCombine"><code class="xref py py-func docutils literal"><span class="pre">RefCombine()</span></code></a> to   get the loss from reflection for each ray segment entering each grid   point. This is then combine with the distance of each raysegments   travel from the mesh and the antenna gains to get the Power in   decibels.</li>
<li>The ray points from <a class="reference internal" href="#RayTracerMainProgram.RayTracer" title="RayTracerMainProgram.RayTracer"><code class="xref py py-func docutils literal"><span class="pre">RayTracer()</span></code></a> are saved as:
&#8216;RayPoints<strong>Nra</strong>Refs<strong>Nre</strong>n.npy&#8217; with <strong>Nra</strong> replaced by the     number of rays and <strong>Nre</strong> replaced by the number of reflections.</li>
<li>The ray points from <a class="reference internal" href="#RayTracerMainProgram.MeshProgram" title="RayTracerMainProgram.MeshProgram"><code class="xref py py-func docutils literal"><span class="pre">MeshProgram()</span></code></a> are saved as:
&#8216;RayMeshPoints<strong>Nra</strong>Refs<strong>Nre</strong>n.npy&#8217; with <strong>Nra</strong> replaced     by the     number of rays and <strong>Nre</strong> replaced by the number of reflections.     The mesh is saved as &#8216;DSM<strong>Nra</strong>Refs<strong>Nre</strong>m.npy&#8217;.</li>
</ul>
<dl class="function">
<dt id="RayTracerMainProgram.MeshProgram">
<code class="descclassname">RayTracerMainProgram.</code><code class="descname">MeshProgram</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#MeshProgram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.MeshProgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Refect rays and output the Mesh containing ray information.</p>
<p>Parameters for the raytracer are input in <a class="reference internal" href="#module-ParameterInput" title="ParameterInput"><code class="xref py py-mod docutils literal"><span class="pre">ParameterInput</span></code></a>
The raytracing parameters defined in this module are saved and then loaded.</p>
<ul class="simple">
<li>&#8216;Raytracing.npy&#8217; - An array of 4 floats which is saved to   [Nra (number of rays), Nre (number of reflections),   h (relative meshwidth),   L (room length scale, the longest axis has been rescaled to 1 and this   is it&#8217;s original length)]</li>
<li>&#8216;Obstacles.npy&#8217;  - An array for 3x3x1 arrays containing co-ordinates   forming triangles which form the obstacles. This is saved to Oblist   (The obstacles which are within the outerboundary )</li>
<li>&#8216;Origin.npy&#8217;     - A 3x1 array for the co-ordinate of the source.   This is saved to Tx  (The location of the source antenna and origin   of every ray)</li>
<li>&#8216;OuterBoundary.npy&#8217; - An array for 3x3x1 arrays containing   co-ordinates forming triangles which form the obstacles. This is   saved to OuterBoundary   (The Obstacles forming the outer boundary of   the room )</li>
</ul>
<p>Put the two arrays of obstacles into one array</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Oblist</span><span class="o">=</span><span class="p">[</span><span class="n">Oblist</span><span class="p">,</span><span class="n">OuterBoundary</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li>&#8216;Directions.npy&#8217; - An Nrax3x1 array containing the vectors which   correspond to the initial direction of each ray. This is save to Direc.</li>
</ul>
<p>A room is initialised with <em>Oblist</em> using the py:class:<cite>Room.room</cite>   class in <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal"><span class="pre">Room</span></code></a>.</p>
<p>The number of obstacles and the number of x, y and z steps is found</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Nob</span><span class="o">=</span><span class="n">Room</span><span class="o">.</span><span class="n">Nob</span>
<span class="n">Nx</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Room</span><span class="o">.</span><span class="n">maxxleng</span><span class="p">()</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
<span class="n">Ny</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Room</span><span class="o">.</span><span class="n">maxyleng</span><span class="p">()</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
<span class="n">Nz</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Room</span><span class="o">.</span><span class="n">maxzleng</span><span class="p">()</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<p>Initialise a <cite>DSM</cite>.   <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DictionarySparseMatrix.DS</span></code></a> with the   number of spaces in the x, y and z axis Nx, Ny, Nz, the number of   obstacles Nob, the number of reflections Nre and the number of rays Nra.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Mesh</span><span class="o">=</span><span class="n">DSM</span><span class="o">.</span><span class="n">DS</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">Nob</span><span class="o">*</span><span class="n">Nre</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nb">int</span><span class="p">((</span><span class="n">Nre</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Nra</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Find the reflection points of the rays and store the distance and   reflection angles of the rays in the Mesh. Use the   py:func:<cite>Room.room.ray_mesh_bounce</cite> function.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Rays</span><span class="p">,</span> <span class="n">Mesh</span><span class="o">=</span><span class="n">Room</span><span class="o">.</span><span class="n">ray_mesh_bounce</span><span class="p">(</span><span class="n">Tx</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">Nre</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">Nra</span><span class="p">),</span><span class="n">Direc</span><span class="p">,</span><span class="n">Mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>Save the reflection points in Rays to   &#8216;RayMeshPoints<strong>Nra</strong>Refs<strong>Nre</strong>n.npy&#8217; making the   substitution for <strong>Nra</strong> and <strong>Nre</strong> with their parameter values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Mesh</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="RayTracerMainProgram.RayTracer">
<code class="descclassname">RayTracerMainProgram.</code><code class="descname">RayTracer</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#RayTracer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.RayTracer" title="Permalink to this definition">¶</a></dt>
<dd><p>Refect rays and output the points of reflection.</p>
<p>Parameters for the raytracer are input in   <a class="reference internal" href="#ParameterInput.DeclareParameters" title="ParameterInput.DeclareParameters"><code class="xref py py-func docutils literal"><span class="pre">ParameterInput.DeclareParameters()</span></code></a> The raytracing   parameters defined in this function are saved and then loaded.</p>
<ul class="simple">
<li>&#8216;Raytracing.npy&#8217; - An array of 4 floats which is saved to   [Nra (number of rays), Nre (number of reflections),   h (relative meshwidth),   L (room length scale, the longest axis has been rescaled to 1 and this   is it&#8217;s original length)]</li>
<li>&#8216;Obstacles.npy&#8217;  - An array for 3x3x1 arrays containing co-ordinates   forming triangles which form the obstacles. This is saved to Oblist   (The obstacles which are within the outerboundary )</li>
<li>&#8216;Origin.npy&#8217;     - A 3x1 array for the co-ordinate of the source.   This is saved to Tx  (The location of the source antenna and origin   of every ray)</li>
<li>&#8216;OuterBoundary.npy&#8217; - An array for 3x3x1 arrays containing   co-ordinates forming triangles which form the obstacles. This is   saved to OuterBoundary   (The Obstacles forming the outer boundary of   the room )</li>
</ul>
<p>Put the two arrays of obstacles into one array</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Oblist</span><span class="o">=</span><span class="p">[</span><span class="n">Oblist</span><span class="p">,</span><span class="n">OuterBoundary</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li>&#8216;Directions.npy&#8217; - An Nrax3x1 array containing the vectors which   correspond to the initial direction of each ray. This is save to Direc.</li>
</ul>
<p>A room is initialised with <em>Oblist</em> using the <code class="xref py py-class docutils literal"><span class="pre">room</span></code>   class in <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal"><span class="pre">Room</span></code></a>.</p>
<p>Find the reflection points of the rays using   <code class="xref py py-func docutils literal"><span class="pre">room.ray_bounce()</span></code> function.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Rays</span><span class="p">,</span> <span class="n">Mesh</span><span class="o">=</span><span class="n">Room</span><span class="o">.</span><span class="n">ray_bounce</span><span class="p">(</span><span class="n">Tx</span><span class="p">,</span><span class="n">Nre</span><span class="p">,</span><span class="n">Nra</span><span class="p">,</span><span class="n">Direc</span><span class="p">)</span>
</pre></div>
</div>
<p>Save the reflection points in Rays to   &#8216;RayPoints<strong>Nra</strong>Refs<strong>Nre</strong>n.npy&#8217; making the   substitution for <strong>Nra</strong> and <strong>Nre</strong> with their parameter values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">0 to mark a successful run</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="RayTracerMainProgram.RefCoefComputation">
<code class="descclassname">RayTracerMainProgram.</code><code class="descname">RefCoefComputation</code><span class="sig-paren">(</span><em>Mesh</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#RefCoefComputation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.RefCoefComputation" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the mesh of reflection coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Mesh</strong> &#8211; The DS mesh which contains the angles and distances rays   have travelled.</td>
</tr>
</tbody>
</table>
<p>Load the physical parameters using
<a class="reference internal" href="#ParameterInput.ObstacleCoefficients" title="ParameterInput.ObstacleCoefficients"><code class="xref py py-func docutils literal"><span class="pre">ParameterInput.ObstacleCoefficients()</span></code></a></p>
<ul class="simple">
<li>Znobrat - is the vector of characteristic impedances for obstacles   divided by the characteristic impedance of air.</li>
<li>refindex - if the vector of refractive indexes for the obstacles.</li>
</ul>
<p>Compute the Reflection coefficients (RefCoefper,Refcoefpar) using:   <a class="reference internal" href="#DictionarySparseMatrix.ref_coef" title="DictionarySparseMatrix.ref_coef"><code class="xref py py-func docutils literal"><span class="pre">DictionarySparseMatrix.ref_coef()</span></code></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">(<a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DictionarySparseMatrix.DS</span></code></a> (Nx,Ny,Nz,na,nb)    , <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DictionarySparseMatrix.DS</span></code></a> (Nx,Ny,Nz,na,nb))</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">(RefCoefper,Refcoefpar)</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="RayTracerMainProgram.RefCombine">
<code class="descclassname">RayTracerMainProgram.</code><code class="descname">RefCombine</code><span class="sig-paren">(</span><em>Rper</em>, <em>Rpar</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#RefCombine"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.RefCombine" title="Permalink to this definition">¶</a></dt>
<dd><p>Combine reflection coefficients to get the loss from reflection   coefficient for each ray segment.</p>
<p>Take in the DS&#8217;s (<a class="reference internal" href="#module-DictionarySparseMatrix" title="DictionarySparseMatrix"><code class="xref py py-mod docutils literal"><span class="pre">DictionarySparseMatrix</span></code></a>. <code class="xref py py-class docutils literal"><span class="pre">DS</span></code>)  corresponding to the reflection coefficients for all the ray   interactions (<a class="reference internal" href="#module-DictionarySparseMatrix" title="DictionarySparseMatrix"><code class="xref py py-mod docutils literal"><span class="pre">DictionarySparseMatrix</span></code></a>. <code class="xref py py-func docutils literal"><span class="pre">ref_coef(Mesh)()</span></code>).</p>
<p>Use the function <a class="reference internal" href="#module-DictionarySparseMatrix" title="DictionarySparseMatrix"><code class="xref py py-mod docutils literal"><span class="pre">DictionarySparseMatrix</span></code></a>. <code class="xref py py-class docutils literal"><span class="pre">DS</span></code>.   <code class="xref py py-func docutils literal"><span class="pre">dict_col_mult()</span></code> to multiple reflection coefficients in the same column.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Combper</span><span class="o">=</span><span class="p">[</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">Rper</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">Rper</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">Rper</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">],</span>
<span class="o">...</span><span class="p">,</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">Rper</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">Rper</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">Rper</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Combpar</span><span class="o">=</span><span class="p">[</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">Rpar</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">Rpar</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">Rpar</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">],</span>
<span class="o">...</span><span class="p">,</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">Rpar</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">Rpar</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">Rpar</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>Rper</strong> &#8211; The mesh corresponding to reflection coefficients   perpendicular to the polarisation.</li>
<li><strong>Rpar</strong> &#8211; The mesh corresponding to reflection coefficients   parallel to the polarisation.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first">(<a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DictionarySparseMatrix.DS</span></code></a> (Nx,Ny,Nz,1,nb),   <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DictionarySparseMatrix.DS</span></code></a> (Nx,Ny,Nz,na,nb))</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Combper, Combpar</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="RayTracerMainProgram.StdProgram">
<code class="descclassname">RayTracerMainProgram.</code><code class="descname">StdProgram</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#StdProgram"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.StdProgram" title="Permalink to this definition">¶</a></dt>
<dd><p>Refect rays and input object information output the power.</p>
<p>Parameters for the raytracer are input in <a class="reference internal" href="#module-ParameterInput" title="ParameterInput"><code class="xref py py-mod docutils literal"><span class="pre">ParameterInput</span></code></a>
The raytracing parameters defined in this module are saved and then loaded.</p>
<ul class="simple">
<li>&#8216;Raytracing.npy&#8217; - An array of 4 floats which is saved to   [Nra (number of rays), Nre (number of reflections),   h (relative meshwidth),   L (room length scale, the longest axis has been rescaled to 1 and this   is it&#8217;s original length)]</li>
<li>&#8216;Obstacles.npy&#8217;  - An array for 3x3x1 arrays containing co-ordinates   forming triangles which form the obstacles. This is saved to Oblist   (The obstacles which are within the outerboundary )</li>
<li>&#8216;Origin.npy&#8217;     - A 3x1 array for the co-ordinate of the source.   This is saved to Tx  (The location of the source antenna and origin   of every ray)</li>
<li>&#8216;OuterBoundary.npy&#8217; - An array for 3x3x1 arrays containing   co-ordinates forming triangles which form the obstacles. This is   saved to OuterBoundary   (The Obstacles forming the outer boundary of   the room )</li>
</ul>
<p>Put the two arrays of obstacles into one array</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Oblist</span><span class="o">=</span><span class="p">[</span><span class="n">Oblist</span><span class="p">,</span><span class="n">OuterBoundary</span><span class="p">]</span>
</pre></div>
</div>
<ul class="simple">
<li>&#8216;Directions.npy&#8217; - An Nrax3x1 array containing the vectors which   correspond to the initial direction of each ray. This is save to Direc.</li>
</ul>
<p>A room is initialised with <em>Oblist</em> using the py:class:<cite>Room.room</cite>   class in <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal"><span class="pre">Room</span></code></a>.</p>
<p>The number of obstacles and the number of x, y and z steps is found</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Nob</span><span class="o">=</span><span class="n">Room</span><span class="o">.</span><span class="n">Nob</span>
<span class="n">Nx</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Room</span><span class="o">.</span><span class="n">maxxleng</span><span class="p">()</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
<span class="n">Ny</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Room</span><span class="o">.</span><span class="n">maxyleng</span><span class="p">()</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
<span class="n">Nz</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Room</span><span class="o">.</span><span class="n">maxzleng</span><span class="p">()</span><span class="o">/</span><span class="n">h</span><span class="p">)</span>
</pre></div>
</div>
<p>Initialise a <cite>DSM</cite>.   <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DictionarySparseMatrix.DS</span></code></a> with the   number of spaces in the x, y and z axis Nx, Ny, Nz, the number of   obstacles Nob, the number of reflections Nre and the number of rays Nra.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Mesh</span><span class="o">=</span><span class="n">DSM</span><span class="o">.</span><span class="n">DS</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">Nob</span><span class="o">*</span><span class="n">Nre</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nb">int</span><span class="p">((</span><span class="n">Nre</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Nra</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Find the reflection points of the rays and store the power Use the   py:func:<cite>Room.room.ray_mesh_bounce</cite> function.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Rays</span><span class="p">,</span> <span class="n">Mesh</span><span class="o">=</span><span class="n">Room</span><span class="o">.</span><span class="n">ray_mesh_power_bounce</span><span class="p">(</span><span class="n">Tx</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">Nre</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">Nra</span><span class="p">),</span><span class="n">Direc</span><span class="p">,</span><span class="n">Mesh</span><span class="p">)</span>
</pre></div>
</div>
<p>Save the reflection points in Rays to   &#8216;RayMeshPoints<strong>Nra</strong>Refs<strong>Nre</strong>n.npy&#8217; making the   substitution for <strong>Nra</strong> and <strong>Nre</strong> with their parameter values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Mesh</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="RayTracerMainProgram.plot_grid">
<code class="descclassname">RayTracerMainProgram.</code><code class="descname">plot_grid</code><span class="sig-paren">(</span><em>index=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#plot_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.plot_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots slices of a 3D power grid.</p>
<p>Loads <cite>Power_grid.npy</cite> and for each z step plots a heatmap of the   values at the (x,y) position.</p>
</dd></dl>

<dl class="function">
<dt id="RayTracerMainProgram.power_grid">
<code class="descclassname">RayTracerMainProgram.</code><code class="descname">power_grid</code><span class="sig-paren">(</span><em>Roomnum=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/RayTracerMainProgram.html#power_grid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#RayTracerMainProgram.power_grid" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the field on a grid using enviroment parameters and the   ray Mesh.</p>
<p>Loads:</p>
<ul class="simple">
<li>(<em>Nra</em>= number of rays, <em>Nre</em>= number of reflections,   <em>h</em>= meshwidth, <em>L</em>= room length scale)=`Paramters/Raytracing.npy`</li>
<li>(<em>Nob</em>=number of obstacles)=`Parameters/Nob.npy`</li>
<li>(<em>Gt</em>=transmitter gains)=`Parameters/TxGains.npy`</li>
<li>(<em>freq</em>= frequency)=`Parameters/frequency.npy`</li>
<li>(<em>Freespace</em>= permittivity, permeabilty   and spead of light)=`Parameters/Freespace.npy`</li>
<li>(<em>Znobrat</em>= Znob/Z0, the ratio of the impedance of obstacles and   the impedance in freespace.) = <cite>Parameters/Znobrat.npy</cite></li>
<li>(<em>refindex</em>= the refractive index of the obstacles)=  Paramerters/refindex.npy`</li>
<li>(<em>Mesh</em>)=`DSM<strong>Nra</strong>Refs<strong>Nre</strong>m.npy`</li>
</ul>
<p>Method:
* Initialise Grid using the number of x, y, and z steps in <em>Mesh</em>.
* Use the function <code class="xref py py-func docutils literal"><span class="pre">DictionarySparseMatrix.DS.power_compute()</span></code>
to compute the power.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Nx Ny x Nz numpy array of floats.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Grid</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-ParameterInput">
<span id="input-of-the-parameters"></span><h1>Input of the parameters<a class="headerlink" href="#module-ParameterInput" title="Permalink to this headline">¶</a></h1>
<p>The code saves the values for the parameters in a ray tracer</p>
<dl class="function">
<dt id="ParameterInput.BoxBuild">
<code class="descclassname">ParameterInput.</code><code class="descname">BoxBuild</code><span class="sig-paren">(</span><em>xmi</em>, <em>xma</em>, <em>ymi</em>, <em>yma</em>, <em>zmi</em>, <em>zma</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ParameterInput.html#BoxBuild"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ParameterInput.BoxBuild" title="Permalink to this definition">¶</a></dt>
<dd><p>Input the inimum and maximum x,y, and z co-ordinates which will form a Box.
:param xmi: The minimum x co-ordinate.
:param xma: The maximum x co-ordinate.
:param ymi:The minimum y co-ordinate.
:param yma: The maximum y co-ordinate.
:param zmi: The minimum z co-ordinate.
:param zma: The maximum z co-ordinate.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Box</span><span class="o">=</span><span class="p">[</span><span class="n">T0</span><span class="p">,</span><span class="n">T1</span><span class="p">,</span><span class="o">...</span><span class="n">T12</span><span class="p">]</span>
<span class="n">TJ</span><span class="o">=</span><span class="p">[</span><span class="n">p0J</span><span class="p">,</span><span class="n">p1J</span><span class="p">,</span><span class="n">p2J</span><span class="p">]</span>
<span class="n">p0J</span><span class="o">=</span><span class="p">[</span><span class="n">x0J</span><span class="p">,</span><span class="n">y0J</span><span class="p">,</span><span class="n">z0J</span><span class="p">]</span>
<span class="n">p1J</span><span class="o">=</span><span class="p">[</span><span class="n">x1J</span><span class="p">,</span><span class="n">y1J</span><span class="p">,</span><span class="n">z1J</span><span class="p">]</span>
<span class="n">p2J</span><span class="o">=</span><span class="p">[</span><span class="n">x2J</span><span class="p">,</span><span class="n">y2J</span><span class="p">,</span><span class="n">x2J</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">12 x 3 x 3 numpy array.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Box</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ParameterInput.DeclareParameters">
<code class="descclassname">ParameterInput.</code><code class="descname">DeclareParameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/ParameterInput.html#DeclareParameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ParameterInput.DeclareParameters" title="Permalink to this definition">¶</a></dt>
<dd><p>All input parameters for the ray-launching method are entered in
this function which will then save them inside a Parameters folder.</p>
<ul>
<li><p class="first">Nra - Number of rays</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Due to need of integer steps the input number of rays can not
always be used if everything is equally spaced.</p>
</div>
</li>
<li><p class="first">Nre - Number of reflections</p>
</li>
<li><p class="first">Ns - Number of steps to split longest axis.</p>
</li>
<li><p class="first">l1 - Interior obstacle scale</p>
</li>
<li><p class="first">l2 - Boundary scale.</p>
</li>
<li><p class="first">triangle1 - First interior obstacle</p>
</li>
<li><p class="first">...</p>
</li>
<li><p class="first">triangleN - Last interior obstacle</p>
</li>
<li><p class="first">OuterBoundary1 - First obstacle forming the boundary of the   environment</p>
</li>
<li><p class="first">...</p>
</li>
<li><p class="first">OuterBoundaryN - Last obstacle forming the boundary of the   environment.</p>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">0 if successfully completed.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="ParameterInput.ObstacleCoefficients">
<code class="descclassname">ParameterInput.</code><code class="descname">ObstacleCoefficients</code><span class="sig-paren">(</span><em>index=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/ParameterInput.html#ObstacleCoefficients"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#ParameterInput.ObstacleCoefficients" title="Permalink to this definition">¶</a></dt>
<dd><p>Input the paramters for obstacles and the antenna. To ensure   arrays are of the right length for compatibility for the   ray-launcher retrieve the ray-launching parameters in   <a class="reference internal" href="#ParameterInput.DeclareParameters" title="ParameterInput.DeclareParameters"><code class="xref py py-func docutils literal"><span class="pre">DeclareParameters()</span></code></a></p>
<p>Load:</p>
<ul class="simple">
<li>&#8216;Obstacles.npy&#8217;     -Co-ordinates of obstacles in the room</li>
<li>&#8216;OuterBoundary.npy&#8217; - Co-ordinates of the walls of the room</li>
<li>&#8216;Raytracing.npy&#8217;    -[Nra (number of rays), Nre (number of reflections),   h (relative meshwidth)]</li>
</ul>
<p>Calculate:</p>
<ul class="simple">
<li>Nob=len([Obstacles,OuterBoundary])</li>
</ul>
<p>Input:</p>
<ul class="simple">
<li><cite>Freespace</cite> -[mu0 (permeability of air),   eps0 (permittivity of air),Z0 (characteristic impedance of air),   c (speed of light)]</li>
<li><cite>frequency</cite> - <span class="math">\(\omega\)</span> angular frequency of the wave out   the antenna.</li>
<li><cite>mur</cite>       - <span class="math">\(\mu_r\)</span> The relative permeability for all obstacles.   This should be an array with the same number of terms as the number   of obstacles Nob.</li>
<li><cite>epsr</cite>     - <span class="math">\(\epsilon_r\)</span> The relative permittivity for each obstacle.   This should be an array with the same number of terms as the number   of obstacles Nob.</li>
<li><cite>sigma</cite>     - <span class="math">\(\sigma\)</span> The electrical conductivity of the obstacles.   This should be an array with the same number of terms as the number   of obstacles.</li>
<li><cite>Gt</cite>        - The gains of the antenna. The should be an array with   the same number of terms as the number of rays Nra.</li>
</ul>
<p>Calculate:</p>
<ul class="simple">
<li><cite>eps0</cite>   - <span class="math">\(\epsilon_0=\frac{1}{\mu_0 c^2}\)</span>  permittivity of   freespace.</li>
<li><cite>Z0</cite>     - <span class="math">\(Z_0=\sqrt{\frac{\mu_0}{\epsilon_0}}\)</span> characteristic   impedance of freespace.</li>
<li><cite>refindex</cite> - The refreactive index   <span class="math">\(n=\sqrt{\mu_r\epsilon_r}\)</span></li>
<li><cite>Znobrat</cite>- The relative impedance of the obstacles given by,
<span class="math">\(\hat{Z}_{Nob}=\frac{Z_{Nob}}{Z_0}\)</span>. The impedance of each     obstacle <span class="math">\(Z_{Nob}\)</span> is given by     <span class="math">\(Z_{Nob}=\sqrt{\frac{i\omega\mu_0\mu_r}{\sigma+i\epsilon_0\epsilon_r}}\)</span>.</li>
</ul>
<p>The Znobrat and refindex terms are then reformatted so that they   repeat Nre times with an extra term. The extra term corresponds to   the line of sight path. This makes them the same length as a column   in a matrix in a <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DictionarySparseMatrix.DS</span></code></a>.   Each term corresponds to a possible obstacle reflection combination.</p>
<p>The Gains matrix is also reformated to that it repeats (Nre+1) times.   This corresponds to every possible ray reflection number combination   This makes them the same length as a row in a matrix in a   <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DictionarySparseMatrix.DS</span></code></a>.   Each term corresponds to a possible obstacle reflection combination.</p>
<p>Save:
* <cite>frequency.npy</cite>- The angular frequency <span class="math">\(\omega\)</span>.
* <cite>refindex.npy</cite> - The refractive index of the obstacles.
* <cite>Znobrat.npy</cite>  - The relative characteristic impedance.
* <cite>TxGains.npy</cite>  - The gains of the antenna.
* <cite>Freespace.npy</cite>- The freespace parameters.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Freespace</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mu0</span><span class="p">,</span><span class="n">eps0</span><span class="p">,</span><span class="n">Z0</span><span class="p">,</span><span class="n">c</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">0 if successfully completed.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-Rays">
<span id="rays"></span><h1>Rays<a class="headerlink" href="#module-Rays" title="Permalink to this headline">¶</a></h1>
<p>Code to construct the ray-tracing objects rays</p>
<dl class="class">
<dt id="Rays.Ray">
<em class="property">class </em><code class="descclassname">Rays.</code><code class="descname">Ray</code><span class="sig-paren">(</span><em>s</em>, <em>origin</em>, <em>direc</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray" title="Permalink to this definition">¶</a></dt>
<dd><p>A ray is a representation of the the trajectory of a reflecting   line and its reflections.
Ray.points is an array of co-ordinates representing
the collision points with the last term being the direction the ray ended in.
And Ray.reflections is an array containing tuples of the angles of incidence
and the number referring to the position of the obstacle in the obstacle list</p>
<dl class="method">
<dt id="Rays.Ray.mesh_multiref">
<code class="descname">mesh_multiref</code><span class="sig-paren">(</span><em>s</em>, <em>room</em>, <em>Nre</em>, <em>Mesh</em>, <em>Nra</em>, <em>nra</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.mesh_multiref"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.mesh_multiref" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a ray and finds the first Nre reflections within a room.
As each reflection is found the ray is stepped through and
information added to the Mesh.
:param room: Obstacle co-ordinates, <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal"><span class="pre">Room</span></code></a>. <code class="xref py py-class docutils literal"><span class="pre">room</span></code>.
:param Nre: Number of reflections, integer.
:param Mesh: A grid with corresponding sparse matrices, this     is a <a class="reference internal" href="#module-DictionarySparseMatrix" title="DictionarySparseMatrix"><code class="xref py py-mod docutils literal"><span class="pre">DictionarySparseMatrix</span></code></a>. <code class="xref py py-class docutils literal"><span class="pre">DS</span></code> object.
:param Nra: Total number of rays, integer.</p>
<p>Method:</p>
<ul class="simple">
<li>Create a temporary vector vec.</li>
<li>For each ray segment use     <code class="xref py py-func docutils literal"><span class="pre">mesh_singleray(room,Mesh,dist,vec,Nra,Nre,nra)()</span></code> to      segment storing r*calcvec in the Mesh. With r being the distance      ray travelled to get  centre of the grid point the ray has gone      through.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Mesh</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.mesh_power_multiref">
<code class="descname">mesh_power_multiref</code><span class="sig-paren">(</span><em>s</em>, <em>room</em>, <em>Nre</em>, <em>Mesh</em>, <em>Nra</em>, <em>it</em>, <em>Znobrat</em>, <em>refindex</em>, <em>Antpar</em>, <em>Gt</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.mesh_power_multiref"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.mesh_power_multiref" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a ray and finds the first Nre reflections within a room.
As each reflection is found the ray is stepped through and
information added to the Mesh.
:param room: Obstacle co-ordinates, <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal"><span class="pre">Room</span></code></a>. <code class="xref py py-class docutils literal"><span class="pre">room</span></code>.
:param Nre: Number of reflections, integer.
:param Grid: a Nx*Ny*Nz array which will contain power values
:param Nra: total number of rays.
:param it: current ray number.
:param Znobrat: The array with the ratio of the impedance of an     obstacle over the impedance of air.
:param refindex: Array with the refractive indices of an obstacle.
:param Antpar: array with antenna parameters - scaled wavenumber, wavelength, lengthscale.
:param Gt: transmitter gains.</p>
<p>Method:</p>
<ul class="simple">
<li>Start with the initial power.</li>
<li>For each ray segment use     <code class="xref py py-func docutils literal"><span class="pre">mesh_power_singleray(room,Mesh,dist,vec,Nra,Nre,nra)()</span></code> to      store the power along the ray.</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">grid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.mesh_power_singleray">
<code class="descname">mesh_power_singleray</code><span class="sig-paren">(</span><em>s</em>, <em>room</em>, <em>_Grid</em>, <em>_dist</em>, <em>_RefCoef</em>, <em>Nra</em>, <em>Nre</em>, <em>nra</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.mesh_power_singleray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.mesh_power_singleray" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate between two intersection points and store the ray     information in the Mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>room</strong> &#8211; <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal"><span class="pre">Room</span></code></a>. <code class="xref py py-class docutils literal"><span class="pre">room</span></code> object which     contains the co-ordinates of the obstacles.</li>
<li><strong>Grid</strong> &#8211; <a class="reference internal" href="#module-DictionarySparseMatrix" title="DictionarySparseMatrix"><code class="xref py py-mod docutils literal"><span class="pre">DictionarySparseMatrix</span></code></a>. <code class="xref py py-class docutils literal"><span class="pre">DS</span></code>     which will store the field in the parallel and perdenicular to     polarisation components at each <span class="math">\((x,y,z)\)</span> position.</li>
<li><strong>dist</strong> &#8211; A scalar variable which is the distance the ray     travelled at the start of the ray segment.</li>
<li><strong>RefCoef</strong> &#8211; A vector containing the product of the reflection     coefficients in the perpendicular and parallel directions to the     polarisation.</li>
<li><strong>Nra</strong> &#8211; Total number of rays.</li>
<li><strong>Nre</strong> &#8211; Maximum number of reflections.</li>
<li><strong>nra</strong> &#8211; Current ray number.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Method:</p>
<ul>
<li><p class="first">Calculate <span class="math">\(\theta\)</span> the reflection angle using     <code class="xref py py-func docutils literal"><span class="pre">reflect_angle(room)()</span></code>.</p>
</li>
<li><p class="first">Find the number of steps <span class="math">\(Ns\)</span> to the end of the ray segment     using <code class="xref py py-func docutils literal"><span class="pre">number_steps(meshwidth)()</span></code>.</p>
</li>
<li><p class="first">Compute an array of normal vectors representing the ray cone.</p>
</li>
<li><p class="first">Check the reflection number:</p>
<ul class="simple">
<li>If 0 then the <span class="math">\(RefCoef\)</span> term is 1.</li>
<li>Else set <span class="math">\(RefCoef\)</span></li>
</ul>
</li>
<li><p class="first">Step along the ray, For <span class="math">\(m1\in[0,Ns):\)</span></p>
<ul>
<li><p class="first">Check if the ray point is outside the domain.</p>
</li>
<li><p class="first">Calculate the co-ordinate of the centre.</p>
</li>
<li><p class="first">Recalculate distance to be for the centre point       <span class="math">\(Mesh[i1,j1,k1,:,col]=np.sqrt(np.dot((p0-p2),(p0-p2)))*calcvec\)</span>.</p>
</li>
<li><p class="first">For each normal:</p>
<ul class="simple">
<li>Find the next cone point <span class="math">\(p3\)</span> from the previous point         <span class="math">\(p1\)</span>, using the distance through a grid cube         <span class="math">\(\alpha\)</span>. This is given by:math:<cite>p3=p1+m2*alpha*norm</cite>.</li>
<li>Find the co-ordinate for the centre of the grid point z         corresponding to the <span class="math">\(p3\)</span>&#8216;s.</li>
<li>Find the distance to this centre point.</li>
<li>Set the column <span class="math">\(nra*Nre+nre\)</span> of the mesh term at         these grid points to the distance times the vector of         reflection angles.</li>
</ul>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Grid</span><span class="p">[</span><span class="n">cpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">cpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">cpos</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span><span class="o">+=</span><span class="n">e</span><span class="o">^</span><span class="p">{</span><span class="n">ikr</span><span class="p">}(</span><span class="mi">1</span><span class="o">/</span><span class="n">r2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">*</span><span class="n">RefCoef</span>
</pre></div>
</div>
</li>
<li><p class="first">Find the co-ordinate for the next ray point.       <span class="math">\(p1=p1+alpha*direc\)</span>.</p>
</li>
</ul>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Mesh, dist, calcvec</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.mesh_singleray">
<code class="descname">mesh_singleray</code><span class="sig-paren">(</span><em>s</em>, <em>room</em>, <em>_Mesh</em>, <em>_dist</em>, <em>_calcvec</em>, <em>Nra</em>, <em>Nre</em>, <em>nra</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.mesh_singleray"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.mesh_singleray" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate between two intersection points and store the ray     information in the Mesh</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>room</strong> &#8211; <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal"><span class="pre">Room</span></code></a>. <code class="xref py py-class docutils literal"><span class="pre">room</span></code> object which     contains the co-ordinates of the obstacles.</li>
<li><strong>Mesh</strong> &#8211; <a class="reference internal" href="#module-DictionarySparseMatrix" title="DictionarySparseMatrix"><code class="xref py py-mod docutils literal"><span class="pre">DictionarySparseMatrix</span></code></a>. <code class="xref py py-class docutils literal"><span class="pre">DS</span></code>     which will store all of the ray information.</li>
<li><strong>dist</strong> &#8211; A scalar variable which is the distance the ray     travelled at the start of the ray segment.</li>
<li><strong>calcvec</strong> &#8211; A vector containing <span class="math">\(e^{i     heta}\)</span> terms     for reflection angles :math:`  heta`. These terms are stored     in row nre*Nob+nob with nre being the current reflection number,     Nob the maximum obstacle number and nob the number of the     obstacle which was hit with the corresponding angle.</li>
<li><strong>Nra</strong> &#8211; Total number of rays.</li>
<li><strong>Nre</strong> &#8211; Maximum number of reflections.</li>
<li><strong>nra</strong> &#8211; Current ray number.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Method:</p>
<ul>
<li><p class="first">Calculate <span class="math">\(\theta\)</span> the reflection angle using     <code class="xref py py-func docutils literal"><span class="pre">reflect_angle(room)()</span></code>.</p>
</li>
<li><p class="first">Find the number of steps <span class="math">\(Ns\)</span> to the end of the ray segment     using <code class="xref py py-func docutils literal"><span class="pre">number_steps(meshwidth)()</span></code>.</p>
</li>
<li><p class="first">Compute an array of normal vectors representing the ray cone.</p>
</li>
<li><p class="first">Check the reflection number:</p>
<ul class="simple">
<li>If 0 then the <span class="math">\(calcvec[0]\)</span> term is 1.</li>
<li>ElseIf 1 then set <span class="math">\(calcvec[0]=0\)</span> and       <span class="math">\(calcvec[nre*Nob+nob]=e^{i \theta}\)</span>.</li>
<li>Else set <span class="math">\(calcvec[nre*Nob+nob]=e^{i \theta}\)</span>.</li>
</ul>
</li>
<li><p class="first">Step along the ray, For <span class="math">\(m1\in[0,Ns):\)</span></p>
<ul>
<li><p class="first">Check if the ray point is outside the domain.</p>
</li>
<li><p class="first">Calculate the co-ordinate of the centre.</p>
</li>
<li><p class="first">Recalculate distance to be for the centre point       <span class="math">\(Mesh[i1,j1,k1,:,col]=np.sqrt(np.dot((p0-p2),(p0-p2)))*calcvec\)</span>.</p>
</li>
<li><p class="first">For each normal:</p>
<ul class="simple">
<li>Find the next cone point <span class="math">\(p3\)</span> from the previous point         <span class="math">\(p1\)</span>, using the distance through a grid cube         <span class="math">\(\alpha\)</span>. This is given by:math:<cite>p3=p1+m2*alpha*norm</cite>.</li>
<li>Find the co-ordinate for the centre of the grid point z         corresponding to the <span class="math">\(p3\)</span>&#8216;s.</li>
<li>Find the distance to this centre point.</li>
<li>Set the column <span class="math">\(nra*Nre+nre\)</span> of the mesh term at         these grid points to the distance times the vector of         reflection angles.</li>
</ul>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Mesh</span><span class="p">[</span><span class="n">cpos</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">cpos</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">],</span><span class="n">cpos</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="p">],:,</span><span class="n">col</span><span class="p">]</span><span class="o">=</span><span class="n">r2</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">calcvec</span>
</pre></div>
</div>
</li>
<li><p class="first">Find the co-ordinate for the next ray point.       <span class="math">\(p1=p1+alpha*direc\)</span>.</p>
</li>
</ul>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Mesh, dist, calcvec</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.multiref">
<code class="descname">multiref</code><span class="sig-paren">(</span><em>s</em>, <em>room</em>, <em>Nre</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.multiref"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.multiref" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a ray and finds the first five reflections within a room.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>room</strong> &#8211; <a class="reference internal" href="#Room.room" title="Room.room"><code class="xref py py-class docutils literal"><span class="pre">Room.room</span></code></a> object which     contains all the obstacles in the room.</li>
<li><strong>Nre</strong> &#8211; The number of reflections. Integer value.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Using the function <code class="xref py py-func docutils literal"><span class="pre">reflect_calc(room)()</span></code> find the     co-ordinate of the reflected ray. Store this in s.points     and return whether the function was successful.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">3x1 numpy array.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">end=1 if unsuccessful, 0 is successful.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.normal_mat">
<code class="descname">normal_mat</code><span class="sig-paren">(</span><em>s</em>, <em>Ncones</em>, <em>Nra</em>, <em>d</em>, <em>dist</em>, <em>h</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.normal_mat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.normal_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Form a matrix of vectors representing the plane which is      normal to d</p>
<ul class="simple">
<li>Normalise the direction of the ray <span class="math">\(d=d/||d||\)</span></li>
<li>Calculate angle spacing between rays <span class="math">\(deltheta=2\arcsin(1/Ncones)\)</span></li>
<li>Calculate the number of normals. <span class="math">\(Nnor=1+(2\pi)/deltheta\)</span></li>
<li>Create an array of all the angles.</li>
</ul>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">anglevec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">ma</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Nnor</span><span class="p">),</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
<ul class="simple">
<li>The dot product of the direction and the normal needs to be 0.     Choose <span class="math">\((1,1,-(dx+dy)/dz)\)</span> as the first vector      (unless dz==0). Use this to compute another vector in the plane.      This forms a co-ordinate axis for the normal vectors.</li>
</ul>
<p>If dz==0 then instead choose the vector <span class="math">\((0,0,1)\)</span> and      repeat the process for the additional axis vector.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y</span><span class="o">=</span><span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="n">x</span> <span class="n">d</span>
<span class="n">y</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="o">/||</span><span class="n">y</span><span class="o">||</span><span class="p">)</span><span class="o">*</span><span class="n">y</span>
</pre></div>
</div>
<ul class="simple">
<li>Use the ais vectors as multiples of <span class="math">\(\cos(\theta)\)</span>      <span class="math">\(\sin(\theta)\)</span> to form equally space vectors.</li>
</ul>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">N</span><span class="o">=</span><span class="n">cos</span><span class="p">(</span><span class="n">anglevec</span><span class="p">)</span><span class="o">*</span> <span class="n">N</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">sin</span><span class="p">(</span><span class="n">anglevec</span><span class="p">)</span><span class="o">*</span><span class="n">y</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">N</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.number_cone_steps">
<code class="descname">number_cone_steps</code><span class="sig-paren">(</span><em>s</em>, <em>h</em>, <em>dist</em>, <em>Nra</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.number_cone_steps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.number_cone_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>find the number of steps taken along one normal in the cone</p>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.number_steps">
<code class="descname">number_steps</code><span class="sig-paren">(</span><em>s</em>, <em>meshwidth</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.number_steps"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.number_steps" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of steps along the ray between intersection points</p>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.obst_collision_point">
<code class="descname">obst_collision_point</code><span class="sig-paren">(</span><em>s</em>, <em>surface</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.obst_collision_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.obst_collision_point" title="Permalink to this definition">¶</a></dt>
<dd><p>intersection of the ray with a wall_segment</p>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.ray_length">
<code class="descname">ray_length</code><span class="sig-paren">(</span><em>s</em>, <em>inter</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.ray_length"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.ray_length" title="Permalink to this definition">¶</a></dt>
<dd><p>The length of the ray upto the intersection</p>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.raytest">
<code class="descname">raytest</code><span class="sig-paren">(</span><em>s</em>, <em>room</em>, <em>err</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.raytest"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.raytest" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks the reflection function for errors using the test     functions in <a class="reference internal" href="#module-reflection" title="reflection"><code class="xref py py-mod docutils literal"><span class="pre">reflection</span></code></a>.</p>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.ref_angle">
<code class="descname">ref_angle</code><span class="sig-paren">(</span><em>s</em>, <em>room</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.ref_angle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.ref_angle" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the reflection angle of the most recent intersected ray.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>room</strong> &#8211; <a class="reference internal" href="#module-Room" title="Room"><code class="xref py py-mod docutils literal"><span class="pre">Room</span></code></a>. <code class="xref py py-class docutils literal"><span class="pre">room</span></code> object which     contains all the obstacles in the room.</td>
</tr>
</tbody>
</table>
<p>Use the ray number stored in s.points[-2][-1] to retrieve     the obstacle number then retrieve that obstacle from room.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">norm</span><span class="o">=</span><span class="n">edge1</span> <span class="n">x</span> <span class="n">edge2</span>

<span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">ray_direc</span> <span class="o">.</span> <span class="n">norm</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="o">||</span><span class="n">ray_direc</span><span class="o">||</span> <span class="o">||</span><span class="n">norm</span><span class="o">||</span><span class="p">)</span>

<span class="n">theta</span><span class="o">=</span><span class="n">arccos</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)">float</a></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">theta</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.reflect_calc">
<code class="descname">reflect_calc</code><span class="sig-paren">(</span><em>s</em>, <em>room</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.reflect_calc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.reflect_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the reflection of the ray inside a room.</p>
<p>Method:</p>
<ul class="simple">
<li>If: the previous collision point was <em>None</em> then don&#8217;t find the     next one. Return: 1</li>
<li>Else: Compute the next collision point.<ul>
<li>If: the collision point doesn&#8217;t exist. Return: 1</li>
<li>Else: use the collision point to compute the reflected ray.       Return: 0</li>
</ul>
</li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">0 or 1 indicator of success.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">0 if  reflection was computed 1 if not.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Rays.Ray.room_collision_point">
<code class="descname">room_collision_point</code><span class="sig-paren">(</span><em>s</em>, <em>room</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Rays.html#Ray.room_collision_point"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Rays.Ray.room_collision_point" title="Permalink to this definition">¶</a></dt>
<dd><p>The closest intersection out of the possible intersections with
the wall_segments in room. Returns the intersection point and the
wall intersected with</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-Room">
<span id="room"></span><h1>Room<a class="headerlink" href="#module-Room" title="Permalink to this headline">¶</a></h1>
<p>Code to construct the mesh of the room</p>
<dl class="class">
<dt id="Room.room">
<em class="property">class </em><code class="descclassname">Room.</code><code class="descname">room</code><span class="sig-paren">(</span><em>s</em>, <em>obst</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room" title="Permalink to this definition">¶</a></dt>
<dd><p>A room is where the obstacle co-ordinates are contained.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>obst</strong> &#8211; is a Nobx3x[3x1] array, where Nob is the number of     obstacles.</td>
</tr>
</tbody>
</table>
<p>obst[j] is a 3x[3x1] array which is 3, 3D co-ordinates   which form a triangle.</p>
<p>This array of triangles forms the obstacles in the room.</p>
<dl class="docutils">
<dt>Attributes of room:</dt>
<dd><ul class="first last simple">
<li>s.obst=obst</li>
<li>.points[3*j]=obst[j][0]</li>
<li>s.maxlength is a 4x1 array initialised as empty. Once assigned     this is the maximum length in theroom and in the x, y, and z axis.</li>
<li>s.bounds is a 3x2 array     <span class="math">\(s.bounds= [ [minx, miny, minz], [maxx,maxy,maxz]]\)</span></li>
<li>s.inside_points is an initial empty array. Points which are known     to be inside obstacles are added to this array later.</li>
<li>s.time is an array with the time the room was created.</li>
<li>s.meshwidth is initialised as zero but is stored once asked for     using get_meshwidth.</li>
</ul>
</dd>
</dl>
<dl class="method">
<dt id="Room.room.coordinate">
<code class="descname">coordinate</code><span class="sig-paren">(</span><em>s</em>, <em>h</em>, <em>i</em>, <em>j</em>, <em>k</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room.coordinate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room.coordinate" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the co-ordinate of the point at the centre of the element.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>h</strong> &#8211; the meshwdith. Once assigned this matches s.meshwidth</li>
<li><strong>i</strong> &#8211; the first index or an array corresponding to the first     index for multiple points.</li>
<li><strong>j</strong> &#8211; the second index or an array corresponding to the second     index for multiple points.</li>
<li><strong>k</strong> &#8211; the third index or an array corresponding to the third     index for multiple points.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>If there is only 1 i, 1 j, and 1 k,</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">=</span><span class="p">[</span><span class="n">minx</span><span class="p">,</span><span class="n">miny</span><span class="p">,</span><span class="n">minz</span><span class="p">]</span> <span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">j</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">k</span><span class="o">+</span><span class="mf">0.5</span><span class="p">]</span>
</pre></div>
</div>
<p>ElseIf there&#8217;s arrays for i,j, and k,</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">=</span><span class="p">[[</span><span class="n">minx</span><span class="p">,</span><span class="n">miny</span><span class="p">,</span><span class="n">minz</span><span class="p">]</span> <span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="p">[</span><span class="n">i0</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">j0</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">k0</span><span class="o">+</span><span class="mf">0.5</span><span class="p">],</span><span class="o">...</span><span class="p">,</span>
  <span class="p">[</span><span class="n">minx</span><span class="p">,</span><span class="n">miny</span><span class="p">,</span><span class="n">minz</span><span class="p">]</span> <span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="p">[</span><span class="ow">in</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">jn</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span><span class="n">kn</span><span class="o">+</span><span class="mf">0.5</span> <span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">p</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Room.room.maxleng">
<code class="descname">maxleng</code><span class="sig-paren">(</span><em>s</em>, <em>a=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room.maxleng"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room.maxleng" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the maximum length in the room or axis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>a</strong> &#8211; the axis or room. a=0 maximum length in room, a=1 for     x-axis, a=2 for y-axis a=3 for z-axis.</td>
</tr>
</tbody>
</table>
<p>If the maxlength[a] hasn&#8217;t been found yet find it by comparing the     between points in s.points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">s.maxlength[a]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Room.room.position">
<code class="descname">position</code><span class="sig-paren">(</span><em>s</em>, <em>p</em>, <em>h</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room.position"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room.position" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the indexing position in a mesh with width h for point p     lying in the room s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>p</strong> &#8211; =[x,y,z] the co-ordinate of the point p or an array     of <span class="math">\(points p=[[x0,y0,z0],...,[xn,yn,zn]]\)</span></li>
<li><strong>h</strong> &#8211; is the meshwidth, once assigned this matches s.meshwidth</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>If p is one point,</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="p">[</span><span class="n">minx</span><span class="p">,</span><span class="n">miny</span><span class="p">,</span><span class="n">minz</span><span class="p">])</span><span class="o">//</span><span class="n">h</span><span class="p">,</span>
</pre></div>
</div>
<p>If p is an array of points,</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="o">=</span><span class="p">[(</span><span class="n">p0</span><span class="o">-</span><span class="p">[</span><span class="n">minx</span><span class="p">,</span><span class="n">miny</span><span class="p">,</span><span class="n">minz</span><span class="p">])</span><span class="o">//</span><span class="n">h</span><span class="p">,</span><span class="o">...</span><span class="p">,(</span><span class="n">pn</span><span class="o">-</span><span class="p">[</span><span class="n">minx</span><span class="p">,</span><span class="n">miny</span><span class="p">,</span><span class="n">minz</span><span class="p">])</span><span class="o">//</span><span class="n">h</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Room.room.ray_bounce">
<code class="descname">ray_bounce</code><span class="sig-paren">(</span><em>s</em>, <em>Tx</em>, <em>Nre</em>, <em>Nra</em>, <em>directions</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room.ray_bounce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room.ray_bounce" title="Permalink to this definition">¶</a></dt>
<dd><p>Trace ray&#8217;s uniformly emitted from an origin around a room.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>Nra</strong> &#8211; Number of rays</li>
<li><strong>Nre</strong> &#8211; number of reflections Nre</li>
<li><strong>directions</strong> &#8211; A Nra*3 array of the initial directions     for each ray.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The multiref function is used to find the Nre reflections for     the Nra rays with the obstacles s.obst.</p>
<p><span class="math">\(raylist=[[p00,p01,...,p0Nre],[p10,...,p1Nre],...,[pNra0,...,pNraNre]]\)</span></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">An array of the ray points.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">raylist</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Room.room.ray_mesh_bounce">
<code class="descname">ray_mesh_bounce</code><span class="sig-paren">(</span><em>s</em>, <em>Tx</em>, <em>Nre</em>, <em>Nra</em>, <em>directions</em>, <em>Mesh</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room.ray_mesh_bounce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room.ray_mesh_bounce" title="Permalink to this definition">¶</a></dt>
<dd><p>Traces ray&#8217;s uniformly emitted from an origin around a room.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>Tx</strong> &#8211; the co-ordinate of the transmitter location</li>
<li><strong>Nra</strong> &#8211; Number of rays</li>
<li><strong>Nre</strong> &#8211; number of reflections</li>
<li><strong>directions</strong> &#8211; Nra*3 array of the initial direction for     each ray.</li>
<li><strong>Mesh</strong> &#8211; a Nx*Ny*Nz*na*nb array (actually a dictionary of     sparse matrices using class DS but built to have similar     structure to an array).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">na</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Nob</span><span class="o">*</span><span class="n">Nre</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">nb</span><span class="o">=</span><span class="nb">int</span><span class="p">((</span><span class="n">Nre</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Nra</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The rays are reflected Nre times with the obstacles s.obst.     The points of intersection with the obstacles are stored in z
raylist. This is done using the mesh_multiref function.
As each intersection is found the mesh_multiref function     forms the line segment between intersection points and the     corresponding ray cone. All mesh elements in the ray cone store     the reflection angles and the distance along the ray cone from the     source to the centre of each mesh element. This is stored in Mesh.
See <code class="xref py py-func docutils literal"><span class="pre">Rays.mesh_multiref()</span></code> for more details on the     reflections and storage.</p>
<p>When complete the time in s.time() is assigned to the time taken     to complete the function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">raylist, Mesh</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="Room.room.ray_mesh_power_bounce">
<code class="descname">ray_mesh_power_bounce</code><span class="sig-paren">(</span><em>s</em>, <em>Tx</em>, <em>Nre</em>, <em>Nra</em>, <em>Direc</em>, <em>Grid</em>, <em>Znobrat</em>, <em>refindex</em>, <em>Antpar</em>, <em>Gt</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/Room.html#room.ray_mesh_power_bounce"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#Room.room.ray_mesh_power_bounce" title="Permalink to this definition">¶</a></dt>
<dd><p>Traces ray&#8217;s uniformly emitted from an origin around a room.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>Tx</strong> &#8211; the co-ordinate of the transmitter location</li>
<li><strong>Nra</strong> &#8211; Number of rays</li>
<li><strong>Nre</strong> &#8211; number of reflections</li>
<li><strong>directions</strong> &#8211; Nra*3 array of the initial direction for     each ray.</li>
<li><strong>Grid</strong> &#8211; a Nx*Ny*Nz array which will contain power values</li>
<li><strong>Znobrat</strong> &#8211; The array with the ratio of the impedance of an     obstacle over the impedance of air.</li>
<li><strong>refindex</strong> &#8211; Array with the refractive indices of an obstacle.</li>
<li><strong>Antpar</strong> &#8211; array with antenna parameters - scaled wavenumber, wavelength, lengthscale.</li>
<li><strong>Gt</strong> &#8211; transmitter gains.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>The rays are reflected Nre times with the obstacles s.obst.     The points of intersection with the obstacles are stored in z
raylist. This is done using the mesh_multiref function.
As each intersection is found the mesh_multiref function     forms the line segment between intersection points and the     corresponding ray cone. All mesh elements in the ray cone store     the power. This is stored in Grid.
See <code class="xref py py-func docutils literal"><span class="pre">Rays.mesh_multiref()</span></code> for more details on the     reflections and storage.</p>
<p>When complete the time in s.time() is assigned to the time taken     to complete the function.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">raylist, Grid</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-DictionarySparseMatrix">
<span id="mesh"></span><h1>Mesh<a class="headerlink" href="#module-DictionarySparseMatrix" title="Permalink to this headline">¶</a></h1>
<p>Code for the dictionary of sparse matrices class <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DS</span></code></a> which indexes like a multidimensional array but the array is sparse.  To exploit <code class="xref py py-mod docutils literal"><span class="pre">scipy.sparse.dok_matrix`=SM</span> <span class="pre">the</span> <span class="pre">`DS</span></code> uses a key for  each x,y, z position and associates a SM.</p>
<p>This module also contains functions which are not part of the class  but act on it.</p>
<dl class="class">
<dt id="DictionarySparseMatrix.DS">
<em class="property">class </em><code class="descclassname">DictionarySparseMatrix.</code><code class="descname">DS</code><span class="sig-paren">(</span><em>s</em>, <em>Nx=1</em>, <em>Ny=1</em>, <em>Nz=1</em>, <em>na=1</em>, <em>nb=1</em>, <em>dt=&lt;class 'numpy.complex128'&gt;</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS" title="Permalink to this definition">¶</a></dt>
<dd><p>The DS class is a dictionary of sparse matrices.
The keys for the dictionary are (i,j,k) such that i is in [0,Nx],
j is in [0, Ny], and k is in [0,Nz].
SM=DS[x,y,z] is a na*nb sparse matrix, initialised with complex128 data type.
<span class="math">\(na=(Nob*Nre+1)\)</span>
<span class="math">\(nb=((Nre)*(Nra)+1)\)</span>
The DS is initialised with keys Nx, Ny, and Nz to a dictionary with   keys,
<span class="math">\(\{ (x,y,z) \forall x \in [0,Nx), y \in [0,Ny), z \in [0,Nz)\}.\)</span></p>
<p>With the value at each key being an na*nb SM.</p>
<dl class="method">
<dt id="DictionarySparseMatrix.DS.asin">
<code class="descname">asin</code><span class="sig-paren">(</span><em>s</em>, <em>ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.asin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.asin" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds</p>
<p><span class="math">\(\theta=\arcsin(x)\)</span> for all terms <span class="math">\(x != 0\)</span> in     the DS s. Since all angles     <span class="math">\(\theta\)</span> are in <span class="math">\([0,\pi /2]\)</span>,     <span class="math">\(\arcsin(x)\)</span> is not a problem.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">DSM with the same dimensions as s, with     <span class="math">\(\arcsin(s)=\theta\)</span> in      the same positions as the corresponding theta terms.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.cos">
<code class="descname">cos</code><span class="sig-paren">(</span><em>s</em>, <em>ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.cos"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.cos" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds <span class="math">\(\cos(\theta)\)</span> for all terms     <span class="math">\(\theta != 0\)</span> in the DS s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A DSM with the same dimensions with     <span class="math">\(\cos(\theta)\)</span> in the      same position as the corresponding theta terms.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.cos_asin">
<code class="descname">cos_asin</code><span class="sig-paren">(</span><em>s</em>, <em>ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.cos_asin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.cos_asin" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds <span class="math">\(\cos( \asin( \theta))\)</span> for all terms     <span class="math">\(\theta != 0\)</span> in the DS s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A DSM with the same dimensions with     <span class="math">\(\cos( \asin( \theta))\)</span> in the      same position as the corresponding theta terms.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.costhetat">
<code class="descname">costhetat</code><span class="sig-paren">(</span><em>s</em>, <em>refindex</em>, <em>ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.costhetat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.costhetat" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes in a Mesh of angles with nonzero terms at ind. Computes
cos of thetat at those angles using the refractive index&#8217;s.
:param ind: The indices of the nonzero terms.
:param refindex: The refractive index&#8217;s of the obstacles in a vector.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">SIN</span><span class="o">=</span><span class="n">sin</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
<span class="n">thetat</span><span class="o">=</span><span class="n">asin</span><span class="p">(</span><span class="n">SIN</span><span class="o">/</span><span class="n">refindex</span><span class="p">)</span>
<span class="n">ctht</span><span class="o">=</span><span class="n">cos</span><span class="p">(</span><span class="n">thetat</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">DSM</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">ctht</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dense">
<code class="descname">dense</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dense"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dense" title="Permalink to this definition">¶</a></dt>
<dd><p>Fills the DSM s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A dense Nx x Ny x Nz x na x nb array with matching nonzero terms to      the sparse matrix s and zeroes elsewhere.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_DSM_divideby_vec">
<code class="descname">dict_DSM_divideby_vec</code><span class="sig-paren">(</span><em>s</em>, <em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_DSM_divideby_vec"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_DSM_divideby_vec" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide every column of the DSM s elementwise with the vector vec.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> &#8211; a row vector with length na.</td>
</tr>
</tbody>
</table>
<p>For integers <span class="math">\(x,y,z,k\)</span> and <span class="math">\(j\)</span> such that,
<span class="math">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">vec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">a DSM &#8216;out&#8217; with the same dimensions as s.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_DSM_divideby_vec_withind">
<code class="descname">dict_DSM_divideby_vec_withind</code><span class="sig-paren">(</span><em>s</em>, <em>vec</em>, <em>ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_DSM_divideby_vec_withind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_DSM_divideby_vec_withind" title="Permalink to this definition">¶</a></dt>
<dd><p>Divide every column of the DSM s elementwise with the vector vec.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> &#8211; a row vector with length na.</td>
</tr>
</tbody>
</table>
<p>For integers <span class="math">\(x,y,z,k\)</span> and <span class="math">\(j\)</span> such that,
<span class="math">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">/</span><span class="n">vec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">a DSM &#8216;out&#8217; with the same dimensions as s.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_col_mult_withind">
<code class="descname">dict_col_mult_withind</code><span class="sig-paren">(</span><em>s</em>, <em>ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_col_mult_withind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_col_mult_withind" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply all nonzero terms in a column.</p>
<p>In every grid point x,y,z of s there is a sparse matrix SM.     Take the product of all nonzero terms in each column and     keep these in a vector v.
Construct a new DS of size Nx x Ny x Nz x 1 x nb=s.shape[1].    Call this out. out[x,y,z] should be the v corresponding     to the SM in s at x,y,z.</p>
<dl class="docutils">
<dt>Method:</dt>
<dd><ul class="first last simple">
<li>Find the <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DS</span></code></a>. <a class="reference internal" href="#DictionarySparseMatrix.DS.nonzero" title="DictionarySparseMatrix.DS.nonzero"><code class="xref py py-func docutils literal"><span class="pre">nonzero()</span></code></a> indices of s.</li>
<li>For each nonzero x,y,z grid point find the       nonzero() indices of the SM. Do this by column so       that the output has pairs going through       each nonzero column and matching the nonzero row       number. Use function <a class="reference internal" href="#DictionarySparseMatrix.nonzero_bycol" title="DictionarySparseMatrix.nonzero_bycol"><code class="xref py py-func docutils literal"><span class="pre">nonzero_bycol()</span></code></a>.</li>
<li>Go through each of these indice pairs for the SM.       Check if the column index is new. If so assign       the column in out to the matching       value in the SM. If the column number is not       new then multiply the value in the column in       out by the corresponding value in the SM.</li>
</ul>
</dd>
</dl>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="o">=</span><span class="p">[</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">],</span>
<span class="o">...</span><span class="p">,</span>
<span class="p">[</span><span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="n">prod</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">column</span> <span class="n">nb</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">DS of size Nx x Ny x Nz x 1 x nb</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_row_vec_multiply">
<code class="descname">dict_row_vec_multiply</code><span class="sig-paren">(</span><em>s</em>, <em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_row_vec_multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_row_vec_multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply every row of the DSM s elementwise with the
vector vec.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> &#8211; a row vector with length na.</td>
</tr>
</tbody>
</table>
<p>For integers <span class="math">\(x,y,z,k\)</span> and <span class="math">\(j\)</span> such that,
<span class="math">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>Multiplication is done using     <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal"><span class="pre">dict_vec_multiply(vec)()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">A DSM &#8216;out&#8217; with the same dimensions as s.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_row_vec_multiply_withind">
<code class="descname">dict_row_vec_multiply_withind</code><span class="sig-paren">(</span><em>s</em>, <em>vec</em>, <em>ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_row_vec_multiply_withind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_row_vec_multiply_withind" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply every row of the DSM s elementwise with the
vector vec.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> &#8211; a row vector with length na.</td>
</tr>
</tbody>
</table>
<p>For integers <span class="math">\(x,y,z,k\)</span> and <span class="math">\(j\)</span> such that,
<span class="math">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">*</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>Multiplication is done using     <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal"><span class="pre">dict_vec_multiply(vec)()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">A DSM &#8216;out&#8217; with the same dimensions as s.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_scal_mult">
<code class="descname">dict_scal_mult</code><span class="sig-paren">(</span><em>s</em>, <em>scal</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_scal_mult"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_scal_mult" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply every term of the DSM s by scal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>scal</strong> &#8211; scalar variable</td>
</tr>
</tbody>
</table>
<p>For integers <span class="math">\(x,y,z,k\)</span> and <span class="math">\(j\)</span> such that,
<span class="math">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">scal</span><span class="o">*</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">DS(Nx,Ny,Nz,na,nb)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_vec_divideby_DSM">
<code class="descname">dict_vec_divideby_DSM</code><span class="sig-paren">(</span><em>s</em>, <em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_vec_divideby_DSM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_vec_divideby_DSM" title="Permalink to this definition">¶</a></dt>
<dd><p>Every column of the DSM s divides elementwise the vector vec.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> &#8211; a row vector with length na.</td>
</tr>
</tbody>
</table>
<p>For integers <span class="math">\(x,y,z,k\)</span> and <span class="math">\(j\)</span> such that,
<span class="math">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">/</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">a DSM &#8216;out&#8217; with the same dimensions as s.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.dict_vec_multiply">
<code class="descname">dict_vec_multiply</code><span class="sig-paren">(</span><em>s</em>, <em>vec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.dict_vec_multiply"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.dict_vec_multiply" title="Permalink to this definition">¶</a></dt>
<dd><p>Multiply every column of the DSM s elementwise with the     vector vec.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>vec</strong> &#8211; a row vector with length na.</td>
</tr>
</tbody>
</table>
<p>For integers <span class="math">\(x,y,z,k\)</span> and <span class="math">\(j\)</span> such that,
<span class="math">\(x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)\)</span>,</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">vec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
</pre></div>
</div>
<p>Multiplication is done using     <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal"><span class="pre">dict_vec_multiply(vec)()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">A DSM &#8216;out&#8217; with the same dimensions as s.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.nonzero">
<code class="descname">nonzero</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.nonzero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.nonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the indices of the nonzero terms in the DSM s.</p>
<blockquote>
<div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The indices are found by iterating through all           keys (x,y,z) for the DSM s and finding the nonzero           indices of the corresponding sparse matrix.           These indices are then combinded           with the x,y,z key and stacked to create a 5xN           array of all the nonzero terms in the DSM,           where N is the number of nonzero           terms.</p>
</div>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">indices=[ [x1,y1,z1,k1,j1],...,[xn,yn,zn,kn,jn]]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.nonzeroMat">
<code class="descname">nonzeroMat</code><span class="sig-paren">(</span><em>s</em>, <em>cor</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.nonzeroMat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.nonzeroMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the indices of the nonzero terms for part of the DSM s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cor</strong> &#8211; the part of s that you want the nonzero indices for.</td>
</tr>
</tbody>
</table>
<p>The indices are found by using the <a class="reference internal" href="#DictionarySparseMatrix.DS.nonzero" title="DictionarySparseMatrix.DS.nonzero"><code class="xref py py-func docutils literal"><span class="pre">nonzero()</span></code></a> function on s[cor]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">indices=[ [x1,y1,z1,k1,j1],...,[xn,yn,zn,kn,jn]]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.row_sum">
<code class="descname">row_sum</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.row_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.row_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum all nonzero terms in a row.</p>
<p>In every grid point x,y,z of s there is a sparse matrix SM.
Construct a new DS of size Nx x Ny x Nz x na=s.shape[0] x 1.
Call this out.
out[x,y,z] should be the corresponding na x1 SM to the SM in s at x,y,z.</p>
<dl class="docutils">
<dt>Method:</dt>
<dd><ul class="first last simple">
<li>Find the <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DS</span></code></a>. <a class="reference internal" href="#DictionarySparseMatrix.DS.nonzero" title="DictionarySparseMatrix.DS.nonzero"><code class="xref py py-func docutils literal"><span class="pre">nonzero()</span></code></a> indices of s`</li>
<li>Go through each of these indice. Check if the       row index is new. If so assign the row in out to the matching       value in the SM. If the row number is not new then sum the       value in the column in out by the corresponding value in the SM.</li>
</ul>
</dd>
</dl>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="o">=</span><span class="p">[</span>
<span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="n">na</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">],</span>
<span class="o">...</span><span class="p">,</span>
<span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="n">na</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">DS of size Nx x Ny x Nz x na x  1</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.row_sum_withind">
<code class="descname">row_sum_withind</code><span class="sig-paren">(</span><em>s</em>, <em>ind</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.row_sum_withind"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.row_sum_withind" title="Permalink to this definition">¶</a></dt>
<dd><p>Sum all nonzero terms in a row.</p>
<p>In every grid point x,y,z of s there is a sparse matrix SM.
Construct a new DS of size Nx x Ny x Nz x na=s.shape[0] x 1.
Call this out.
out[x,y,z] should be the corresponding na x1 SM to the SM in s at x,y,z.</p>
<dl class="docutils">
<dt>Method:</dt>
<dd><ul class="first last simple">
<li>Find the <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DS</span></code></a>. <a class="reference internal" href="#DictionarySparseMatrix.DS.nonzero" title="DictionarySparseMatrix.DS.nonzero"><code class="xref py py-func docutils literal"><span class="pre">nonzero()</span></code></a> indices of s`</li>
<li>Go through each of these indice. Check if the       row index is new. If so assign the row in out to the matching       value in the SM. If the row number is not new then sum the       value in the column in out by the corresponding value in the SM.</li>
</ul>
</dd>
</dl>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">out</span><span class="o">=</span><span class="p">[</span>
<span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="n">na</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="p">],</span>
<span class="o">...</span><span class="p">,</span>
<span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="mi">0</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="mi">1</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
<span class="o">...</span><span class="p">,</span>
<span class="nb">sum</span><span class="p">(</span><span class="n">nonzero</span> <span class="n">terms</span> <span class="ow">in</span> <span class="n">row</span> <span class="n">na</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="n">Nx</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="p">]</span>
<span class="p">]</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">DS of size Nx x Ny x Nz x na x  1</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">out</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.save_dict">
<code class="descname">save_dict</code><span class="sig-paren">(</span><em>s</em>, <em>filename_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.save_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.save_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the DSM s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; the name of the file to save to.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">nothing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.sin">
<code class="descname">sin</code><span class="sig-paren">(</span><em>s</em>, <em>ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.sin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.sin" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds <span class="math">\(\sin(\theta)\)</span> for all terms     <span class="math">\(\theta != 0\)</span> in the DS s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A DSM with the same dimensions with     <span class="math">\(\sin(\theta)\)</span> in the      same position as the corresponding theta terms.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.sparse_angles">
<code class="descname">sparse_angles</code><span class="sig-paren">(</span><em>s</em>, <em>ind=-1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.sparse_angles"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.sparse_angles" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds the angles <span class="math">\(\theta\)</span> which are the arguments     of the nonzero complex terms in the DSM s.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A DSM with the same dimensions with     <span class="math">\(\theta\)</span> in the same      position as the corresponding complex terms.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.stopcheck">
<code class="descname">stopcheck</code><span class="sig-paren">(</span><em>s</em>, <em>i</em>, <em>j</em>, <em>k</em>, <em>p1</em>, <em>h</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.stopcheck"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.stopcheck" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the index [i,j,k] is valid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>i</strong> &#8211; is the index for the x axis.</li>
<li><strong>j</strong> &#8211; is the index for the y axis.</li>
<li><strong>k</strong> &#8211; is the index for the z axis.</li>
<li><strong>p1</strong> &#8211; is the point at the end of the ray.</li>
<li><strong>h</strong> &#8211; is the mesh width</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">1 if valid, 0 if not.</p>
</td>
</tr>
</tbody>
</table>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">add the inside check to this function</p>
</div>
<div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">add the check for the end of the ray.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.stopchecklist">
<code class="descname">stopchecklist</code><span class="sig-paren">(</span><em>s</em>, <em>ps</em>, <em>p1</em>, <em>h</em>, <em>p3</em>, <em>n</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.stopchecklist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.stopchecklist" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if the list of points is valid.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>ps</strong> &#8211; the indices for the points in the list</li>
<li><strong>p1</strong> &#8211; the end of the ray</li>
<li><strong>h</strong> &#8211; the meshwidth</li>
<li><strong>p3</strong> &#8211; the points on the cone vectors</li>
<li><strong>n</strong> &#8211; the normal vectors forming the cone.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>start=0 if no points were valid if at least 1 point was valid,
ps=[[i1,j1,k1],...,[in,jn,kn]] the indices of the valid points,
p3=[[x1,y1,z1],...,[xn,yn,zn]] co-ordinates of the valid points,
N=[n0,...,nN] the normal vectors corresponding to the valid points.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">start, ps, p3, N</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="DictionarySparseMatrix.DS.togrid">
<code class="descname">togrid</code><span class="sig-paren">(</span><em>s</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#DS.togrid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.DS.togrid" title="Permalink to this definition">¶</a></dt>
<dd><p>Computethe matrix norm at each grid point and return a     3d numpy array.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Nx x Ny x Nz numpy array</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Grid</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.load_dict">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">load_dict</code><span class="sig-paren">(</span><em>filename_</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#load_dict"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.load_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a DS as a dictionary and construct the DS again.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>filename</strong> &#8211; the name of the DS saved</td>
</tr>
</tbody>
</table>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">Nx</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">Keys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">Keys</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">Ny</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">Keys</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">Keys</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">Nz</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">Keys</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">Keys</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">nothing</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.nonzero_bycol">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">nonzero_bycol</code><span class="sig-paren">(</span><em>SM</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#nonzero_bycol"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.nonzero_bycol" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the index pairs for the nonzero terms in a sparse matrix.
Go through each column and find the nonzero rows.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>SM</strong> &#8211; sparse matrix.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">[[i(0j0),i(1j0),...,i(nj0),...,i(njn)],    [j0,...,j0,...,jn,...,jn]]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.parnonzero">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">parnonzero</code><span class="sig-paren">(</span><em>nj</em>, <em>DS</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#parnonzero"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.parnonzero" title="Permalink to this definition">¶</a></dt>
<dd><p>Parallel version of a program with a dummy DS and a function for   finding the indices of the nonzero terms in a mesh.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>nj</strong> &#8211; number of processes.</li>
<li><strong>DS</strong> &#8211; the mesh</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Pool the nj processes
Specify what needs to be done.
Combine the information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">5xn array which n is the number of nonzero terms.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.phase_calc">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">phase_calc</code><span class="sig-paren">(</span><em>RadMesh</em>, <em>khat</em>, <em>L</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#phase_calc"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.phase_calc" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute <span class="math">\(\exp(i
rac{\hat{k}\hat{r}}{L^2})\)</span>   for a Mesh of <span class="math">\(r\)</span></p>
<blockquote>
<div><p>The phase is usually expressed at <span class="math">\(exp(ikr)\)</span>.
Since <span class="math">\(\hat{k}\)</span> and <span class="math">\(\hat{r}\)</span> are nondimensional lengths   scaled by the room length L the power of <span class="math">\(L^{-2}\)</span> must be used.</p>
<p>Exponentials are not defined on DS, instead use   <span class="math">\(\exp(i       heta)=\cos(     heta)+i\sin(    heta)\)</span>.</p>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">S1</span><span class="o">=</span><span class="n">RadMesh</span><span class="o">.</span><span class="n">dict_scal_mult</span><span class="p">(</span><span class="n">khat</span><span class="p">)</span>
<span class="n">S2</span><span class="o">=</span><span class="n">S1</span><span class="o">.</span><span class="n">dict_scal_mult</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="n">out</span><span class="o">=</span><span class="n">S1</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span><span class="o">+</span><span class="n">S1</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span><span class="o">.</span><span class="n">dict_scal_mult</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">rtype:</th><td class="field-body">DS of size Nx x Ny x Nz x na x 1</td>
</tr>
<tr class="field-even field"><th class="field-name">return:</th><td class="field-body">out</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.power_compute">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">power_compute</code><span class="sig-paren">(</span><em>Mesh</em>, <em>Grid</em>, <em>Znobrat</em>, <em>refindex</em>, <em>Antpar</em>, <em>Gt</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#power_compute"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.power_compute" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the field from a Mesh of ray information and the physical   parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>Mesh</strong> &#8211; The <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DS</span></code></a> mesh of ray information.</li>
<li><strong>Znobrat</strong> &#8211; An Nob x Nre+1 array containing tiles of the impedance     of obstacles divided by the impedance of air.</li>
<li><strong>refindex</strong> &#8211; An Nob x Nre+1 array containing tiles of the refractive    index of obstacles.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Method:</p>
<blockquote>
<div><ul class="simple">
<li>First compute the reflection coefficients using     <code class="xref py py-func docutils literal"><span class="pre">ref_coef(Mesh,Znobrat,refindex)()</span></code></li>
<li>Combine the reflection coefficients that correspond to the same     ray using <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal"><span class="pre">dict_col_mult()</span></code>. This     multiplies reflection coefficients in the same column.</li>
<li>Extract the distance each ray had travelled using     <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal"><span class="pre">__get_rad__()</span></code></li>
<li>Multiply by the gains for the corresponding ray.</li>
<li>Multiply terms by the phases     <span class="math">\(\exp(i\hat{k} \hat{r})^{L^{-2}}\)</span>. With <span class="math">\(L\)</span> being     the room length scale. <span class="math">\(\hat{r}\)</span> being the relative distance     travelled which is the actual distance divided by the room length     scale, and <span class="math">\(\hat{k}\)</span> is the relative wavenumber which is the     actual wavenumber times the room length scale.</li>
<li>Multiply by the gains corresponding to each ray.</li>
<li>Divide by the distance corresponding to each ray segment.</li>
<li>Sum all the ray segments in a grid point.</li>
<li>Multiply the grid by the transmitted field times the wavelngth     divided by the room length scale. <span class="math">\(\frac{\lambda}{L 4 \pi}\)</span></li>
<li>Multiply by initial polarisation vectors and combine.</li>
<li>Ignore dividing by initial phi as when converting to power in db     this disappears.</li>
<li>Take the amplitude and square.</li>
<li>Take <span class="math">\(10log10()\)</span> to get the db Power.</li>
</ul>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Nx x Ny x Nz numpy array of real values.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Grid</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.ref_coef">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">ref_coef</code><span class="sig-paren">(</span><em>Mesh</em>, <em>Znobrat</em>, <em>refindex</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#ref_coef"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.ref_coef" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the reflection coefficients.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Mesh</strong> &#8211; The DS mesh which contains terms re^(itheta) with theta   the reflection angle of incidence.</td>
</tr>
</tbody>
</table>
<p>Method:</p>
<blockquote>
<div><ul class="simple">
<li>Gets the mesh of angles using <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal"><span class="pre">sparse_angles()</span></code></li>
<li>Gets the indices of the nonzero terms using <a class="reference internal" href="#DictionarySparseMatrix.DS" title="DictionarySparseMatrix.DS"><code class="xref py py-class docutils literal"><span class="pre">DS</span></code></a>. <code class="xref py py-func docutils literal"><span class="pre">nonzero()</span></code></li>
<li>Initialise sin(thetai), cos(thetai) and cos(thetat) meshes.</li>
<li>Compute cos(thetai),sin(thetai), cos(thetat)</li>
</ul>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">cthi</span><span class="o">=</span><span class="n">AngDSM</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span>
<span class="n">SIN</span><span class="o">=</span><span class="n">AngDSM</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span>
<span class="n">Div</span><span class="o">=</span><span class="n">SIN</span><span class="o">.</span><span class="n">dict_DSM_divideby_vec</span><span class="p">(</span><span class="n">refindex</span><span class="p">)</span>
<span class="n">ctht</span><span class="o">=</span><span class="n">Div</span><span class="o">.</span><span class="n">asin</span><span class="p">()</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span>
</pre></div>
</div>
<ul class="simple">
<li>Compute the reflection coefficients.</li>
</ul>
<div class="code highlight-default"><div class="highlight"><pre><span></span><span class="n">S1</span><span class="o">=</span><span class="p">(</span><span class="n">cthi</span><span class="p">)</span><span class="o">.</span><span class="n">dict_vec_multiply</span><span class="p">(</span><span class="n">Znobrat</span><span class="p">)</span>
<span class="n">S2</span><span class="o">=</span><span class="p">(</span><span class="n">ctht</span><span class="p">)</span><span class="o">.</span><span class="n">dict_vec_multiply</span><span class="p">(</span><span class="n">Znobrat</span><span class="p">)</span>
<span class="n">Rper</span><span class="o">=</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">ctht</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">S1</span><span class="o">+</span><span class="n">ctht</span><span class="p">)</span>
<span class="n">Rpar</span><span class="o">=</span><span class="p">(</span><span class="n">cthi</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">cthi</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">Rper=DS(Nx,Ny,Nz,na,nb),Rpar=DS(Nx,Ny,Nz,na,nb)</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Rper, Rpar</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_14">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">test_14</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_14"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_14" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a test of the reflection coefficient function.
It sets test versions for the input parameters required and fills a DS   with dummy values.
It then computes the reflection coefficients associated with those   dummy parameters and values.</p>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_15">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">test_15</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_15"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_15" title="Permalink to this definition">¶</a></dt>
<dd><p>Testing multiplying nonzero terms in columns</p>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_17">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">test_17</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_17"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_17" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the <a class="reference internal" href="#DictionarySparseMatrix.parnonzero" title="DictionarySparseMatrix.parnonzero"><code class="xref py py-func docutils literal"><span class="pre">parnonzero()</span></code></a> function which should find   nonzero() indices in parallel.</p>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_18">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">test_18</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_18"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_18" title="Permalink to this definition">¶</a></dt>
<dd><p>Testing the save and load pickle functions.</p>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_19">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">test_19</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_19"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_19" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the <code class="xref py py-func docutils literal"><span class="pre">nonzero_bycol(SM)()</span></code> function.
Initialise a dummy sparse matrix SM.</p>
<dl class="docutils">
<dt>In <code class="xref py py-func docutils literal"><span class="pre">nonzero_bycol(SM)()</span></code>:</dt>
<dd><ul class="first last simple">
<li>Transpose the matrix.</li>
<li>Find the nonzero indices.</li>
<li>Swap the rows and columns in the indices.</li>
<li>Return the indices</li>
</ul>
</dd>
</dl>
<p>Check these match the nonzero terms in SM.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">0 if successful 1 if not.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_20">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">test_20</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_20"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_20" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the dict_col_mult() function.
Use a dummy DS with each matrix upper triangular with the number in   every position the row.
Check that the col_mult that comes out is the column number +1   factorial.</p>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_21">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">test_21</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_21"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_21" title="Permalink to this definition">¶</a></dt>
<dd><p>Test if the __get_rad__() function works.</p>
</dd></dl>

<dl class="function">
<dt id="DictionarySparseMatrix.test_22">
<code class="descclassname">DictionarySparseMatrix.</code><code class="descname">test_22</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/DictionarySparseMatrix.html#test_22"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#DictionarySparseMatrix.test_22" title="Permalink to this definition">¶</a></dt>
<dd><p>Test the set_item() function for setting columns in a DSM</p>
</dd></dl>

</div>
<div class="section" id="module-reflection">
<span id="reflection"></span><h1>Reflection<a class="headerlink" href="#module-reflection" title="Permalink to this headline">¶</a></h1>
<p>Code to Reflect a line in an edge without using Shapely</p>
<dl class="function">
<dt id="reflection.errorcheck">
<code class="descclassname">reflection.</code><code class="descname">errorcheck</code><span class="sig-paren">(</span><em>err</em>, <em>ray</em>, <em>ref</em>, <em>normedge</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/reflection.html#errorcheck"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#reflection.errorcheck" title="Permalink to this definition">¶</a></dt>
<dd><p>Take the input ray and output ray and the normal to the edge,
check that both vectors have the same angle to the normal</p>
</dd></dl>

<dl class="function">
<dt id="reflection.refangle">
<code class="descclassname">reflection.</code><code class="descname">refangle</code><span class="sig-paren">(</span><em>line</em>, <em>obst</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/reflection.html#refangle"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#reflection.refangle" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the reflection angle for the line reflection on the surface obst</p>
</dd></dl>

<dl class="function">
<dt id="reflection.test3">
<code class="descclassname">reflection.</code><code class="descname">test3</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/reflection.html#test3"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#reflection.test3" title="Permalink to this definition">¶</a></dt>
<dd><p>angle test</p>
</dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<p>Write an rst file for the notation.</p>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Welcome to DSMRayTracerDoc&#8217;s documentation!</a></li>
<li><a class="reference internal" href="#module-RayTracerMainProgram">Main Program</a></li>
<li><a class="reference internal" href="#module-ParameterInput">Input of the parameters</a></li>
<li><a class="reference internal" href="#module-Rays">Rays</a></li>
<li><a class="reference internal" href="#module-Room">Room</a></li>
<li><a class="reference internal" href="#module-DictionarySparseMatrix">Mesh</a></li>
<li><a class="reference internal" href="#module-reflection">Reflection</a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and tables</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="#">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/index.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Hayley.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
      |
      <a href="_sources/index.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>