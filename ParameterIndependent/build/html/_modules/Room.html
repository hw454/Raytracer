<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Room &#8212; DSMRayTracerDoc 0 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="DSMRayTracerDoc 0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for Room</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># Hayley Wragg 2017-07-18</span>
<span class="sd">&#39;&#39;&#39; Code to construct the mesh of the room &#39;&#39;&#39;</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">atan2</span><span class="p">,</span><span class="n">hypot</span><span class="p">,</span><span class="n">sqrt</span><span class="p">,</span><span class="n">copysign</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="k">import</span> <span class="n">sin</span><span class="p">,</span><span class="n">cos</span><span class="p">,</span><span class="n">atan2</span><span class="p">,</span><span class="n">log</span>
<span class="kn">import</span> <span class="nn">numpy</span>                <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">reflection</span>           <span class="k">as</span> <span class="nn">ref</span>
<span class="kn">import</span> <span class="nn">intersection</span>         <span class="k">as</span> <span class="nn">ins</span>
<span class="kn">import</span> <span class="nn">linefunctions</span>        <span class="k">as</span> <span class="nn">lf</span>
<span class="kn">import</span> <span class="nn">HayleysPlotting</span>      <span class="k">as</span> <span class="nn">hp</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span>    <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">math</span>                 <span class="k">as</span> <span class="nn">ma</span>
<span class="kn">import</span> <span class="nn">numpy.linalg</span>         <span class="k">as</span> <span class="nn">lin</span>
<span class="kn">import</span> <span class="nn">random</span>               <span class="k">as</span> <span class="nn">rnd</span>
<span class="kn">import</span> <span class="nn">Rays</span>                 <span class="k">as</span> <span class="nn">ry</span>
<span class="kn">import</span> <span class="nn">time</span>                 <span class="k">as</span> <span class="nn">t</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="n">epsilon</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">epsilon</span>

<div class="viewcode-block" id="room"><a class="viewcode-back" href="../index.html#Room.room">[docs]</a><span class="k">class</span> <span class="nc">room</span><span class="p">:</span>
  <span class="sd">&#39;&#39;&#39; A room is where the obstacle co-ordinates are contained.</span>

<span class="sd">  :param obst: is a Nobx3x[3x1] array, where Nob is the number of \</span>
<span class="sd">    obstacles.</span>

<span class="sd">  obst[j] is a 3x[3x1] array which is 3, 3D co-ordinates \</span>
<span class="sd">  which form a triangle.</span>

<span class="sd">  This array of triangles forms the obstacles in the room.</span>

<span class="sd">  Attributes of room:</span>
<span class="sd">    * s.obst=obst</span>
<span class="sd">    * .points[3*j]=obst[j][0]</span>
<span class="sd">    * s.maxlength is a 4x1 array initialised as empty. Once assigned \</span>
<span class="sd">    this is the maximum length in theroom and in the x, y, and z axis.</span>
<span class="sd">    *  s.bounds is a 3x2 array \</span>
<span class="sd">    :math:`s.bounds= [ [minx, miny, minz], [maxx,maxy,maxz]]`</span>
<span class="sd">    * s.inside_points is an initial empty array. Points which are known \</span>
<span class="sd">    to be inside obstacles are added to this array later.</span>
<span class="sd">    * s.time is an array with the time the room was created.</span>
<span class="sd">    * s.meshwidth is initialised as zero but is stored once asked for \</span>
<span class="sd">    using get_meshwidth.</span>

<span class="sd">  &#39;&#39;&#39;</span>
  <span class="c1">## Constructor</span>
  <span class="c1"># @param obst is a Nobx3x[3x1] array, where Nob is the number of</span>
  <span class="c1"># obstacles. obst[j] is a 3x[3x1] array which is 3, 3D co-ordinates</span>
  <span class="c1"># which form a triangle.</span>
  <span class="c1"># This array of triangles forms the obstacles in the room.</span>
  <span class="c1"># - s.obst=obst</span>
  <span class="c1"># - \f$ s.points[3*j]=obst[j][0] \f$</span>
  <span class="c1"># - s.maxlength is a 4x1 array initialised as empty. Once assigned this</span>
  <span class="c1"># is the maximum length in theroom and in the x, y, and z axis.</span>
  <span class="c1"># - s.bounds is a 3x2 array</span>
  <span class="c1"># \f$ s.bounds= [ [minx, miny, minz], [maxx,maxy,maxz]] \f$</span>
  <span class="c1"># - s.inside_points is an initial empty array. Points which are known</span>
  <span class="c1"># to be inside obstacles are added to this array later.</span>
  <span class="c1"># - s.time is an array with the time the room was created.</span>
  <span class="c1"># - s.meshwidth is initialised as zero but is stored once asked for</span>
  <span class="c1"># using get_meshwidth.</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">obst</span><span class="p">):</span>
    <span class="n">s</span><span class="o">.</span><span class="n">obst</span><span class="o">=</span><span class="n">obst</span>
    <span class="n">RoomP</span><span class="o">=</span><span class="n">obst</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">obst</span><span class="p">)):</span>
      <span class="n">RoomP</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">RoomP</span><span class="p">,</span><span class="n">obst</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">points</span><span class="o">=</span><span class="n">RoomP</span>
    <span class="c1"># Points is the array of all the co-ordinates which form the surfaces in the room</span>
    <span class="n">s</span><span class="o">.</span><span class="n">Nob</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">obst</span><span class="p">)</span>
    <span class="c1"># Nob is the number of surfaces forming obstacles in the room.</span>
    <span class="n">s</span><span class="o">.</span><span class="n">maxlength</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">bounds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">points</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">points</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>
    <span class="n">s</span><span class="o">.</span><span class="n">inside_points</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="c1"># The inside points line within obstacles and are used to detect if a ray is inside or outside.</span>
    <span class="n">s</span><span class="o">.</span><span class="n">time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
    <span class="c1"># The time taken for a computation is stored in time.</span>
    <span class="n">s</span><span class="o">.</span><span class="n">meshwidth</span><span class="o">=</span><span class="mf">0.0</span>
  <span class="c1">## Get the &#39;ith&#39; obstacle</span>
  <span class="c1"># @param i the indiex for the term being returned.</span>
  <span class="c1"># @return s.points[i]</span>
  <span class="k">def</span> <span class="nf">__get_obst__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
   <span class="sd">&#39;&#39;&#39; Returns the ith surface obstacle of the room s&#39;&#39;&#39;</span>
   <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">obst</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
  <span class="c1">## Get the &#39;ith&#39; inside point</span>
  <span class="c1"># @param i the indiex for the term being returned.</span>
  <span class="c1"># @return s.inside_points[i]</span>
  <span class="k">def</span> <span class="nf">__get_insidepoint__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
   <span class="sd">&#39;&#39;&#39; Returns the ith inside point of s &#39;&#39;&#39;</span>
   <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">inside_points</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
  <span class="c1">## Get the meshwidth.</span>
  <span class="c1"># @param Mesh the Nx*Ny*Nz*na*nb array which will be used to store</span>
  <span class="c1"># reflection angles and ray distances.</span>
  <span class="c1"># If the meshwidth has not yet been assigned then calculate it using</span>
  <span class="c1"># the number of terms in the x direction (Nx) in the mesh and the</span>
  <span class="c1"># maximum length in the x direction (s.maxlength[1]).</span>
  <span class="c1"># \f$ meshwidth=s.maxlength[1]/Nx \f$</span>
  <span class="c1"># If the meshwidth has already been found then it is returned without recalculating.</span>
  <span class="c1"># @return s.points[i]</span>
  <span class="k">def</span> <span class="nf">get_meshwidth</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">Mesh</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">meshwidth</span><span class="p">)</span><span class="o">&lt;</span><span class="n">epsilon</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">Mesh</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">maxlength</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">Mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">maxlength</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Nx</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">meshwidth</span>
  <span class="c1">## Add a new obst to the room.</span>
  <span class="c1"># @param obst0 is added to s.obst</span>
  <span class="c1"># @param obst0[0],obst0[1],obst0[2] are added to s.points.</span>
  <span class="c1"># @return nothing</span>
  <span class="k">def</span> <span class="nf">__set_obst__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">obst0</span><span class="p">):</span>
    <span class="n">s</span><span class="o">.</span><span class="n">obst</span><span class="o">+=</span><span class="p">(</span><span class="n">obst0</span><span class="p">,)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">points</span><span class="o">+=</span><span class="n">obst0</span>
    <span class="k">return</span>
  <span class="c1">##  Add the point p to the list of inside points for the room.</span>
  <span class="c1"># @param p=[x,y,z]</span>
  <span class="c1"># \if inside_points was empty then assign it to be p.</span>
  <span class="c1"># \f$s.insidepoints=[[x,y,z]]\f$ \endif</span>
  <span class="c1"># \else stack the new point underneath the previous array.</span>
  <span class="c1"># \f$ s.insidepoints=[[x0,y0,z0],[x1,y1,z1],...,[xn,yn,zn],[x,y,z]]\f$,</span>
  <span class="c1"># \f$s.insidepoints[j]=[xj,yj,zj]\f$ \endelse</span>
  <span class="c1"># @return nothing</span>
  <span class="k">def</span> <span class="nf">__set_insidepoint__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">p</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">inside_points</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
      <span class="n">s</span><span class="o">.</span><span class="n">inside_points</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">s</span><span class="o">.</span><span class="n">inside_points</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">s</span><span class="o">.</span><span class="n">inside_points</span><span class="p">,</span><span class="n">p</span><span class="p">))</span>
    <span class="k">return</span>
  <span class="c1">## The string representation of the room s is the string of the</span>
  <span class="c1"># obstacle co-ordinates.</span>
  <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;Room(&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">obst</span><span class="p">))</span><span class="o">+</span><span class="s1">&#39;)&#39;</span>
  <span class="c1">## Get the maximum length in the room or axis.</span>
  <span class="c1"># @param a the axis or room. a=0 maximum length in room, a=1 for</span>
  <span class="c1"># x-axis, a=2 for y-axis a=3 for z-axis.</span>
  <span class="c1"># .</span>
  <span class="c1"># \par</span>
  <span class="c1"># If the maxlength[a] hasn&#39;t been found yet find it by comparing the</span>
  <span class="c1"># length between points in s.points.</span>
  <span class="c1"># @return s.maxlength[a]</span>
<div class="viewcode-block" id="room.maxleng"><a class="viewcode-back" href="../index.html#Room.room.maxleng">[docs]</a>  <span class="k">def</span> <span class="nf">maxleng</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">a</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Get the maximum length in the room or axis.</span>

<span class="sd">    :param a: the axis or room. a=0 maximum length in room, a=1 for \</span>
<span class="sd">    x-axis, a=2 for y-axis a=3 for z-axis.</span>

<span class="sd">    If the maxlength[a] hasn&#39;t been found yet find it by comparing the \</span>
<span class="sd">    between points in s.points.</span>

<span class="sd">    :return: s.maxlength[a]</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Has the maxlength in the room been found yet? If no compute it.</span>
    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">maxlength</span><span class="p">[</span><span class="n">a</span><span class="p">])</span><span class="o">&lt;</span><span class="n">epsilon</span><span class="p">:</span>
      <span class="n">leng</span><span class="o">=</span><span class="mi">0</span>
      <span class="k">if</span> <span class="n">a</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">p1</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
          <span class="n">leng2</span><span class="o">=</span><span class="n">lf</span><span class="o">.</span><span class="n">length</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">]))</span>
          <span class="k">if</span> <span class="n">leng2</span><span class="o">&gt;</span><span class="n">leng</span><span class="p">:</span>
            <span class="n">s</span><span class="o">.</span><span class="n">maxlength</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">=</span><span class="n">leng2</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">maxlength</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">s</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
      <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">maxlength</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">maxlength</span><span class="p">[</span><span class="n">a</span><span class="p">]</span></div>
  <span class="c1">## maxxleng this function is no longer needed but won&#39;t be removed</span>
  <span class="c1"># until all programs calling it have been corrected.</span>
  <span class="c1"># @return s.maxleng(1)</span>
  <span class="k">def</span> <span class="nf">maxxleng</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">maxleng</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="c1">## maxyleng this function is no longer needed but won&#39;t be removed</span>
  <span class="c1"># until all programs calling it have been corrected.</span>
  <span class="c1"># @return s.maxleng(2)</span>
  <span class="k">def</span> <span class="nf">maxyleng</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">maxleng</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
  <span class="c1">## maxzleng this function is no longer needed but won&#39;t be removed</span>
  <span class="c1"># until all programs calling it have been corrected.</span>
  <span class="c1"># @return s.maxlength(3)</span>
  <span class="k">def</span> <span class="nf">maxzleng</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">maxleng</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="c1">## Find the indexing position in a mesh with width h for point p</span>
  <span class="c1">#  lying in the room s.</span>
  <span class="c1"># @param p =[x,y,z] the co-ordinate of the point p or an array of</span>
  <span class="c1"># points p=[[x0,y0,z0],...,[xn,yn,zn]]</span>
  <span class="c1"># @param h is the meshwidth, once assigned this matches s.meshwidth</span>
  <span class="c1"># If p is one point, out=(p-[minx,miny,minz])//h,</span>
  <span class="c1"># If p is an array of points,</span>
  <span class="c1"># out=[(p0-[minx,miny,minz])//h,...,(pn-[minx,miny,minz])//h]</span>
  <span class="c1"># @return out</span>
<div class="viewcode-block" id="room.position"><a class="viewcode-back" href="../index.html#Room.room.position">[docs]</a>  <span class="k">def</span> <span class="nf">position</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">p</span><span class="p">,</span><span class="n">h</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Find the indexing position in a mesh with width h for point p \</span>
<span class="sd">    lying in the room s.</span>

<span class="sd">    :param p: =[x,y,z] the co-ordinate of the point p or an array \</span>
<span class="sd">    of :math:`points p=[[x0,y0,z0],...,[xn,yn,zn]]`</span>
<span class="sd">    :param h: is the meshwidth, once assigned this matches s.meshwidth</span>

<span class="sd">    If p is one point,</span>

<span class="sd">    .. code::</span>

<span class="sd">       out=(p-[minx,miny,minz])//h,</span>

<span class="sd">    If p is an array of points,</span>

<span class="sd">    .. code::</span>

<span class="sd">       out=[(p0-[minx,miny,minz])//h,...,(pn-[minx,miny,minz])//h]</span>

<span class="sd">    :return: out</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">float</span><span class="p">):</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="nb">int</span><span class="p">):</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
      <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="n">s</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">//</span><span class="n">h</span>
      <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
      <span class="n">positions</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">p</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">],(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)))</span><span class="o">//</span><span class="n">h</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">positions</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Neither point nor array of points&quot;</span><span class="p">)</span></div>
  <span class="c1">## Find the co-ordinate of the point at the centre of the element.</span>
  <span class="c1"># @param h the meshwdith. Once assigned this matches s.meshwidth</span>
  <span class="c1"># @param i the first index or an array corresponding to the first</span>
  <span class="c1"># index for multiple points.</span>
  <span class="c1"># @param j the second index or an array corresponding to the second</span>
  <span class="c1"># index for multiple points.</span>
  <span class="c1"># @param k the third index or an array corresponding to the third</span>
  <span class="c1"># index for multiple points.</span>
  <span class="c1"># .</span>
  <span class="c1"># \par</span>
  <span class="c1"># \if there is only 1 i, 1 j, and 1 k,</span>
  <span class="c1"># \f$ p=[minx,miny,minz] +h*[i+0.5,j+0.5,k+0.5] \f$ \endif</span>
  <span class="c1"># \elseif there&#39;s arrays for i,j, and k,</span>
  <span class="c1"># \f$ p=[[minx,miny,minz] +h*[i0+0.5,j0+0.5,k0+0.5],...,</span>
  <span class="c1"># [minx,miny,minz] +h*[in+0.5,jn+0.5,kn+0.5 ]\f$ \endelseif</span>
  <span class="c1"># @return p</span>
<div class="viewcode-block" id="room.coordinate"><a class="viewcode-back" href="../index.html#Room.room.coordinate">[docs]</a>  <span class="k">def</span> <span class="nf">coordinate</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Find the co-ordinate of the point at the centre of the element.</span>

<span class="sd">    :param h: the meshwdith. Once assigned this matches s.meshwidth</span>

<span class="sd">    :param i: the first index or an array corresponding to the first \</span>
<span class="sd">    index for multiple points.</span>

<span class="sd">    :param j: the second index or an array corresponding to the second \</span>
<span class="sd">    index for multiple points.</span>

<span class="sd">    :param k: the third index or an array corresponding to the third \</span>
<span class="sd">    index for multiple points.</span>

<span class="sd">    If there is only 1 i, 1 j, and 1 k,</span>

<span class="sd">    .. code::</span>

<span class="sd">       p=[minx,miny,minz] +h*[i+0.5,j+0.5,k+0.5]</span>

<span class="sd">    ElseIf there&#39;s arrays for i,j, and k,</span>

<span class="sd">    .. code::</span>

<span class="sd">       p=[[minx,miny,minz] +h*[i0+0.5,j0+0.5,k0+0.5],...,</span>
<span class="sd">         [minx,miny,minz] +h*[in+0.5,jn+0.5,kn+0.5 ]</span>

<span class="sd">    :return: p</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">i</span><span class="p">,(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)):</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
      <span class="n">coord</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">])</span><span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">])</span>
      <span class="k">return</span> <span class="n">coord</span>
    <span class="k">elif</span> <span class="n">n</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
      <span class="n">Addarray</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">h</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">]),(</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
      <span class="n">coord</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">h</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">+</span><span class="n">Addarray</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">coord</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Neither point nor array of points&quot;</span><span class="p">)</span></div>
 <span class="c1">## Traces ray&#39;s uniformly emitted from an origin around a room.</span>
 <span class="c1"># @param Tx the co-ordinate of the transmitter location</span>
 <span class="c1"># @param Nra Number of rays</span>
 <span class="c1"># @param Nre number of reflections</span>
 <span class="c1"># @param directions Nra*3 array of the initial direction for each ray.</span>
 <span class="c1"># @param Mesh a Nx*Ny*Nz*na*nb array (actually a dictionary of sparse</span>
 <span class="c1"># matrices using class DS but built to have similar structure to an array).</span>
 <span class="c1"># na=int(Nob*Nre+1), nb=int((Nre)*(Nra)+1)</span>
 <span class="c1"># .</span>
 <span class="c1"># \par The rays are reflected Nre times with the obstacles s.obst. The</span>
 <span class="c1"># points of intersection with the obstacles are stored in raylist. This</span>
 <span class="c1"># is done using the mesh_multiref function.</span>
 <span class="c1"># \par As each intersection is found the mesh_multiref function</span>
 <span class="c1"># forms the line segment between intersection points and the</span>
 <span class="c1"># corresponding ray cone. All mesh elements in the ray cone store the</span>
 <span class="c1"># reflection angles and the distance along the ray cone from the source</span>
 <span class="c1"># to the centre of each mesh element. This is stored in Mesh.</span>
 <span class="c1"># See function mesh_multiref for more details on the reflections and</span>
 <span class="c1"># storage.</span>
 <span class="c1"># \par When complete the time in s.time() is assigned to the time taken</span>
 <span class="c1"># to complete the function.</span>
 <span class="c1"># @return raylist, Mesh</span>
<div class="viewcode-block" id="room.ray_mesh_bounce"><a class="viewcode-back" href="../index.html#Room.room.ray_mesh_bounce">[docs]</a>  <span class="k">def</span> <span class="nf">ray_mesh_bounce</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">Tx</span><span class="p">,</span><span class="n">Nre</span><span class="p">,</span><span class="n">Nra</span><span class="p">,</span><span class="n">directions</span><span class="p">,</span><span class="n">Mesh</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Traces ray&#39;s uniformly emitted from an origin around a room.</span>

<span class="sd">    :param Tx: the co-ordinate of the transmitter location</span>
<span class="sd">    :param Nra: Number of rays</span>
<span class="sd">    :param Nre: number of reflections</span>
<span class="sd">    :param directions: Nra*3 array of the initial direction for \</span>
<span class="sd">    each ray.</span>
<span class="sd">    :param Mesh: a Nx*Ny*Nz*na*nb array (actually a dictionary of \</span>
<span class="sd">    sparse matrices using class DS but built to have similar \</span>
<span class="sd">    structure to an array).</span>

<span class="sd">    .. code::</span>

<span class="sd">       na=int(Nob*Nre+1), nb=int((Nre)*(Nra)+1)</span>

<span class="sd">    The rays are reflected Nre times with the obstacles s.obst. \</span>
<span class="sd">    The points of intersection with the obstacles are stored in z</span>
<span class="sd">    raylist. This is done using the mesh_multiref function.</span>
<span class="sd">    As each intersection is found the mesh_multiref function \</span>
<span class="sd">    forms the line segment between intersection points and the \</span>
<span class="sd">    corresponding ray cone. All mesh elements in the ray cone store \</span>
<span class="sd">    the reflection angles and the distance along the ray cone from the \</span>
<span class="sd">    source to the centre of each mesh element. This is stored in Mesh.</span>
<span class="sd">    See :py:func:`Rays.mesh_multiref` for more details on the \</span>
<span class="sd">    reflections and storage.</span>

<span class="sd">    When complete the time in s.time() is assigned to the time taken \</span>
<span class="sd">    to complete the function.</span>

<span class="sd">    :return: raylist, Mesh</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">start_time</span>    <span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>         <span class="c1"># Start the time counter</span>
    <span class="n">r</span>             <span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">maxleng</span><span class="p">()</span>
    <span class="n">raylist</span>       <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">Nra</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nre</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">directions</span>    <span class="o">=</span><span class="n">r</span><span class="o">*</span><span class="n">directions</span>
    <span class="c1"># Iterate through the rays find the ray reflections</span>
    <span class="c1"># FIXME rays are independent of each other so this is parallelisable</span>
    <span class="c1">#FIXME Find out whether the ray points are correct.</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nra</span><span class="p">):</span>
      <span class="n">Dir</span>       <span class="o">=</span><span class="n">directions</span><span class="p">[</span><span class="n">it</span><span class="p">]</span>
      <span class="n">start</span>     <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Tx</span><span class="p">,[</span><span class="mi">0</span><span class="p">])</span>
      <span class="n">raystart</span>  <span class="o">=</span><span class="n">ry</span><span class="o">.</span><span class="n">Ray</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">Dir</span><span class="p">)</span>
      <span class="n">Mesh</span><span class="o">=</span><span class="n">raystart</span><span class="o">.</span><span class="n">mesh_multiref</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">Nre</span><span class="p">,</span><span class="n">Mesh</span><span class="p">,</span><span class="n">Nra</span><span class="p">,</span><span class="n">it</span><span class="p">)</span>
      <span class="n">raylist</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">=</span><span class="n">raystart</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">s</span><span class="o">.</span><span class="n">time</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start_time</span>
    <span class="k">return</span> <span class="n">raylist</span><span class="p">,</span> <span class="n">Mesh</span></div>
 <span class="c1">## ray_bounceTraces ray&#39;s uniformly emitted from an origin around a room.</span>
 <span class="c1"># @param Nra Number of rays</span>
 <span class="c1"># @param Nre number of reflections Nre</span>
 <span class="c1"># @param directions A Nra*3 array of the initial directions for each ray.</span>
 <span class="c1"># .</span>
 <span class="c1"># \par The multiref function is used to find the Nre reflections for</span>
 <span class="c1"># the Nra rays with the obstacles s.obst.</span>
 <span class="c1"># @return An array of the ray points.</span>
 <span class="c1"># \f$</span>
 <span class="c1"># raylist=[[p00,p01,...,p0Nre],[p10,...,p1Nre],...,[pNra0,...,pNraNre]]</span>
 <span class="c1">#  \f$</span>
<div class="viewcode-block" id="room.ray_mesh_power_bounce"><a class="viewcode-back" href="../index.html#Room.room.ray_mesh_power_bounce">[docs]</a>  <span class="k">def</span> <span class="nf">ray_mesh_power_bounce</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">Tx</span><span class="p">,</span><span class="n">Nre</span><span class="p">,</span><span class="n">Nra</span><span class="p">,</span><span class="n">Direc</span><span class="p">,</span><span class="n">Grid</span><span class="p">,</span><span class="n">Znobrat</span><span class="p">,</span><span class="n">refindex</span><span class="p">,</span><span class="n">Antpar</span><span class="p">,</span><span class="n">Gt</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Traces ray&#39;s uniformly emitted from an origin around a room.</span>

<span class="sd">    :param Tx: the co-ordinate of the transmitter location</span>
<span class="sd">    :param Nra: Number of rays</span>
<span class="sd">    :param Nre: number of reflections</span>
<span class="sd">    :param directions: Nra*3 array of the initial direction for \</span>
<span class="sd">    each ray.</span>
<span class="sd">    :param Grid: a Nx*Ny*Nz array which will contain power values</span>
<span class="sd">    :param Znobrat: The array with the ratio of the impedance of an \</span>
<span class="sd">    obstacle over the impedance of air.</span>
<span class="sd">    :param refindex: Array with the refractive indices of an obstacle.</span>
<span class="sd">    :param Antpar: array with antenna parameters - scaled wavenumber, wavelength, lengthscale.</span>
<span class="sd">    :param Gt: transmitter gains.</span>


<span class="sd">    The rays are reflected Nre times with the obstacles s.obst. \</span>
<span class="sd">    The points of intersection with the obstacles are stored in z</span>
<span class="sd">    raylist. This is done using the mesh_multiref function.</span>
<span class="sd">    As each intersection is found the mesh_multiref function \</span>
<span class="sd">    forms the line segment between intersection points and the \</span>
<span class="sd">    corresponding ray cone. All mesh elements in the ray cone store \</span>
<span class="sd">    the power. This is stored in Grid.</span>
<span class="sd">    See :py:func:`Rays.mesh_multiref` for more details on the \</span>
<span class="sd">    reflections and storage.</span>

<span class="sd">    When complete the time in s.time() is assigned to the time taken \</span>
<span class="sd">    to complete the function.</span>

<span class="sd">    :return: raylist, Grid</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">start_time</span>    <span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>         <span class="c1"># Start the time counter</span>
    <span class="n">r</span>             <span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">maxleng</span><span class="p">()</span>
    <span class="n">raylist</span>       <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">Nra</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nre</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
    <span class="n">directions</span>    <span class="o">=</span><span class="n">r</span><span class="o">*</span><span class="n">directions</span>
    <span class="c1"># Iterate through the rays find the ray reflections</span>
    <span class="c1"># FIXME rays are independent of each other so this is parallelisable</span>
    <span class="c1">#FIXME Find out whether the ray points are correct.</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nra</span><span class="p">):</span>
      <span class="n">Dir</span>       <span class="o">=</span><span class="n">directions</span><span class="p">[</span><span class="n">it</span><span class="p">]</span>
      <span class="n">start</span>     <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Tx</span><span class="p">,[</span><span class="mi">0</span><span class="p">])</span>
      <span class="n">raystart</span>  <span class="o">=</span><span class="n">ry</span><span class="o">.</span><span class="n">Ray</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">Dir</span><span class="p">)</span>
      <span class="k">try</span><span class="p">:</span>
          <span class="n">Grid</span><span class="o">=</span><span class="n">raystart</span><span class="o">.</span><span class="n">mesh_power_multiref</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">Nre</span><span class="p">,</span><span class="n">Grid</span><span class="p">,</span><span class="n">Nra</span><span class="p">,</span><span class="n">it</span><span class="p">,</span><span class="n">Znobrat</span><span class="p">,</span><span class="n">refindex</span><span class="p">,</span><span class="n">Antpar</span><span class="p">,</span><span class="n">Gt</span><span class="p">)</span>
      <span class="k">except</span><span class="p">:</span> <span class="k">raise</span><span class="p">(</span><span class="s1">&#39;Error in power mesh multiref&#39;</span><span class="p">)</span>
      <span class="n">raylist</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">=</span><span class="n">raystart</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">s</span><span class="o">.</span><span class="n">time</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start_time</span>
    <span class="k">return</span> <span class="n">raylist</span><span class="p">,</span> <span class="n">Grid</span></div>
 <span class="c1">## ray_bounceTraces ray&#39;s uniformly emitted from an origin around a room.</span>
 <span class="c1"># @param Nra Number of rays</span>
 <span class="c1"># @param Nre number of reflections Nre</span>
 <span class="c1"># @param directions A Nra*3 array of the initial directions for each ray.</span>
 <span class="c1"># .</span>
 <span class="c1"># \par The multiref function is used to find the Nre reflections for</span>
 <span class="c1"># the Nra rays with the obstacles s.obst.</span>
 <span class="c1"># @return An array of the ray points.</span>
 <span class="c1"># \f$</span>
 <span class="c1"># raylist=[[p00,p01,...,p0Nre],[p10,...,p1Nre],...,[pNra0,...,pNraNre]]</span>
 <span class="c1">#  \f$</span>
<div class="viewcode-block" id="room.ray_bounce"><a class="viewcode-back" href="../index.html#Room.room.ray_bounce">[docs]</a>  <span class="k">def</span> <span class="nf">ray_bounce</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">Tx</span><span class="p">,</span><span class="n">Nre</span><span class="p">,</span><span class="n">Nra</span><span class="p">,</span><span class="n">directions</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Trace ray&#39;s uniformly emitted from an origin around a room.</span>

<span class="sd">    :param Nra: Number of rays</span>
<span class="sd">    :param Nre: number of reflections Nre</span>
<span class="sd">    :param directions: A Nra*3 array of the initial directions \</span>
<span class="sd">    for each ray.</span>

<span class="sd">    The multiref function is used to find the Nre reflections for \</span>
<span class="sd">    the Nra rays with the obstacles s.obst.</span>

<span class="sd">    :math:`raylist=[[p00,p01,...,p0Nre],[p10,...,p1Nre],...,[pNra0,...,pNraNre]]`</span>

<span class="sd">    :rtype: An array of the ray points.</span>

<span class="sd">    :return: raylist</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">start_time</span>    <span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>         <span class="c1"># Start the time counter</span>
    <span class="n">r</span>             <span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">maxleng</span><span class="p">()</span>
    <span class="n">directions</span>    <span class="o">=</span><span class="n">r</span><span class="o">*</span><span class="n">directions</span>
    <span class="n">raylist</span>       <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">Nra</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Nre</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
    <span class="c1"># FIXME the rays are independent of each toher so this is easily parallelisable</span>
    <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nra</span><span class="p">):</span>
      <span class="n">Dir</span>       <span class="o">=</span><span class="n">directions</span><span class="p">[</span><span class="n">it</span><span class="p">]</span>
      <span class="n">start</span>     <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Tx</span><span class="p">,[</span><span class="mi">0</span><span class="p">])</span>
      <span class="n">raystart</span>  <span class="o">=</span><span class="n">ry</span><span class="o">.</span><span class="n">Ray</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">Dir</span><span class="p">)</span>
      <span class="n">raystart</span><span class="o">.</span><span class="n">multiref</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">Nre</span><span class="p">)</span>
      <span class="n">raylist</span><span class="p">[</span><span class="n">it</span><span class="p">]</span><span class="o">=</span><span class="n">raystart</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">s</span><span class="o">.</span><span class="n">time</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">start_time</span>
    <span class="k">return</span> <span class="n">raylist</span></div>
  <span class="c1">## Takes in n array of obsts and adds to the room</span>
  <span class="c1"># @param obsts=[obst0,obst1,...,obstn] the array of obstacles</span>
  <span class="c1"># .</span>
  <span class="c1"># \par The obstacles are add to s.obst and points are added to</span>
  <span class="c1"># s.points using add_obst.</span>
  <span class="c1"># \par The number of obstacles Nob is increased by n.</span>
  <span class="c1"># @return nothing</span>
  <span class="k">def</span> <span class="nf">roomobstadd</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">obsts</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">obst1</span> <span class="ow">in</span> <span class="n">obsts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
      <span class="n">s</span><span class="o">.</span><span class="n">add_obst</span><span class="p">(</span><span class="n">obst1</span><span class="p">)</span>
      <span class="n">s</span><span class="o">.</span><span class="n">Nob</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span></div>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Hayley.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
    </div>

    

    
  </body>
</html>