<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>DictionarySparseMatrix &#8212; DSMRayTracerDoc 0 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="DSMRayTracerDoc 0 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for DictionarySparseMatrix</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># Hayley 2019-05-01</span>
<span class="sd">&#39;&#39;&#39;Code for the dictionary of sparse matrices class :py:class:`DS` which\</span>
<span class="sd"> indexes like a multidimensional array but the array is sparse. \</span>
<span class="sd"> To exploit :py:mod:`scipy.sparse.dok_matrix`=SM the `DS` uses a key for \</span>
<span class="sd"> each x,y, z position and associates a SM.</span>

<span class="sd"> This module also contains functions which are not part of the class \</span>
<span class="sd"> but act on it.</span>

<span class="sd"> &#39;&#39;&#39;</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="k">import</span> <span class="n">dok_matrix</span> <span class="k">as</span> <span class="n">SM</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">product</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span> <span class="k">as</span> <span class="nn">t</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">from</span> <span class="nn">six.moves</span> <span class="k">import</span> <span class="n">cPickle</span> <span class="k">as</span> <span class="n">pkl</span>
<span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="k">import</span> <span class="n">Pool</span>
<span class="kn">import</span> <span class="nn">timeit</span>
<span class="c1">#from collections import defaultdict</span>

<span class="n">epsilon</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">epsilon</span>
<span class="c1">#----------------------------------------------------------------------</span>
<span class="c1"># NOTATION IN COMMENTS</span>
<span class="c1">#----------------------------------------------------------------------</span>
<span class="c1"># dk is dictionary key, smk is sparse matrix key, SM is a sparse matrix</span>
<span class="c1"># DS or DSM is a DS object which is a dictionary of sparse matrices.</span>

<div class="viewcode-block" id="DS"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS">[docs]</a><span class="k">class</span> <span class="nc">DS</span><span class="p">:</span>
  <span class="sd">&#39;&#39;&#39; The DS class is a dictionary of sparse matrices.</span>
<span class="sd">  The keys for the dictionary are (i,j,k) such that i is in [0,Nx],</span>
<span class="sd">  j is in [0, Ny], and k is in [0,Nz].</span>
<span class="sd">  SM=DS[x,y,z] is a na*nb sparse matrix, initialised with complex128 data type.</span>
<span class="sd">  :math:`na=(Nob*Nre+1)`</span>
<span class="sd">  :math:`nb=((Nre)*(Nra)+1)`</span>
<span class="sd">  The DS is initialised with keys Nx, Ny, and Nz to a dictionary with \</span>
<span class="sd">  keys,</span>
<span class="sd">  :math:`\{ (x,y,z) \\forall x \in [0,Nx), y \in [0,Ny), z \in [0,Nz)\}.`</span>

<span class="sd">  With the value at each key being an na*nb SM.</span>
<span class="sd">  &#39;&#39;&#39;</span>
  <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">Nx</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">Ny</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">Nz</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">na</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">):</span>
    <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
    <span class="n">Keys</span><span class="o">=</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Nz</span><span class="p">))</span>
    <span class="c1">#default_value=SM(s.shape,dtype=dt)</span>
    <span class="c1">#s.d=dict.fromkeys(Keys,SM(s.shape,dtype=dt))</span>
    <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="o">=</span><span class="p">{}</span>
    <span class="c1">#s.d=defaultdict(default_value)</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Keys</span><span class="p">:</span>
      <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">SM</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
    <span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="o">=</span><span class="n">Nx</span>
    <span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="o">=</span><span class="n">Ny</span>
    <span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="o">=</span><span class="n">Nz</span>
    <span class="n">s</span><span class="o">.</span><span class="n">time</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()])</span>
  <span class="c1">## @param i</span>
  <span class="c1"># - If &#39;i&#39; has length 5, i=[x,y,z,k,j] then this is the position of a</span>
  <span class="c1"># single term out=A[k,j] in a matrix A=DSM[x,y,z], return out.</span>
  <span class="c1"># - &#39;i&#39; has length 4 then i=[x,y,z,k], this is the position of a</span>
  <span class="c1"># row out=A[k] (array of length nb) of a sparse matrix corresponding</span>
  <span class="c1"># to the dictionary key A=DSM[x,y,z].</span>
  <span class="c1"># - If &#39;i&#39; has length 3 then i is the position of the whole sparse</span>
  <span class="c1"># matrix out=A for the sparse matrix at location [x,y,z].</span>
  <span class="c1"># .</span>
  <span class="c1"># \par</span>
  <span class="c1"># The &#39;k&#39; and &#39;j&#39; indices can be replaced with : to return rows or</span>
  <span class="c1"># columns of the SM A=DSM[x,y,z].</span>
  <span class="c1"># @return the &#39;i&#39; term of the DSM</span>
  <span class="k">def</span> <span class="nf">__get_SM__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Get a SM at the position dk=[x,y,z].</span>
<span class="sd">    * n indicates whether a whole SM is set, a row or a column.</span>
<span class="sd">    * If n==0 a whole SM.</span>
<span class="sd">    * If n==1 a row or rows.</span>
<span class="sd">      * n2 is the number of rows.</span>
<span class="sd">    * If n==2 a column or columns.</span>
<span class="sd">      * n2 is the number of columns.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1">#out=SM(s.shape,dtype=np.complex128)</span>
    <span class="n">dt</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
      <span class="n">out</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
      <span class="c1"># Get one row.</span>
      <span class="k">if</span> <span class="n">singletype</span><span class="p">(</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="n">n2</span><span class="o">=</span><span class="mi">1</span>
      <span class="c1"># Get multiple rows.</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">n2</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="c1"># Get a row</span>
      <span class="k">if</span> <span class="n">n2</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">out</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">][</span><span class="n">smk</span><span class="p">,:]</span>
      <span class="c1"># Get multiple rows</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">nkeys</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">smk</span><span class="p">)</span>
        <span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nkeys</span><span class="p">,</span><span class="n">nb</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">smk</span><span class="p">:</span>
          <span class="n">out</span><span class="p">[</span><span class="n">j</span><span class="p">,:]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">][</span><span class="n">j</span><span class="p">,:]</span>
          <span class="n">p</span><span class="o">+=</span><span class="mi">1</span>
    <span class="c1"># Get a  column or columns.</span>
    <span class="k">elif</span> <span class="n">n</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">singletype</span><span class="p">(</span><span class="n">smk</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="n">n2</span><span class="o">=</span><span class="mi">1</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">n2</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">smk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="k">if</span> <span class="n">n2</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">out</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">][</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">smk</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">na</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">na</span><span class="p">,</span><span class="n">n2</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n2</span><span class="p">):</span>
          <span class="n">out</span><span class="p">[:,</span><span class="n">c</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">][</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">c</span><span class="p">],</span><span class="n">smk</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># Invalid &#39;i&#39; the length does not match a possible position.</span>
      <span class="n">errmsg</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;Error setting the (</span><span class="si">%s</span><span class="s1">) part of the sparse matr</span>
<span class="s1">      ix to (</span><span class="si">%s</span><span class="s1">). Invalid index (</span><span class="si">%s</span><span class="s1">). A 3-tuple is required to</span>
<span class="s1">      return a sparse matrix(SM), 4-tuple for the row of a SM or</span>
<span class="s1">      5-tuple for the element in the SM.&#39;&#39;&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
      <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
      <span class="k">pass</span>
    <span class="k">return</span> <span class="n">out</span>
  <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Get all or part of a DSM.</span>

<span class="sd">    :param i:</span>

<span class="sd">      * If &#39;i&#39; has length 5, i=[x,y,z,k,j] then this is the position of \</span>
<span class="sd">      a single term out=A[k,j] in a matrix A=DSM[x,y,z], return out.</span>

<span class="sd">      * &#39;i&#39; has length 4 then i=[x,y,z,k], this is the position of a \</span>
<span class="sd">      row out=A[k] (array of length nb) of a sparse matrix corresponding \</span>
<span class="sd">      to the dictionary key A=DSM[x,y,z].</span>

<span class="sd">      * If &#39;i&#39; has length 3 then i is the position of the whole sparse \</span>
<span class="sd">      matrix out=A for the sparse matrix at location [x,y,z].</span>

<span class="sd">      The &#39;k&#39; and &#39;j&#39; indices can be replaced with : to return rows or \</span>
<span class="sd">      columns of the SM A=DSM[x,y,z].</span>

<span class="sd">    Method:</span>

<span class="sd">    * .. code::</span>

<span class="sd">         dk,smk=i[:3],i[3:]</span>

<span class="sd">    * If dk[0],dk[1], and dk[2] are all numbers and smk[0] and smk[1] \</span>
<span class="sd">      are not numbers of slices then :math:`k=1`. This means that a \</span>
<span class="sd">      whole sparse matrix is being set at the (x,y,z) position.</span>

<span class="sd">    * k indicates which (x,y,z) terms are being set.</span>

<span class="sd">      * If k==-1: Set only one grid position (x,y,z).</span>
<span class="sd">      * If k==0. Set all x positions with (y,z) co-ordinates.</span>
<span class="sd">      * If k==1. Set all y positions with (x,z) co-ordinates.</span>
<span class="sd">      * If k==2. Set all z positions with (x,y) co-ordinates.</span>
<span class="sd">      * If k==3. Set all x and y positions with (z) co-ordinates.</span>
<span class="sd">      * If k==4. Set all x and z  positions with (y) co-ordinates.</span>
<span class="sd">      * If k==5. Set all y and z  positions with (x) co-ordinates</span>
<span class="sd">      * If k==6. Set all x, y and z positions.</span>
<span class="sd">      * If k==7. Set all [x1,...,xn] , [y1,...,y1], [z1,...,zn] terms.</span>
<span class="sd">        In this case a numpy array is returned.</span>

<span class="sd">    * n indicates whether a whole SM is set, a row or a column.</span>

<span class="sd">      * If n==0 a whole SM.</span>
<span class="sd">      * If n==1 a row or rows.</span>
<span class="sd">        * n2 is the number of rows.</span>
<span class="sd">      * If n==2 a column or columns.</span>
<span class="sd">        * n2 is the number of columns.</span>

<span class="sd">    :param x: the new value to be assigned to DSM[i]</span>

<span class="sd">    :return: the &#39;i&#39; term of the DSM</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dk</span><span class="p">,</span><span class="n">smk</span><span class="o">=</span><span class="n">i</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
    <span class="c1"># If dk[0], dk[1], and dk[2] are numbers then one position (x,y,z)</span>
    <span class="c1"># is being refered to.</span>
    <span class="k">if</span> <span class="n">singletype</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
      <span class="k">if</span> <span class="n">singletype</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">singletype</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
          <span class="n">k</span><span class="o">=-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">k</span><span class="o">=</span><span class="mi">2</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">singletype</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
          <span class="n">k</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">k</span><span class="o">=</span><span class="mi">3</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span>  <span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
      <span class="n">k</span><span class="o">=</span><span class="mi">7</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">singletype</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">singletype</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
          <span class="n">k</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">k</span><span class="o">=</span><span class="mi">4</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">singletype</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
          <span class="n">k</span><span class="o">=</span><span class="mi">5</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">k</span><span class="o">=</span><span class="mi">6</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span>
    <span class="n">dt</span><span class="o">=</span><span class="nb">type</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">k</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
    <span class="c1">## Returning a scalar variable or sparse matrix at an exact \</span>
    <span class="c1"># position (dk0,dk1,dk2,smk0,smk1). Only return a sparse matrix is</span>
    <span class="c1"># smk is empty of slices.</span>
      <span class="n">out</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">__get_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
    <span class="c1">## Return a DS for all x in (0,Nx) and exact y=dk1, z=dk2, \</span>
    <span class="c1"># Each x,y,z term is either a SM or a scalar variable depending on</span>
    <span class="c1"># smk.</span>
      <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">):</span>
        <span class="n">dk</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">out</span><span class="p">[</span><span class="n">dk</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">__get_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
    <span class="c1">## Return a DS for all y in (0,Ny) and exact x=dk0, z=dk2, \</span>
    <span class="c1"># Each x,y,z term is either a SM or a scalar variable depending on</span>
    <span class="c1"># smk.</span>
      <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">):</span>
        <span class="n">dk</span><span class="o">=</span><span class="p">[</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">y</span><span class="p">,</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">out</span><span class="p">[</span><span class="n">dk</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">__get_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
    <span class="c1">## Return a DS for all z in (0,Nz) and exact x=dk0, y=dk1 \</span>
    <span class="c1"># Each x,y,z term is either a SM or a scalar variable depending on</span>
    <span class="c1"># smk.</span>
      <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">):</span>
        <span class="n">dk</span><span class="o">=</span><span class="p">[</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">y</span><span class="p">,</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">out</span><span class="p">[</span><span class="n">dk</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">__get_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
    <span class="c1">## Return a DS for all x in (0,Nx) and y in (0,Ny), and exact z=dk2, \</span>
    <span class="c1"># Each x,y,z term is either a SM or a scalar variable depending on</span>
    <span class="c1"># smk.</span>
      <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">)):</span>
        <span class="n">dk</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">out</span><span class="p">[</span><span class="n">dk</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">__get_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
    <span class="c1">## Return a DS for all x in (0,Nx) and z in (0,Nz) and exact y=dk1 \</span>
    <span class="c1"># Each x,y,z term is either a SM or a scalar variable depending on</span>
    <span class="c1"># smk.</span>
      <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">)):</span>
        <span class="n">dk</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">z</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="n">dk</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">__get_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">5</span><span class="p">:</span>
    <span class="c1">## Return a DS for all i in (0,Ny), z in (0,Nz) and exact x=dk0 \</span>
    <span class="c1"># Each x,y,z term is either a SM or a scalar variable depending on</span>
    <span class="c1"># smk.</span>
      <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="k">for</span> <span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">)):</span>
        <span class="n">dk</span><span class="o">=</span><span class="p">[</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="n">dk</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">__get_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">6</span><span class="p">:</span>
    <span class="c1">## Return a DS for all x in (0,Nx), y in (0,Ny) and z in (0,Nz) \</span>
    <span class="c1"># Each x,y,z term is either a SM or a scalar variable depending on</span>
    <span class="c1"># smk.</span>
      <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
      <span class="k">for</span> <span class="n">dk</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">out</span><span class="p">[</span><span class="n">dk</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">__get_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">7</span><span class="p">:</span>
      <span class="c1">## In the case when an 5xn co-ordinates are input output a nx1</span>
      <span class="c1"># array containing the terms in the respective positions.</span>
      <span class="n">nkey</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nkey</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">dt</span><span class="p">)</span>
      <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nkey</span><span class="p">):</span>
        <span class="n">sm</span><span class="o">=</span><span class="p">[</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">count</span><span class="p">],</span><span class="n">smk</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">count</span><span class="p">]]</span>
        <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">count</span><span class="p">],</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">count</span><span class="p">],</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">count</span><span class="p">])</span>
        <span class="n">out</span><span class="p">[</span><span class="n">count</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">__get_SM__</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no k has been assigned&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>
  <span class="k">def</span> <span class="nf">__set_SM__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Set a SM at the position dk=[x,y,z].</span>
<span class="sd">    * n indicates whether a whole SM is set, a row or a column.</span>
<span class="sd">    * If n==0 a whole SM.</span>
<span class="sd">    * If n==1 a row or rows.</span>
<span class="sd">      * n2 is the number of rows.</span>
<span class="sd">    * If n==2 a column or columns.</span>
<span class="sd">      * n2 is the number of columns.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
      <span class="c1"># If dk is not already one of the dictionary keys add the new</span>
      <span class="c1"># key to the DSM with an initialise SM.</span>
      <span class="k">if</span> <span class="n">dk</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">]</span><span class="o">=</span><span class="n">SM</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
      <span class="c1"># Assign &#39;x&#39; to the SM with key dk.</span>
      <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">]</span><span class="o">=</span><span class="n">x</span>
    <span class="k">elif</span> <span class="n">n</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
      <span class="c1"># Set one row.</span>
      <span class="k">if</span> <span class="n">singletype</span><span class="p">(</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span> <span class="n">n2</span><span class="o">=</span><span class="mi">1</span>
      <span class="c1"># Set multiple rows.</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">n2</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="c1"># If the key isn&#39;t in the DSM add it with the initialised SM.</span>
      <span class="k">if</span> <span class="n">dk</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">]</span><span class="o">=</span><span class="n">SM</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
      <span class="c1"># Set a row to the value &#39;x&#39;</span>
      <span class="k">if</span> <span class="n">n2</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">][</span><span class="n">smk</span><span class="p">,:]</span><span class="o">=</span><span class="n">x</span>
      <span class="c1"># Set multiple rows to the rows of &#39;x&#39;.</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">smk</span><span class="p">:</span>
          <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">][</span><span class="n">j</span><span class="p">,:]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">p</span><span class="p">]</span>
          <span class="n">p</span><span class="o">+=</span><span class="mi">1</span>
    <span class="c1"># set a SM element or column if smk[0]=: (slice) or multiple elements or columns.</span>
    <span class="k">elif</span> <span class="n">n</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
      <span class="k">if</span> <span class="n">singletype</span><span class="p">(</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">],(</span><span class="nb">slice</span><span class="p">)):</span> <span class="n">n2</span><span class="o">=</span><span class="mi">1</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">n2</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">if</span> <span class="n">dk</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">]</span><span class="o">=</span><span class="n">SM</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">n2</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="c1">#print(x) #DEBUG</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">],(</span><span class="nb">slice</span><span class="p">)):</span>
          <span class="n">n3</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
          <span class="k">if</span> <span class="n">singletype</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n3</span><span class="p">):</span>
              <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">][</span><span class="n">i</span><span class="p">,</span><span class="n">smk</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="n">x</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">singletype</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
              <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">][:,</span><span class="n">smk</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="n">x</span>
            <span class="k">else</span><span class="p">:</span>
              <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">][:,</span><span class="n">smk</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="n">x</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">][</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">smk</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">=</span><span class="n">x</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">end</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">end</span><span class="p">):</span>
          <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">dk</span><span class="p">][</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">c</span><span class="p">],</span><span class="n">smk</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">c</span><span class="p">]]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="c1"># Invalid &#39;i&#39; the length does not match a possible position.</span>
      <span class="n">errmsg</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;Error setting the (</span><span class="si">%s</span><span class="s1">) part of the sparse matr</span>
<span class="s1">      ix to (</span><span class="si">%s</span><span class="s1">). Invalid index (</span><span class="si">%s</span><span class="s1">). A 3-tuple is required to</span>
<span class="s1">      return a sparse matrix(SM), 4-tuple for the row of a SM or</span>
<span class="s1">      5-tuple for the element in the SM.&#39;&#39;&#39;</span> <span class="o">%</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">i</span><span class="p">))</span>
      <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
      <span class="k">pass</span>
  <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Set a new value to all or part of a DSM.</span>

<span class="sd">    :param i:</span>

<span class="sd">      * If &#39;i&#39; has length 5, i=[x,y,z,k,j] then this is the position of \</span>
<span class="sd">      a single term out=A[k,j] in a matrix A=DSM[x,y,z], return out.</span>

<span class="sd">      * &#39;i&#39; has length 4 then i=[x,y,z,k], this is the position of a \</span>
<span class="sd">      row out=A[k] (array of length nb) of a sparse matrix corresponding \</span>
<span class="sd">      to the dictionary key A=DSM[x,y,z].</span>

<span class="sd">      * If &#39;i&#39; has length 3 then i is the position of the whole sparse \</span>
<span class="sd">      matrix out=A for the sparse matrix at location [x,y,z].</span>

<span class="sd">      The &#39;k&#39; and &#39;j&#39; indices can be replaced with : to return rows or \</span>
<span class="sd">      columns of the SM A=DSM[x,y,z].</span>

<span class="sd">    Method:</span>

<span class="sd">    * .. code::</span>

<span class="sd">         dk,smk=i[:3],i[3:]</span>

<span class="sd">    * If dk[0],dk[1], and dk[2] are all numbers and smk[0] and smk[1] \</span>
<span class="sd">      are not numbers of slices then :math:`k=1`. This means that a \</span>
<span class="sd">      whole sparse matrix is being set at the (x,y,z) position.</span>

<span class="sd">    * k indicates which (x,y,z) terms are being set.</span>

<span class="sd">      * If k==-1: Set only one grid position (x,y,z).</span>
<span class="sd">      * If k==0. Set all x positions with (y,z) co-ordinates.</span>
<span class="sd">      * If k==1. Set all y positions with (x,z) co-ordinates.</span>
<span class="sd">      * If k==2. Set all z positions with (x,y) co-ordinates.</span>
<span class="sd">      * If k==3. Set all x and y positions with (z) co-ordinates.</span>
<span class="sd">      * If k==4. Set all x and z  positions with (y) co-ordinates.</span>
<span class="sd">      * If k==5. Set all y and z  positions with (x) co-ordinates</span>
<span class="sd">      * If k==6. Set all x, y and z positions.</span>
<span class="sd">      * If k==7. Set all [x1,...,xn] , [y1,...,y1], [z1,...,zn] terms.</span>

<span class="sd">    * n indicates whether a whole SM is set, a row or a column.</span>

<span class="sd">      * If n==0 a whole SM.</span>
<span class="sd">      * If n==1 a row or rows.</span>
<span class="sd">        * n2 is the number of rows.</span>
<span class="sd">      * If n==2 a column or columns.</span>
<span class="sd">        * n2 is the number of columns.</span>

<span class="sd">    :param x: the new value to be assigned to DSM[i]</span>

<span class="sd">    :return: the &#39;i&#39; term of the DSM</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dk</span><span class="p">,</span><span class="n">smk</span><span class="o">=</span><span class="n">i</span><span class="p">[:</span><span class="mi">3</span><span class="p">],</span><span class="n">i</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
    <span class="c1"># If dk[0], dk[1], and dk[2] are numbers then one position (x,y,z)</span>
    <span class="c1"># is being refered to.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">],(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="p">)):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">],(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="p">)):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">],(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="p">)):</span>
          <span class="n">k</span><span class="o">=-</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">k</span><span class="o">=</span><span class="mi">2</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">],(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="p">)):</span>
          <span class="n">k</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">k</span><span class="o">==</span><span class="mi">3</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span>  <span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
      <span class="n">k</span><span class="o">=</span><span class="mi">7</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">],(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="p">)):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">],(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="p">)):</span>
          <span class="n">k</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">k</span><span class="o">=</span><span class="mi">4</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">],(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="p">)):</span>
          <span class="n">k</span><span class="o">=</span><span class="mi">5</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">k</span><span class="o">=</span><span class="mi">6</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="mi">3</span>
    <span class="k">if</span> <span class="n">k</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
      <span class="n">s</span><span class="o">.</span><span class="n">__set_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">):</span>
        <span class="n">dk</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">s</span><span class="o">.</span><span class="n">__set_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">):</span>
        <span class="n">dk</span><span class="o">=</span><span class="p">[</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">y</span><span class="p">,</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">s</span><span class="o">.</span><span class="n">__set_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">z</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">):</span>
        <span class="n">dk</span><span class="o">=</span><span class="p">[</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">y</span><span class="p">,</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">s</span><span class="o">.</span><span class="n">__set_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">)):</span>
        <span class="n">dk</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="n">s</span><span class="o">.</span><span class="n">__set_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">4</span><span class="p">:</span>
       <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">)):</span>
        <span class="n">dk</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">z</span><span class="p">]</span>
        <span class="n">s</span><span class="o">.</span><span class="n">__set_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">5</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">)):</span>
        <span class="n">dk</span><span class="o">=</span><span class="p">[</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
        <span class="n">s</span><span class="o">.</span><span class="n">__set_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">6</span><span class="p">:</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">DS</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
          <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">dk</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
          <span class="n">s</span><span class="o">.</span><span class="n">__set_SM__</span><span class="p">(</span><span class="n">smk</span><span class="p">,</span><span class="n">dk</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">k</span><span class="o">==</span><span class="mi">7</span><span class="p">:</span>
      <span class="n">nkey</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nkey</span><span class="p">):</span>
        <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="n">dk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">count</span><span class="p">],</span><span class="n">dk</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">count</span><span class="p">],</span><span class="n">dk</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">count</span><span class="p">])</span>
        <span class="n">sm</span><span class="o">=</span><span class="p">[</span><span class="n">smk</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">count</span><span class="p">],</span><span class="n">smk</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">count</span><span class="p">]]</span>
        <span class="n">s</span><span class="o">.</span><span class="n">__set_SM__</span><span class="p">(</span><span class="n">sm</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">x</span><span class="p">[</span><span class="n">count</span><span class="p">],</span><span class="n">n</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;no k has been assigned&#39;</span><span class="p">)</span>
    <span class="k">return</span>
  <span class="c1">## String representation of the DSM s.</span>
  <span class="c1"># constructs a string of the keys with their corresponding values</span>
  <span class="c1"># (sparse matrices with the nonzero positions and values).</span>
  <span class="c1"># @return the string of the DSM s.</span>
  <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">keys</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">out</span><span class="o">=</span><span class="nb">str</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
      <span class="n">new</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
      <span class="n">out</span><span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;&quot; </span><span class="si">{0}</span><span class="s2"></span>
<span class="s2">               </span><span class="si">{1}</span><span class="s2">&quot;&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">,</span><span class="n">new</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>
  <span class="c1">## Add two DSM&#39;s together.</span>
  <span class="c1"># Add sparse matrices from DSM and DSM2 elementwise if they have the</span>
  <span class="c1"># same dictionary key (x,y,z).</span>
  <span class="c1"># Return a new DSM with the same dimensions</span>
  <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DSM2</span><span class="p">):</span>
    <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">)):</span>
      <span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">+</span><span class="n">DSM2</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out</span>
  <span class="c1">## Subtract DSM2 from DSM</span>
  <span class="c1"># Subtract sparse matrices in DSM2 from DSM elementwise if they have the</span>
  <span class="c1"># same dictionary key (x,y,z).</span>
  <span class="c1"># Return a new DSM with the same dimensions</span>
  <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DSM</span><span class="p">):</span>
    <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">)):</span>
      <span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">-</span><span class="n">DSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out</span>
  <span class="c1">## Multiply DSM2 with s</span>
  <span class="c1"># Perform matrix multiplication AB for all sparse matrices A in s</span>
  <span class="c1"># and B in DSM2 with the same key (x,y,z)</span>
  <span class="c1"># @param DSM2 is a DSM with the same dimensions as s.</span>
  <span class="c1"># @return a new DSM with the same dimensions</span>
  <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DSM2</span><span class="p">):</span>
    <span class="c1">#LOOKAT could use nonzero indices but is finding the indices slower than repeating.</span>
    <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">)):</span>
      <span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">DSM2</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">out</span>
  <span class="c1">## Divide elementwise s with DSM2</span>
  <span class="c1"># Perform elementwise division A/B for all sparse matrices A in DSM</span>
  <span class="c1"># and B in DSM2 with the same key (x,y,z).</span>
  <span class="c1"># @param DSM2 is a DSM with the same dimensions as s.</span>
  <span class="c1"># @return a new DSM with the same dimensions</span>
  <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">DSM2</span><span class="p">):</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">DSM2</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">T</span>
    <span class="n">out</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]],</span><span class="n">DSM2</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">out</span>
  <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">DSM2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; If all non-zero terms aren&#39;t equal then matrices aren&#39;t equal.</span>
<span class="sd">    :return: True if equal, False if not.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">)):</span>
      <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">-</span><span class="n">DSM2</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">-</span><span class="n">DSM2</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="n">epsilon</span><span class="p">:</span>
          <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span> <span class="k">pass</span>
      <span class="k">else</span><span class="p">:</span> <span class="k">pass</span>
    <span class="k">return</span> <span class="kc">True</span>
  <span class="k">def</span> <span class="nf">__self_eq__</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Check that the SMs at each grid point aren&#39;t equal.</span>

<span class="sd">    Method:</span>
<span class="sd">    Check each grid point against a different one. If o</span>
<span class="sd">    :return: True if equal, False if not.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">z1</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">)):</span>
      <span class="k">for</span> <span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">z2</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">x1</span><span class="o">==</span><span class="n">x1</span> <span class="ow">and</span> <span class="n">y1</span><span class="o">==</span><span class="n">y2</span> <span class="ow">and</span> <span class="n">z1</span><span class="o">==</span><span class="n">z2</span><span class="p">:</span> <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">ind</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">z1</span><span class="p">]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
          <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
          <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">z1</span><span class="p">][</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span><span class="o">!=</span><span class="n">s</span><span class="p">[</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">z2</span><span class="p">][</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]]:</span> <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">pass</span>
    <span class="k">return</span> <span class="kc">True</span>
  <span class="c1">## Return the distance which is stored in each column of s</span>
  <span class="c1"># @rtype a new DS with sparse vectors rather than matrices in each grid element</span>
  <span class="c1"># @return DS(Nx,Ny,Nz,1,nb)</span>
  <span class="k">def</span> <span class="nf">__get_rad__</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return a DS corresponding to the distances stored in the mesh.</span>

<span class="sd">      * Initialise out=DS(Nx,Ny,Nz,1,s.shape[1])</span>

<span class="sd">      * Go through all the nonzero x,y,z grid points.</span>

<span class="sd">      * Go through the nonzero columns and put the absolute value of the \</span>
<span class="sd">      first term in the corresponding column in out[x,y,z]</span>

<span class="sd">      * Pass until the next nonzero index is for a new column and repeat.</span>

<span class="sd">    :rtype: DS(Nx,Ny,Nz,1,s.shape[1]) of real values.</span>

<span class="sd">    :return: out</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">float</span><span class="p">)</span>
    <span class="c1"># Find the nonzero indices. There&#39;s no need to retrieve distances on 0 terms.</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">T</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">p</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">l</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">m</span><span class="o">=-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
      <span class="c1"># No need to go through the same grid element again.</span>
      <span class="k">if</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">p</span> <span class="ow">and</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">l</span> <span class="ow">and</span> <span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">m</span><span class="p">:</span>
        <span class="k">pass</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">ind2</span><span class="o">=</span><span class="n">nonzero_bycol</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]])</span>
        <span class="n">p</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">l</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">m</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">chk</span><span class="o">=-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ind2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
          <span class="k">if</span> <span class="n">chk</span><span class="o">==</span><span class="n">j</span><span class="p">:</span>
            <span class="k">pass</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">ind2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">count</span><span class="p">],</span><span class="n">j</span><span class="p">])</span>
            <span class="n">chk</span><span class="o">=</span><span class="n">j</span>
          <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">out</span>
  <span class="k">def</span> <span class="nf">__get_rad__withind__</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">ind</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Return a DS corresponding to the distances stored in the mesh.</span>

<span class="sd">      * Initialise out=DS(Nx,Ny,Nz,1,s.shape[1])</span>

<span class="sd">      * Go through all the nonzero x,y,z grid points.</span>

<span class="sd">      * Go through the nonzero columns and put the absolute value of the \</span>
<span class="sd">      first term in the corresponding column in out[x,y,z]</span>

<span class="sd">      * Pass until the next nonzero index is for a new column and repeat.</span>

<span class="sd">    :rtype: DS(Nx,Ny,Nz,1,s.shape[1]) of real values.</span>

<span class="sd">    :return: out</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="nb">float</span><span class="p">)</span>
    <span class="c1"># Find the nonzero indices. There&#39;s no need to retrieve distances on 0 terms.</span>
    <span class="c1">#ind=s.nonzero()</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">T</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">p</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">l</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">m</span><span class="o">=-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
      <span class="c1"># No need to go through the same grid element again.</span>
      <span class="k">if</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">p</span> <span class="ow">and</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">l</span> <span class="ow">and</span> <span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">m</span><span class="p">:</span>
        <span class="k">pass</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">ind2</span><span class="o">=</span><span class="n">nonzero_bycol</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]])</span>
        <span class="n">p</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">l</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">m</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">chk</span><span class="o">=-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ind2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
          <span class="k">if</span> <span class="n">chk</span><span class="o">==</span><span class="n">j</span><span class="p">:</span>
            <span class="k">pass</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="nb">abs</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">ind2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">count</span><span class="p">],</span><span class="n">j</span><span class="p">])</span>
            <span class="n">chk</span><span class="o">=</span><span class="n">j</span>
          <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">out</span>
  <span class="c1">## Finds arcsin(theta) for all terms theta \!= 0 in DSM.</span>
  <span class="c1"># @return a DSM with the same dimensions with arcsin(theta) in the</span>
  <span class="c1"># same position as the corresponding theta terms.</span>
  <span class="k">def</span> <span class="nf">truediv_withind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">DSM2</span><span class="p">,</span><span class="n">ind</span><span class="p">):</span>
    <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">T</span>
    <span class="n">out</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]],</span><span class="n">DSM2</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">out</span>
  <span class="k">def</span> <span class="nf">mul_withind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">DSM2</span><span class="p">,</span><span class="n">ind</span><span class="p">):</span>
    <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">T</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">p</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">l</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">m</span><span class="o">=-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
      <span class="n">x</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
      <span class="n">y</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
      <span class="n">z</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
      <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="n">p</span> <span class="ow">and</span> <span class="n">y</span><span class="o">==</span><span class="n">l</span> <span class="ow">and</span> <span class="n">z</span><span class="o">==</span><span class="n">m</span><span class="p">:</span>
        <span class="k">pass</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span><span class="o">=</span><span class="n">x</span>
        <span class="n">l</span><span class="o">=</span><span class="n">y</span>
        <span class="n">m</span><span class="o">=</span><span class="n">z</span>
        <span class="n">out</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">DSM2</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">out</span>
<div class="viewcode-block" id="DS.togrid"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.togrid">[docs]</a>  <span class="k">def</span> <span class="nf">togrid</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Computethe matrix norm at each grid point and return a \</span>
<span class="sd">    3d numpy array.</span>

<span class="sd">    :rtype: Nx x Ny x Nz numpy array</span>

<span class="sd">    :return: Grid</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">Nx</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span>
    <span class="n">Ny</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span>
    <span class="n">Nz</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span>
    <span class="n">na</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Grid</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nx</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ny</span><span class="p">),</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nz</span><span class="p">)):</span>
      <span class="n">Grid</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">=</span><span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Grid</span></div>

<div class="viewcode-block" id="DS.asin"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.asin">[docs]</a>  <span class="k">def</span> <span class="nf">asin</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">ind</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Finds</span>

<span class="sd">    :math:`\\theta=\\arcsin(x)` for all terms :math:`x != 0` in \</span>
<span class="sd">    the DS s. Since all angles \</span>
<span class="sd">    :math:`\\theta` are in :math:`[0,\pi /2]`, \</span>
<span class="sd">    :math:`\\arcsin(x)` is not a problem.</span>

<span class="sd">    :returns: DSM with the same dimensions as s, with \</span>
<span class="sd">    :math:`\\arcsin(s)=\\theta` in \</span>
<span class="sd">     the same positions as the corresponding theta terms.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
      <span class="n">ind</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">pass</span>
    <span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">asinDSM</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
    <span class="n">asinDSM</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">asinDSM</span></div>
  <span class="c1">## Finds cos(theta) for all terms theta \!= 0 in DSM.</span>
  <span class="c1"># @return a DSM with the same dimensions with cos(theta) in the</span>
  <span class="c1"># same position as the corresponding theta terms.</span>
<div class="viewcode-block" id="DS.cos"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.cos">[docs]</a>  <span class="k">def</span> <span class="nf">cos</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">ind</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Finds :math:`\\cos(\\theta)` for all terms \</span>
<span class="sd">    :math:`\\theta != 0` in the DS s.</span>

<span class="sd">    :returns: A DSM with the same dimensions with \</span>
<span class="sd">    :math:`\\cos(\\theta)` in the \</span>
<span class="sd">     same position as the corresponding theta terms.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
      <span class="n">ind</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">pass</span>
    <span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">CosDSM</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
    <span class="n">CosDSM</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">CosDSM</span></div>
<div class="viewcode-block" id="DS.cos_asin"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.cos_asin">[docs]</a>  <span class="k">def</span> <span class="nf">cos_asin</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">ind</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Finds :math:`\\cos( \\asin( \\theta))` for all terms \</span>
<span class="sd">    :math:`\\theta != 0` in the DS s.</span>

<span class="sd">    :returns: A DSM with the same dimensions with \</span>
<span class="sd">    :math:`\\cos( \\asin( \\theta))` in the \</span>
<span class="sd">     same position as the corresponding theta terms.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
      <span class="n">ind</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">pass</span>
    <span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">CosDSM</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
    <span class="n">CosDSM</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]]))</span>
    <span class="k">return</span> <span class="n">CosDSM</span></div>
  <span class="c1">## Finds sin(theta) for all terms theta \!= 0 in DSM.</span>
  <span class="c1"># @return a DSM with the same dimensions with sin(theta) in the</span>
  <span class="c1"># same position as the corresponding theta terms.</span>
<div class="viewcode-block" id="DS.sin"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.sin">[docs]</a>  <span class="k">def</span> <span class="nf">sin</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">ind</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Finds :math:`\\sin(\\theta)` for all terms \</span>
<span class="sd">    :math:`\\theta != 0` in the DS s.</span>

<span class="sd">    :return: A DSM with the same dimensions with \</span>
<span class="sd">    :math:`\\sin(\\theta)` in the \</span>
<span class="sd">     same position as the corresponding theta terms.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
      <span class="n">ind</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">pass</span>
    <span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">SinDSM</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
    <span class="n">SinDSM</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">SinDSM</span></div>
  <span class="c1">## Finds the angles theta which are the arguments of the nonzero</span>
  <span class="c1"># complex terms in the DSM s.</span>
  <span class="c1"># @return a DSM with the same dimensions with theta in the</span>
  <span class="c1"># same position as the corresponding complex terms.</span>
<div class="viewcode-block" id="DS.sparse_angles"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.sparse_angles">[docs]</a>  <span class="k">def</span> <span class="nf">sparse_angles</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">ind</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Finds the angles :math:`\\theta` which are the arguments \</span>
<span class="sd">    of the nonzero complex terms in the DSM s.</span>

<span class="sd">    :return: A DSM with the same dimensions with \</span>
<span class="sd">    :math:`\\theta` in the same \</span>
<span class="sd">     position as the corresponding complex terms.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#print(&#39;start angles&#39;)</span>
    <span class="n">t0</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">AngDSM</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
    <span class="n">t1</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)):</span>
      <span class="n">ind</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="k">pass</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">T</span>
    <span class="c1">#print(s[ind[0],ind[1],ind[2],ind[3],ind[4]]) #DEBUG</span>
    <span class="n">AngDSM</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">]])</span>
    <span class="n">t3</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;time finding angles&#39;</span><span class="p">,</span><span class="n">t3</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">AngDSM</span></div>
  <span class="c1">## Multiply every column of the DSM s elementwise with the vector vec.</span>
  <span class="c1"># @param vec a row vector with length na.</span>
  <span class="c1"># @return a DSM &#39;out&#39; with the same dimensions as s.</span>
  <span class="c1"># out[x,y,z,k,j]=vec[k]*DSM[x,y,z,k,j]</span>
<div class="viewcode-block" id="DS.dict_scal_mult"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.dict_scal_mult">[docs]</a>  <span class="k">def</span> <span class="nf">dict_scal_mult</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">scal</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;Multiply every term of the DSM s by scal.</span>

<span class="sd">    :param scal: scalar variable</span>

<span class="sd">    For integers :math:`x,y,z,k` and :math:`j` such that,</span>
<span class="sd">    :math:`x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)`,</span>

<span class="sd">    .. code::</span>

<span class="sd">       out[x,y,z,k,j]=scal*DSM[x,y,z,k,j]</span>

<span class="sd">    :rtype: DS(Nx,Ny,Nz,na,nb)</span>

<span class="sd">    :return: out</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">p</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">l</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">m</span><span class="o">=-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
      <span class="c1"># No need to go through the same grid element again.</span>
      <span class="k">if</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">p</span> <span class="ow">and</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">l</span> <span class="ow">and</span> <span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">m</span><span class="p">:</span>
        <span class="k">pass</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">l</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">m</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">out</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">]</span><span class="o">=</span><span class="n">scal</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="DS.dict_vec_multiply"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.dict_vec_multiply">[docs]</a>  <span class="k">def</span> <span class="nf">dict_vec_multiply</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">vec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Multiply every column of the DSM s elementwise with the \</span>
<span class="sd">    vector vec.</span>

<span class="sd">    :param vec: a row vector with length na.</span>

<span class="sd">    For integers :math:`x,y,z,k` and :math:`j` such that,</span>
<span class="sd">    :math:`x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)`,</span>

<span class="sd">    .. code::</span>

<span class="sd">       out[x,y,z,k,j]=vec[k]*DSM[x,y,z,k,j]</span>

<span class="sd">    Multiplication is done using \</span>
<span class="sd">    :py:class:`DS`. :py:func:`dict_vec_multiply(vec)`</span>

<span class="sd">    :rtype: A DSM &#39;out&#39; with the same dimensions as s.</span>

<span class="sd">    :returns: out</span>

<span class="sd">     &quot;&quot;&quot;</span>
    <span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">outDSM</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">Ni</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">ind</span><span class="p">)[</span><span class="mi">4</span><span class="p">])</span> <span class="c1">#FIXME find the nonzero columns without repeat column index for each term</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Ni</span><span class="p">):</span>
      <span class="c1">#out=np.multiply(vec,s[ind[l][3]],s[ind[l][0],ind[l][1],ind[l][2],ind[l][3],ind[l][4]])</span>
      <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">3</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">4</span><span class="p">]])</span>
      <span class="n">outDSM</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">4</span><span class="p">]]</span><span class="o">=</span><span class="n">out</span>
    <span class="k">return</span> <span class="n">outDSM</span></div>
  <span class="c1">## Divide every column of the DSM s elementwise with the vector vec.</span>
  <span class="c1"># @param vec a row vector with length na.</span>
  <span class="c1"># @return a DSM &#39;out&#39; with the same dimensions as s.</span>
  <span class="c1"># out[x,y,z,k,j]=DSM[x,y,z,k,j]/vec[k]</span>

<div class="viewcode-block" id="DS.dict_row_vec_multiply"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.dict_row_vec_multiply">[docs]</a>  <span class="k">def</span> <span class="nf">dict_row_vec_multiply</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">vec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Multiply every row of the DSM s elementwise with the</span>
<span class="sd">    vector vec.</span>

<span class="sd">    :param vec: a row vector with length na.</span>

<span class="sd">    For integers :math:`x,y,z,k` and :math:`j` such that,</span>
<span class="sd">    :math:`x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)`,</span>

<span class="sd">    .. code::</span>

<span class="sd">       out[x,y,z,k,j]=vec[j]*DSM[x,y,z,k,j]</span>

<span class="sd">    Multiplication is done using \</span>
<span class="sd">    :py:class:`DS`. :py:func:`dict_vec_multiply(vec)`</span>

<span class="sd">    :rtype: A DSM &#39;out&#39; with the same dimensions as s.</span>

<span class="sd">    :returns: out</span>

<span class="sd">     &quot;&quot;&quot;</span>
    <span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">outDSM</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">Ni</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">ind</span><span class="p">)[</span><span class="mi">4</span><span class="p">])</span> <span class="c1">#FIXME find the nonzero columns without repeat column index for each term</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Ni</span><span class="p">):</span>
      <span class="c1">#out=np.multiply(vec,s[ind[l][3]],s[ind[l][0],ind[l][1],ind[l][2],ind[l][3],ind[l][4]])</span>
      <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">4</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">4</span><span class="p">]])</span>
      <span class="n">outDSM</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">4</span><span class="p">]]</span><span class="o">=</span><span class="n">out</span>
    <span class="k">return</span> <span class="n">outDSM</span></div>
<div class="viewcode-block" id="DS.dict_row_vec_multiply_withind"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.dict_row_vec_multiply_withind">[docs]</a>  <span class="k">def</span> <span class="nf">dict_row_vec_multiply_withind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">vec</span><span class="p">,</span><span class="n">ind</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Multiply every row of the DSM s elementwise with the</span>
<span class="sd">    vector vec.</span>

<span class="sd">    :param vec: a row vector with length na.</span>

<span class="sd">    For integers :math:`x,y,z,k` and :math:`j` such that,</span>
<span class="sd">    :math:`x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)`,</span>

<span class="sd">    .. code::</span>

<span class="sd">       out[x,y,z,k,j]=vec[j]*DSM[x,y,z,k,j]</span>

<span class="sd">    Multiplication is done using \</span>
<span class="sd">    :py:class:`DS`. :py:func:`dict_vec_multiply(vec)`</span>

<span class="sd">    :rtype: A DSM &#39;out&#39; with the same dimensions as s.</span>

<span class="sd">    :returns: out</span>

<span class="sd">     &quot;&quot;&quot;</span>
    <span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">outDSM</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
    <span class="c1">#ind=s.nonzero()</span>
    <span class="n">Ni</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">ind</span><span class="p">)[</span><span class="mi">4</span><span class="p">])</span> <span class="c1">#FIXME find the nonzero columns without repeat column index for each term</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Ni</span><span class="p">):</span>
      <span class="c1">#out=np.multiply(vec,s[ind[l][3]],s[ind[l][0],ind[l][1],ind[l][2],ind[l][3],ind[l][4]])</span>
      <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">4</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">4</span><span class="p">]])</span>
      <span class="n">outDSM</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">4</span><span class="p">]]</span><span class="o">=</span><span class="n">out</span>
    <span class="k">return</span> <span class="n">outDSM</span></div>
  <span class="c1">## Divide every column of the DSM s elementwise with the vector vec.</span>
  <span class="c1"># @param vec a row vector with length na.</span>
  <span class="c1"># @return a DSM &#39;out&#39; with the same dimensions as s.</span>
  <span class="c1"># out[x,y,z,k,j]=DSM[x,y,z,k,j]/vec[k]</span>

<div class="viewcode-block" id="DS.dict_DSM_divideby_vec"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.dict_DSM_divideby_vec">[docs]</a>  <span class="k">def</span> <span class="nf">dict_DSM_divideby_vec</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">vec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Divide every column of the DSM s elementwise with the vector vec.</span>

<span class="sd">    :param vec: a row vector with length na.</span>

<span class="sd">    For integers :math:`x,y,z,k` and :math:`j` such that,</span>
<span class="sd">    :math:`x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)`,</span>

<span class="sd">    .. code::</span>

<span class="sd">       out[x,y,z,k,j]=DSM[x,y,z,k,j]/vec[k]</span>

<span class="sd">    :rtype: a DSM &#39;out&#39; with the same dimensions as s.</span>

<span class="sd">    :return:  out</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">outDSM</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">vec</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nb</span><span class="p">)):</span>
        <span class="n">outDSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,:,</span><span class="n">b</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,:,</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">/</span><span class="n">vec</span>
    <span class="k">return</span> <span class="n">outDSM</span></div>
<div class="viewcode-block" id="DS.dict_DSM_divideby_vec_withind"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.dict_DSM_divideby_vec_withind">[docs]</a>  <span class="k">def</span> <span class="nf">dict_DSM_divideby_vec_withind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">vec</span><span class="p">,</span><span class="n">ind</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Divide every column of the DSM s elementwise with the vector vec.</span>

<span class="sd">    :param vec: a row vector with length na.</span>

<span class="sd">    For integers :math:`x,y,z,k` and :math:`j` such that,</span>
<span class="sd">    :math:`x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)`,</span>

<span class="sd">    .. code::</span>

<span class="sd">       out[x,y,z,k,j]=DSM[x,y,z,k,j]/vec[k]</span>

<span class="sd">    :rtype: a DSM &#39;out&#39; with the same dimensions as s.</span>

<span class="sd">    :return:  out</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">outDSM</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">T</span>
    <span class="c1">#ind=np.transpose(vec.nonzero())</span>
    <span class="c1">#for x,y,z,b in product(range(0,s.Nx),range(0,s.Ny),range(0,s.Nz),range(0,nb)):</span>
    <span class="n">p</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">l</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">m</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">q</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># #a=a[0]</span>
        <span class="c1"># if abs(s[x,y,z,0,b])&lt;epsilon:</span>
        <span class="c1"># pass</span>
        <span class="c1"># else:</span>
        <span class="n">x</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">y</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">z</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">bi</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="n">p</span> <span class="ow">and</span> <span class="n">y</span><span class="o">==</span><span class="n">l</span> <span class="ow">and</span> <span class="n">z</span><span class="o">==</span><span class="n">m</span> <span class="ow">and</span> <span class="n">q</span><span class="o">==</span><span class="n">bi</span><span class="p">:</span>
          <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">outDSM</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,:,</span><span class="n">bi</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">][:,</span><span class="n">bi</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">/</span><span class="n">vec</span>
          <span class="n">q</span><span class="o">=</span><span class="n">bi</span>
          <span class="n">p</span><span class="o">=</span><span class="n">x</span>
          <span class="n">l</span><span class="o">=</span><span class="n">y</span>
          <span class="n">m</span><span class="o">=</span><span class="n">z</span>
    <span class="k">return</span> <span class="n">outDSM</span></div>

  <span class="c1">## Every column of the DSM s divides elementwise the vector vec.</span>
  <span class="c1"># @param vec a row vector with length na.</span>
  <span class="c1"># @return a DSM &#39;out&#39; with the same dimensions as s.</span>
  <span class="c1"># out[x,y,z,k,j]=vec[k]/DSM[x,y,z,k,j]</span>
<div class="viewcode-block" id="DS.costhetat"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.costhetat">[docs]</a>  <span class="k">def</span> <span class="nf">costhetat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">refindex</span><span class="p">,</span><span class="n">ind</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Takes in a Mesh of angles with nonzero terms at ind. Computes</span>
<span class="sd">    cos of thetat at those angles using the refractive index&#39;s.</span>
<span class="sd">    :param ind: The indices of the nonzero terms.</span>
<span class="sd">    :param refindex: The refractive index&#39;s of the obstacles in a vector.</span>

<span class="sd">    .. code::</span>

<span class="sd">       SIN=sin(s)</span>
<span class="sd">       thetat=asin(SIN/refindex)</span>
<span class="sd">       ctht=cos(thetat)</span>

<span class="sd">    :rtype: DSM</span>
<span class="sd">    :returns: ctht&#39;&#39;&#39;</span>
    <span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">ctht</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">T</span>
    <span class="c1">#ind=np.transpose(vec.nonzero())</span>
    <span class="c1">#for x,y,z,b in product(range(0,s.Nx),range(0,s.Ny),range(0,s.Nz),range(0,nb)):</span>
    <span class="n">p</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">l</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">m</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">q</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="c1"># #a=a[0]</span>
        <span class="c1"># if abs(s[x,y,z,0,b])&lt;epsilon:</span>
        <span class="c1"># pass</span>
        <span class="c1"># else:</span>
        <span class="n">x</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">y</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">z</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ai</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">bi</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">thetat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">][</span><span class="n">ai</span><span class="p">,</span><span class="n">bi</span><span class="p">])</span><span class="o">/</span><span class="n">refindex</span><span class="p">[</span><span class="n">ai</span><span class="p">])</span>
        <span class="n">ctht</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">ai</span><span class="p">,</span><span class="n">bi</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thetat</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ctht</span></div>
<div class="viewcode-block" id="DS.dict_col_mult_withind"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.dict_col_mult_withind">[docs]</a>  <span class="k">def</span> <span class="nf">dict_col_mult_withind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">ind</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Multiply all nonzero terms in a column.</span>

<span class="sd">    In every grid point x,y,z of s there is a sparse matrix SM. \</span>
<span class="sd">    Take the product of all nonzero terms in each column and \</span>
<span class="sd">    keep these in a vector v.</span>
<span class="sd">    Construct a new DS of size Nx x Ny x Nz x 1 x nb=s.shape[1].\</span>
<span class="sd">    Call this out. out[x,y,z] should be the v corresponding \</span>
<span class="sd">    to the SM in s at x,y,z.</span>

<span class="sd">    Method:</span>
<span class="sd">      * Find the :py:class:`DS`. :py:func:`nonzero()` indices of s.</span>
<span class="sd">      * For each nonzero x,y,z grid point find the \</span>
<span class="sd">      nonzero() indices of the SM. Do this by column so \</span>
<span class="sd">      that the output has pairs going through \</span>
<span class="sd">      each nonzero column and matching the nonzero row \</span>
<span class="sd">      number. Use function :py:func:`nonzero_bycol()`.</span>
<span class="sd">      * Go through each of these indice pairs for the SM. \</span>
<span class="sd">      Check if the column index is new. If so assign \</span>
<span class="sd">      the column in out to the matching \</span>
<span class="sd">      value in the SM. If the column number is not \</span>
<span class="sd">      new then multiply the value in the column in \</span>
<span class="sd">      out by the corresponding value in the SM.</span>

<span class="sd">    .. code::</span>

<span class="sd">       out=[</span>
<span class="sd">       [prod(nonzero terms in column 0 in s[0,0,0]),</span>
<span class="sd">       prod(nonzero terms in column 1 in s[0,0,0]),</span>
<span class="sd">       ...,</span>
<span class="sd">       prod(nonzero terms in column nb in s[0,0,0]</span>
<span class="sd">       ],</span>
<span class="sd">       ...,</span>
<span class="sd">       [prod(nonzero terms in column 0 in s[Nx-1,Ny-1,Nz-1]),</span>
<span class="sd">       prod(nonzero terms in column 1 in s[Nx-1,Ny-1,Nz-1]),</span>
<span class="sd">       ...,</span>
<span class="sd">       prod(nonzero terms in column nb in s[Nx-1,Ny-1,Nz-1]</span>
<span class="sd">       ]</span>
<span class="sd">       ]</span>

<span class="sd">    :rtype: DS of size Nx x Ny x Nz x 1 x nb</span>

<span class="sd">    :return: out</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1">#ind=s.nonzero()</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">p</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">l</span><span class="o">=-</span><span class="mi">1</span>
    <span class="n">m</span><span class="o">=-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
      <span class="c1"># No need to go through the same grid element again.</span>
      <span class="k">if</span> <span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">p</span> <span class="ow">and</span> <span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">l</span> <span class="ow">and</span> <span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">m</span><span class="p">:</span>
        <span class="k">pass</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">l</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">m</span><span class="o">=</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
        <span class="n">ind2</span><span class="o">=</span><span class="n">nonzero_bycol</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">])</span>
        <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">chk</span><span class="o">=-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ind2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
          <span class="k">if</span> <span class="n">chk</span><span class="o">==</span><span class="n">j</span><span class="p">:</span>
            <span class="n">col</span><span class="o">=</span><span class="n">col</span><span class="o">*</span><span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">ind2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">count</span><span class="p">],</span><span class="n">j</span><span class="p">]</span>
            <span class="n">out</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">ind2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">count</span><span class="p">]]</span><span class="o">=</span><span class="n">col</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="n">col</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="n">ind2</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">count</span><span class="p">],</span><span class="n">j</span><span class="p">]</span>
            <span class="n">out</span><span class="p">[</span><span class="n">p</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">ind2</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">count</span><span class="p">]]</span><span class="o">=</span><span class="n">col</span>
            <span class="n">chk</span><span class="o">=</span><span class="n">j</span>
          <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">out</span></div>
<div class="viewcode-block" id="DS.dict_vec_divideby_DSM"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.dict_vec_divideby_DSM">[docs]</a>  <span class="k">def</span> <span class="nf">dict_vec_divideby_DSM</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">vec</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Every column of the DSM s divides elementwise the vector vec.</span>

<span class="sd">    :param vec: a row vector with length na.</span>

<span class="sd">    For integers :math:`x,y,z,k` and :math:`j` such that,</span>
<span class="sd">    :math:`x \in [0,Nx), y \in [0,Ny), z \in [0,Nz), k \in [0,na),j \in [0,nb)`,</span>

<span class="sd">    .. code::</span>

<span class="sd">       out[x,y,z,k,j]=vec[k]/DSM[x,y,z,k,j]</span>

<span class="sd">    :rtype: a DSM &#39;out&#39; with the same dimensions as s.</span>

<span class="sd">    :return: out</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">outDSM</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
    <span class="n">indices</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">Ni</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Ni</span><span class="p">):</span>
      <span class="n">out</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">vec</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">3</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">4</span><span class="p">]])</span>
      <span class="n">outDSM</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span><span class="n">indices</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="mi">4</span><span class="p">]]</span><span class="o">=</span><span class="n">out</span>
    <span class="k">return</span> <span class="n">outDSM</span></div>
  <span class="c1">## Save the DSM s.</span>
  <span class="c1"># @param filename_ the name of the file to save to.</span>
  <span class="c1"># @return nothing</span>
<div class="viewcode-block" id="DS.save_dict"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.save_dict">[docs]</a>  <span class="k">def</span> <span class="nf">save_dict</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">filename_</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Save the DSM s.</span>

<span class="sd">    :param filename_: the name of the file to save to.</span>

<span class="sd">    :return: nothing</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pkl</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
    <span class="k">return</span></div>
  <span class="c1">## Find the indices of the nonzero terms in the DSM s.</span>
  <span class="c1"># The indices are found by iterating through all keys (x,y,z) for the</span>
  <span class="c1"># DSM s and finding the nonzero indices of the corresponding sparse</span>
  <span class="c1"># matrix. These indices are then combinded with the x,y,z key and</span>
  <span class="c1"># stacked to create an 5xN array of all the nonzero terms in the DSM,</span>
  <span class="c1"># where N is the number of nonzero terms.</span>
  <span class="c1"># @return indices=[ [x1,y1,z1,k1,j1],...,[xn,yn,zn,kn,jn]]</span>
<div class="viewcode-block" id="DS.nonzero"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.nonzero">[docs]</a>  <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find the indices of the nonzero terms in the DSM s.</span>

<span class="sd">      .. note::</span>

<span class="sd">          The indices are found by iterating through all \</span>
<span class="sd">          keys (x,y,z) for the DSM s and finding the nonzero \</span>
<span class="sd">          indices of the corresponding sparse matrix. \</span>
<span class="sd">          These indices are then combinded \</span>
<span class="sd">          with the x,y,z key and stacked to create a 5xN \</span>
<span class="sd">          array of all the nonzero terms in the DSM, \</span>
<span class="sd">          where N is the number of nonzero \</span>
<span class="sd">          terms.</span>

<span class="sd">    :return: indices=[ [x1,y1,z1,k1,j1],...,[xn,yn,zn,kn,jn]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># FIXME this is too slow and needs parallelising / speeding up.</span>
    <span class="n">check</span><span class="o">=-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">)):</span>
      <span class="n">indicesM</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
      <span class="n">NI</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">indicesM</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">NI</span><span class="p">)</span><span class="o">&lt;</span><span class="n">epsilon</span><span class="p">:</span>
        <span class="k">pass</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">check</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
          <span class="n">check</span><span class="o">=</span><span class="mi">0</span>
          <span class="n">indices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">indicesM</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">indicesM</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
          <span class="n">indicesSec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]),(</span><span class="n">NI</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span><span class="n">indicesM</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="n">indicesM</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span>
          <span class="n">indices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">indices</span><span class="p">,</span><span class="n">indicesSec</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">indicesSec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]),(</span><span class="n">NI</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span><span class="n">indicesM</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:],</span><span class="n">indicesM</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:]]</span>
          <span class="n">indices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">indices</span><span class="p">,</span><span class="n">indicesSec</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">check</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
      <span class="n">indices</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="k">return</span> <span class="n">indices</span></div>
<div class="viewcode-block" id="DS.row_sum"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.row_sum">[docs]</a>  <span class="k">def</span> <span class="nf">row_sum</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Sum all nonzero terms in a row.</span>

<span class="sd">    In every grid point x,y,z of s there is a sparse matrix SM.</span>
<span class="sd">    Construct a new DS of size Nx x Ny x Nz x na=s.shape[0] x 1.</span>
<span class="sd">    Call this out.</span>
<span class="sd">    out[x,y,z] should be the corresponding na x1 SM to the SM in s at x,y,z.</span>

<span class="sd">    Method:</span>
<span class="sd">      * Find the :py:class:`DS`. :py:func:`nonzero()` indices of s`</span>
<span class="sd">      * Go through each of these indice. Check if the \</span>
<span class="sd">      row index is new. If so assign the row in out to the matching \</span>
<span class="sd">      value in the SM. If the row number is not new then sum the \</span>
<span class="sd">      value in the column in out by the corresponding value in the SM.</span>

<span class="sd">    .. code::</span>

<span class="sd">       out=[</span>
<span class="sd">       [sum(nonzero terms in row 0 in s[0,0,0]),</span>
<span class="sd">       sum(nonzero terms in row 1 in s[0,0,0]),</span>
<span class="sd">       ...,</span>
<span class="sd">       sum(nonzero terms in row na in s[0,0,0]</span>
<span class="sd">       ],</span>
<span class="sd">       ...,</span>
<span class="sd">       [sum(nonzero terms in row 0 in s[Nx-1,Ny-1,Nz-1]),</span>
<span class="sd">       sum(nonzero terms in row 1 in s[Nx-1,Ny-1,Nz-1]),</span>
<span class="sd">       ...,</span>
<span class="sd">       sum(nonzero terms in row na in s[Nx-1,Ny-1,Nz-1]</span>
<span class="sd">       ]</span>
<span class="sd">       ]</span>

<span class="sd">    :rtype: DS of size Nx x Ny x Nz x na x  1</span>

<span class="sd">    :return: out</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
      <span class="n">out</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">out</span></div>
<div class="viewcode-block" id="DS.row_sum_withind"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.row_sum_withind">[docs]</a>  <span class="k">def</span> <span class="nf">row_sum_withind</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">ind</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39; Sum all nonzero terms in a row.</span>

<span class="sd">    In every grid point x,y,z of s there is a sparse matrix SM.</span>
<span class="sd">    Construct a new DS of size Nx x Ny x Nz x na=s.shape[0] x 1.</span>
<span class="sd">    Call this out.</span>
<span class="sd">    out[x,y,z] should be the corresponding na x1 SM to the SM in s at x,y,z.</span>

<span class="sd">    Method:</span>
<span class="sd">      * Find the :py:class:`DS`. :py:func:`nonzero()` indices of s`</span>
<span class="sd">      * Go through each of these indice. Check if the \</span>
<span class="sd">      row index is new. If so assign the row in out to the matching \</span>
<span class="sd">      value in the SM. If the row number is not new then sum the \</span>
<span class="sd">      value in the column in out by the corresponding value in the SM.</span>

<span class="sd">    .. code::</span>

<span class="sd">       out=[</span>
<span class="sd">       [sum(nonzero terms in row 0 in s[0,0,0]),</span>
<span class="sd">       sum(nonzero terms in row 1 in s[0,0,0]),</span>
<span class="sd">       ...,</span>
<span class="sd">       sum(nonzero terms in row na in s[0,0,0]</span>
<span class="sd">       ],</span>
<span class="sd">       ...,</span>
<span class="sd">       [sum(nonzero terms in row 0 in s[Nx-1,Ny-1,Nz-1]),</span>
<span class="sd">       sum(nonzero terms in row 1 in s[Nx-1,Ny-1,Nz-1]),</span>
<span class="sd">       ...,</span>
<span class="sd">       sum(nonzero terms in row na in s[Nx-1,Ny-1,Nz-1]</span>
<span class="sd">       ]</span>
<span class="sd">       ]</span>

<span class="sd">    :rtype: DS of size Nx x Ny x Nz x na x  1</span>

<span class="sd">    :return: out</span>

<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1">#ind=s.nonzero()</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">ind</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
    <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
      <span class="n">out</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="n">s</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">4</span><span class="p">][</span><span class="n">i</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">out</span></div>
  <span class="c1">## Find the indices of the nonzero terms for part of the DSM s.</span>
  <span class="c1"># @param s the part of s that you want the nonzero indices for.</span>
  <span class="c1"># .</span>
  <span class="c1"># \par</span>
  <span class="c1"># The indices are found by using the nonzero() function on s[cor]</span>
  <span class="c1"># @return indices=[ [x1,y1,z1,k1,j1],...,[xn,yn,zn,kn,jn]]</span>
<div class="viewcode-block" id="DS.nonzeroMat"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.nonzeroMat">[docs]</a>  <span class="k">def</span> <span class="nf">nonzeroMat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">cor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find the indices of the nonzero terms for part of the DSM s.</span>

<span class="sd">    :param cor: the part of s that you want the nonzero indices for.</span>

<span class="sd">    The indices are found by using the :py:func:`nonzero()` function on s[cor]</span>

<span class="sd">    :return: indices=[ [x1,y1,z1,k1,j1],...,[xn,yn,zn,kn,jn]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cor</span><span class="p">,(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)):</span>
      <span class="n">ns</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">ns</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">cor</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ns</span><span class="p">):</span>
      <span class="n">indM</span><span class="o">=</span><span class="n">s</span><span class="p">[</span><span class="n">cor</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">cor</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">cor</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
      <span class="n">NI</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">indM</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
      <span class="k">if</span> <span class="n">j</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="n">cor</span><span class="p">,</span><span class="n">indM</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span><span class="n">indM</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">cor</span><span class="p">,(</span><span class="n">NI</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span><span class="n">indM</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="n">indM</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">indt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">cor</span><span class="p">,(</span><span class="n">NI</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span><span class="n">indM</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">:],</span><span class="n">indM</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">:]]</span>
        <span class="n">ind</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">ind</span><span class="p">,</span><span class="n">indt</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">ind</span></div>
  <span class="c1">## Fills the DSM s.</span>
  <span class="c1"># @return a dense Nx*Ny*Nz*na*nb array with matching nonzero terms to</span>
  <span class="c1"># the sparse matrix s and zeroes elsewhere.</span>
<div class="viewcode-block" id="DS.dense"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.dense">[docs]</a>  <span class="k">def</span> <span class="nf">dense</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Fills the DSM s.</span>

<span class="sd">    :returns: A dense Nx x Ny x Nz x na x nb array with matching nonzero terms to \</span>
<span class="sd">     the sparse matrix s and zeroes elsewhere.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="p">(</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">Nx</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span>
    <span class="n">Ny</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span>
    <span class="n">Nz</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span>
    <span class="n">den</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span><span class="p">)):</span>
      <span class="n">den</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">d</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]</span><span class="o">.</span><span class="n">todense</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">den</span></div>
  <span class="c1">## Check if the index [i,j,k] is valid.</span>
  <span class="c1"># @param i is the index for the x axis.</span>
  <span class="c1"># @param j is the index for the y axis.</span>
  <span class="c1"># @param k is the index for the z axis.</span>
  <span class="c1"># @param p1 is the point at the end of the ray.</span>
  <span class="c1"># @param h is the mesh width</span>
  <span class="c1"># @return 0 if valid, 1 if not.</span>
<div class="viewcode-block" id="DS.stopcheck"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.stopcheck">[docs]</a>  <span class="k">def</span> <span class="nf">stopcheck</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="n">h</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Check if the index [i,j,k] is valid.</span>

<span class="sd">    :param i: is the index for the x axis.</span>

<span class="sd">    :param j: is the index for the y axis.</span>

<span class="sd">    :param k: is the index for the z axis.</span>

<span class="sd">    :param p1: is the point at the end of the ray.</span>

<span class="sd">    :param h: is the mesh width</span>

<span class="sd">    :return: 1 if valid, 0 if not.</span>

<span class="sd">    .. todo:: add the inside check to this function</span>

<span class="sd">    .. todo:: add the check for the end of the ray.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#FIXME add the inside check to this function</span>
    <span class="c1">#FIXME add the check for the end of the ray.</span>
    <span class="c1">#if i&gt;=p1[0] and j&gt;=p1[1] and k&gt;=p1[2]:</span>
    <span class="c1">#  return 0</span>
    <span class="k">if</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">s</span><span class="o">.</span><span class="n">Nx</span> <span class="ow">or</span> <span class="n">j</span><span class="o">&gt;</span><span class="n">s</span><span class="o">.</span><span class="n">Ny</span> <span class="ow">or</span> <span class="n">k</span><span class="o">&gt;</span><span class="n">s</span><span class="o">.</span><span class="n">Nz</span> <span class="ow">or</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span><span class="o">&lt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">k</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="mi">1</span></div>
  <span class="c1">## Check if the list of points is valid.</span>
  <span class="c1"># @param ps the indices for the points in the list</span>
  <span class="c1"># @param p1 the end of the ray</span>
  <span class="c1"># @param h the meshwidth</span>
  <span class="c1"># @param p3 the points on the cone vectors</span>
  <span class="c1"># @param the normal vectors forming the cone.</span>
  <span class="c1"># @return start=0 if no points were valid if at least 1 point was</span>
  <span class="c1"># valid, ps=[[i1,j1,k1],...,[in,jn,kn]] the indices of the</span>
  <span class="c1"># valid points, p3=[[x1,y1,z1],...,[xn,yn,zn]] co-ordinates of</span>
  <span class="c1"># the valid points., N=[n0,...,Nn] the normal vectors corresponding to</span>
  <span class="c1"># the valid points.</span>
<div class="viewcode-block" id="DS.stopchecklist"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.DS.stopchecklist">[docs]</a>  <span class="k">def</span> <span class="nf">stopchecklist</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">ps</span><span class="p">,</span><span class="n">p1</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">p3</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Check if the list of points is valid.</span>

<span class="sd">    :param ps: the indices for the points in the list</span>

<span class="sd">    :param p1: the end of the ray</span>

<span class="sd">    :param h: the meshwidth</span>

<span class="sd">    :param p3: the points on the cone vectors</span>

<span class="sd">    :param n: the normal vectors forming the cone.</span>

<span class="sd">    start=0 if no points were valid if at least 1 point was valid,</span>
<span class="sd">    ps=[[i1,j1,k1],...,[in,jn,kn]] the indices of the valid points,</span>
<span class="sd">    p3=[[x1,y1,z1],...,[xn,yn,zn]] co-ordinates of the valid points,</span>
<span class="sd">    N=[n0,...,nN] the normal vectors corresponding to the valid points.</span>

<span class="sd">    :return: start, ps, p3, N</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">start</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">newps</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">newp3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">newn</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
    <span class="n">j</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ps</span><span class="p">:</span>
      <span class="n">check</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">stopcheck</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">p1</span><span class="p">,</span><span class="n">h</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">check</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">start</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
          <span class="n">newps</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]],[</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]]])</span>
          <span class="n">newp3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p3</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]],[</span><span class="n">p3</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]],[</span><span class="n">p3</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]]])</span>
          <span class="n">newn</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]]])</span>
          <span class="n">start</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="n">newps</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">newps</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]],[</span><span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">]],[</span><span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">]]])))</span>
          <span class="n">newp3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">newp3</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">p3</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]],[</span><span class="n">p3</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]],[</span><span class="n">p3</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]]])))</span>
          <span class="n">newn</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">newn</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]],</span> <span class="p">[</span><span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span> <span class="n">n</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">2</span><span class="p">]]])))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
      <span class="n">j</span><span class="o">+=</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">newps</span><span class="p">,</span> <span class="n">newp3</span><span class="p">,</span> <span class="n">newn</span></div></div>

<div class="viewcode-block" id="phase_calc"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.phase_calc">[docs]</a><span class="k">def</span> <span class="nf">phase_calc</span><span class="p">(</span><span class="n">RadMesh</span><span class="p">,</span><span class="n">khat</span><span class="p">,</span><span class="n">L</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39; Compute :math:`\\exp(i\frac{\hat{k}\hat{r}}{L^2})` \</span>
<span class="sd">  for a Mesh of :math:`r`</span>

<span class="sd">  The phase is usually expressed at :math:`exp(ikr)`.</span>
<span class="sd">  Since :math:`\hat{k}` and :math:`\hat{r}` are nondimensional lengths \</span>
<span class="sd">  scaled by the room length L the power of :math:`L^{-2}` must be used.</span>

<span class="sd">  Exponentials are not defined on DS, instead use \</span>
<span class="sd">  :math:`\\exp(i \theta)=\\cos(\theta)+i\\sin(\theta)`.</span>

<span class="sd">  .. code::</span>

<span class="sd">     S1=RadMesh.dict_scal_mult(khat)</span>
<span class="sd">     S2=S1.dict_scal_mult(1.0/(L**2))</span>
<span class="sd">     out=S1.cos()+S1.sin().dict_scal_mult(1j)</span>

<span class="sd">  :rtype: DS of size Nx x Ny x Nz x na x 1</span>

<span class="sd">  :return: out</span>

<span class="sd">  &#39;&#39;&#39;</span>

  <span class="n">S1</span><span class="o">=</span><span class="n">RadMesh</span><span class="o">.</span><span class="n">dict_scal_mult</span><span class="p">(</span><span class="n">khat</span><span class="p">)</span>
  <span class="n">S2</span><span class="o">=</span><span class="n">S1</span><span class="o">.</span><span class="n">dict_scal_mult</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
  <span class="n">out</span><span class="o">=</span><span class="n">S1</span><span class="o">.</span><span class="n">cos</span><span class="p">()</span><span class="o">+</span><span class="n">S1</span><span class="o">.</span><span class="n">sin</span><span class="p">()</span><span class="o">.</span><span class="n">dict_scal_mult</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="power_compute"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.power_compute">[docs]</a><span class="k">def</span> <span class="nf">power_compute</span><span class="p">(</span><span class="n">Mesh</span><span class="p">,</span><span class="n">Grid</span><span class="p">,</span><span class="n">Znobrat</span><span class="p">,</span><span class="n">refindex</span><span class="p">,</span><span class="n">Antpar</span><span class="p">,</span><span class="n">Gt</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39; Compute the field from a Mesh of ray information and the physical \</span>
<span class="sd">  parameters.</span>

<span class="sd">  :param Mesh: The :py:class:`DS` mesh of ray information.</span>
<span class="sd">  :param Znobrat: An Nob x Nre+1 array containing tiles of the impedance \</span>
<span class="sd">    of obstacles divided by the impedance of air.</span>
<span class="sd">  :param refindex: An Nob x Nre+1 array containing tiles of the refractive\</span>
<span class="sd">    index of obstacles.</span>

<span class="sd">  Method:</span>

<span class="sd">    * First compute the reflection coefficients using \</span>
<span class="sd">    :py:func:`ref_coef(Mesh,Znobrat,refindex)`</span>
<span class="sd">    * Combine the reflection coefficients that correspond to the same \</span>
<span class="sd">    ray using :py:class:`DS`. :py:func:`dict_col_mult()`. This \</span>
<span class="sd">    multiplies reflection coefficients in the same column.</span>
<span class="sd">    * Extract the distance each ray had travelled using \</span>
<span class="sd">    :py:class:`DS`. :py:func:`__get_rad__()`</span>
<span class="sd">    * Multiply by the gains for the corresponding ray.</span>
<span class="sd">    * Multiply terms by the phases \</span>
<span class="sd">    :math:`\\exp(i\hat{k} \hat{r})^{L^{-2}}`. With :math:`L` being \</span>
<span class="sd">    the room length scale. :math:`\hat{r}` being the relative distance \</span>
<span class="sd">    travelled which is the actual distance divided by the room length \</span>
<span class="sd">    scale, and :math:`\hat{k}` is the relative wavenumber which is the \</span>
<span class="sd">    actual wavenumber times the room length scale.</span>
<span class="sd">    * Multiply by the gains corresponding to each ray.</span>
<span class="sd">    * Divide by the distance corresponding to each ray segment.</span>
<span class="sd">    * Sum all the ray segments in a grid point.</span>
<span class="sd">    * Multiply the grid by the transmitted field times the wavelngth \</span>
<span class="sd">    divided by the room length scale. :math:`\\frac{\\lambda}{L 4 \pi}`</span>
<span class="sd">    * Multiply by initial polarisation vectors and combine.</span>
<span class="sd">    * Ignore dividing by initial phi as when converting to power in db \</span>
<span class="sd">    this disappears.</span>
<span class="sd">    * Take the amplitude and square.</span>
<span class="sd">    * Take :math:`10log10()` to get the db Power.</span>

<span class="sd">  :rtype: Nx x Ny x Nz numpy array of real values.</span>

<span class="sd">  :return: Grid</span>

<span class="sd">  &#39;&#39;&#39;</span>
  <span class="n">t0</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Start computing the power from the Mesh&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="c1"># Retrieve the parameters</span>
  <span class="n">khat</span><span class="p">,</span><span class="n">lam</span><span class="p">,</span><span class="n">L</span> <span class="o">=</span> <span class="n">Antpar</span>
  <span class="c1"># Compute the reflection coefficients</span>
  <span class="n">Rper</span><span class="p">,</span> <span class="n">Rpar</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="n">ref_coef</span><span class="p">(</span><span class="n">Mesh</span><span class="p">,</span><span class="n">Znobrat</span><span class="p">,</span><span class="n">refindex</span><span class="p">)</span>

  <span class="c1"># Combine the reflection coefficients to get the reflection loss on each ray.</span>
  <span class="n">t1</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Multiplying reflection coefficients &#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="n">Comper</span><span class="o">=</span><span class="n">Rper</span><span class="o">.</span><span class="n">dict_col_mult_withind</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="c1"># with ind</span>
  <span class="c1">#print(&#39;Ref after mult equal check&#39;,Comper.__self_eq__()) #DEBUG</span>
  <span class="n">Compar</span><span class="o">=</span><span class="n">Rpar</span><span class="o">.</span><span class="n">dict_col_mult_withind</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="c1"># with ind</span>
  <span class="n">t2</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reflection coefficients multiplied, time taken &#39;</span><span class="p">,</span> <span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="c1"># Get the distances for each ray segment from the Mesh</span>
  <span class="n">RadMesh</span><span class="o">=</span><span class="n">Mesh</span><span class="o">.</span><span class="n">__get_rad__withind__</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
  <span class="c1">#FIXME get ind from Mesh nonzeros to the rad versions. So SMs no longer have rows.</span>
  <span class="c1"># Compute the mesh of phases</span>
  <span class="n">ind</span><span class="o">=</span><span class="n">RadMesh</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
  <span class="n">pha</span><span class="o">=</span><span class="n">phase_calc</span><span class="p">(</span><span class="n">RadMesh</span><span class="p">,</span><span class="n">khat</span><span class="p">,</span><span class="n">L</span><span class="p">)</span>
  <span class="c1"># Divide by the rads</span>
  <span class="n">pharad</span><span class="o">=</span><span class="n">pha</span><span class="o">.</span><span class="n">truediv_withind</span><span class="p">(</span><span class="n">RadMesh</span><span class="p">,</span><span class="n">ind</span><span class="p">)</span>
  <span class="c1"># Multiply by the gains.</span>
  <span class="n">Gtpha</span><span class="o">=</span><span class="n">pharad</span><span class="o">.</span><span class="n">dict_row_vec_multiply_withind</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Gt</span><span class="p">),</span><span class="n">ind</span><span class="p">)</span>
  <span class="c1"># Combine Gains, phase and reflection</span>
  <span class="n">GtphaRpe</span><span class="o">=</span><span class="n">Gtpha</span><span class="o">.</span><span class="n">mul_withind</span><span class="p">(</span><span class="n">Comper</span><span class="p">,</span><span class="n">ind</span><span class="p">)</span>
  <span class="n">GtphaRpa</span><span class="o">=</span><span class="n">Gtpha</span><span class="o">.</span><span class="n">mul_withind</span><span class="p">(</span><span class="n">Compar</span><span class="p">,</span><span class="n">ind</span><span class="p">)</span>
  <span class="c1"># Sum cols</span>
  <span class="n">Grid0pe</span><span class="o">=</span><span class="n">GtphaRpe</span><span class="o">.</span><span class="n">row_sum_withind</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
  <span class="n">Grid0pa</span><span class="o">=</span><span class="n">GtphaRpa</span><span class="o">.</span><span class="n">row_sum_withind</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
  <span class="c1"># Turn into numpy array</span>
  <span class="n">Gridpe</span><span class="o">=</span><span class="n">Grid0pe</span><span class="o">.</span><span class="n">togrid</span><span class="p">()</span> <span class="c1"># with ind</span>
  <span class="n">Gridpa</span><span class="o">=</span><span class="n">Grid0pa</span><span class="o">.</span><span class="n">togrid</span><span class="p">()</span> <span class="c1"># with ind</span>
  <span class="c1"># Multiply by the lambda\L</span>
  <span class="n">Gridpe</span><span class="o">=</span><span class="n">Gridpe</span><span class="o">*</span><span class="p">(</span><span class="n">lam</span><span class="o">*</span><span class="n">L</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
  <span class="n">Gridpa</span><span class="o">=</span><span class="n">Gridpa</span><span class="o">*</span><span class="p">(</span><span class="n">lam</span><span class="o">*</span><span class="n">L</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
  <span class="c1"># FIXME polarisation dummy</span>
  <span class="n">aper</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
  <span class="n">apar</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
  <span class="c1"># Power</span>
  <span class="n">P</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">Gridpe</span><span class="p">),</span><span class="mi">2</span><span class="p">)</span>
  <span class="n">P</span><span class="o">=</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
  <span class="c1">#P.filled(None)</span>
  <span class="k">return</span> <span class="n">P</span></div>

<div class="viewcode-block" id="nonzero_bycol"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.nonzero_bycol">[docs]</a><span class="k">def</span> <span class="nf">nonzero_bycol</span><span class="p">(</span><span class="n">SM</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39; Find the index pairs for the nonzero terms in a sparse matrix.</span>
<span class="sd">  Go through each column and find the nonzero rows.</span>

<span class="sd">  :param SM: sparse matrix.</span>

<span class="sd">  :return: [[i(0j0),i(1j0),...,i(nj0),...,i(njn)],\</span>
<span class="sd">    [j0,...,j0,...,jn,...,jn]]</span>
<span class="sd">  &#39;&#39;&#39;</span>
  <span class="n">S2</span><span class="o">=</span><span class="n">SM</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
  <span class="n">inddum</span><span class="o">=</span><span class="n">S2</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
  <span class="n">ind</span><span class="o">=</span><span class="p">[</span><span class="n">inddum</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">inddum</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
  <span class="k">return</span> <span class="n">ind</span></div>

<span class="c1">#=======================================================================</span>
<span class="c1"># FUNCTIONS CONNECTED TO DS BUT AREN&#39;T PART OF THE OBJECT</span>
<span class="c1">#=======================================================================</span>

<span class="k">def</span> <span class="nf">singletype</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
  <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,(</span><span class="nb">float</span><span class="p">,</span><span class="nb">int</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span> <span class="p">)):</span>
    <span class="k">return</span> <span class="kc">True</span>
  <span class="k">else</span><span class="p">:</span> <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="load_dict"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.load_dict">[docs]</a><span class="k">def</span> <span class="nf">load_dict</span><span class="p">(</span><span class="n">filename_</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39; Load a DS as a dictionary and construct the DS again.</span>

<span class="sd">  :param filename_: the name of the DS saved</span>

<span class="sd">  .. code::</span>

<span class="sd">     Nx=max(Keys[0])-min(Keys[0])</span>
<span class="sd">     Ny=max(Keys[1])-min(Keys[1])</span>
<span class="sd">     Nz=max(Keys[2])-min(Keys[2])</span>

<span class="sd">  :returns: nothing</span>

<span class="sd">  &#39;&#39;&#39;</span>
  <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename_</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">ret_di</span> <span class="o">=</span> <span class="n">pkl</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
  <span class="n">Keys</span><span class="o">=</span><span class="n">ret_di</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
  <span class="n">Nx</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">Keys</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">Keys</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">Ny</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">Keys</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">Keys</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">Nz</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">Keys</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">Keys</span><span class="p">)[</span><span class="mi">2</span><span class="p">]</span>
  <span class="n">na</span><span class="o">=</span><span class="n">ret_di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">nb</span><span class="o">=</span><span class="n">ret_di</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
  <span class="n">ret_ds</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
  <span class="n">default_value</span><span class="o">=</span><span class="n">SM</span><span class="p">((</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">Keys</span><span class="p">:</span>
    <span class="n">ret_ds</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">ret_di</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
  <span class="k">return</span> <span class="n">ret_ds</span></div>

<div class="viewcode-block" id="ref_coef"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.ref_coef">[docs]</a><span class="k">def</span> <span class="nf">ref_coef</span><span class="p">(</span><span class="n">Mesh</span><span class="p">,</span><span class="n">Znobrat</span><span class="p">,</span><span class="n">refindex</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39; Find the reflection coefficients.</span>

<span class="sd">  :param Mesh: The DS mesh which contains terms re^(itheta) with theta \</span>
<span class="sd">  the reflection angle of incidence.</span>

<span class="sd">  Method:</span>

<span class="sd">    * Gets the mesh of angles using :py:class:`DS`. :py:func:`sparse_angles()`</span>
<span class="sd">    * Gets the indices of the nonzero terms using :py:class:`DS`. :py:func:`nonzero()`</span>
<span class="sd">    * Initialise sin(thetai), cos(thetai) and cos(thetat) meshes.</span>
<span class="sd">    * Compute cos(thetai),sin(thetai), cos(thetat)</span>

<span class="sd">    .. code::</span>

<span class="sd">      cthi=AngDSM.cos()</span>
<span class="sd">      SIN=AngDSM.sin()</span>
<span class="sd">      Div=SIN.dict_DSM_divideby_vec(refindex)</span>
<span class="sd">      ctht=Div.asin().cos()</span>

<span class="sd">    * Compute the reflection coefficients.</span>

<span class="sd">    .. code::</span>

<span class="sd">       S1=(cthi).dict_vec_multiply(Znobrat)</span>
<span class="sd">       S2=(ctht).dict_vec_multiply(Znobrat)</span>
<span class="sd">       Rper=(S1-ctht)/(S1+ctht)</span>
<span class="sd">       Rpar=(cthi-S2)/(cthi+S2)</span>

<span class="sd">  :rtype: Rper=DS(Nx,Ny,Nz,na,nb),Rpar=DS(Nx,Ny,Nz,na,nb)</span>

<span class="sd">  :returns: Rper, Rpar</span>

<span class="sd">  &#39;&#39;&#39;</span>
  <span class="c1"># FIXME rewrite this whole section so loops aren&#39;t repeated.</span>
  <span class="n">t0</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Retrieving the angles of reflection&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Getting nonzero indices&#39;</span><span class="p">)</span>
  <span class="n">ind</span><span class="o">=</span><span class="n">Mesh</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Make DS for angles&#39;</span><span class="p">)</span>
  <span class="n">AngDSM</span><span class="o">=</span><span class="n">Mesh</span><span class="o">.</span><span class="n">sparse_angles</span><span class="p">()</span>                       <span class="c1"># Get the angles of incidence from the mesh.</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Initialising cthi, ctht, SIN&#39;</span><span class="p">)</span>
  <span class="n">SIN</span> <span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>   <span class="c1"># Initialise a DSM which will be sin(theta)</span>
  <span class="n">cthi</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Initialise a DSM which will be cos(theta)</span>
  <span class="n">ctht</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Initialise a DSM which will be cos(theta_t) #FIXME</span>
  <span class="c1"># #FIXME this section is far too slow and needs speeding up.</span>
  <span class="c1"># print(&#39;----------------------------------------------------------&#39;)</span>
  <span class="c1"># print(&#39;Computing cos(theta_i) on all reflection terms&#39;)</span>
  <span class="c1"># print(&#39;----------------------------------------------------------&#39;)</span>
  <span class="n">cthi</span><span class="o">=</span><span class="n">AngDSM</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>                                   <span class="c1"># Compute cos(theta_i)</span>
  <span class="c1"># t1=t.time()</span>
  <span class="c1"># print(&#39;----------------------------------------------------------&#39;)</span>
  <span class="c1"># print(&#39;cos(theta_i) found time taken &#39;, t1-t0)</span>
  <span class="c1"># print(&#39;----------------------------------------------------------&#39;)</span>
  <span class="c1"># print(&#39;----------------------------------------------------------&#39;)</span>
  <span class="c1"># print(&#39;Computing cos(theta_t) on all reflection terms&#39;)</span>
  <span class="c1"># print(&#39;----------------------------------------------------------&#39;)</span>
  <span class="c1"># #SIN[ind[0],ind[1],ind[2],ind[3],ind[4]]=np.sin(AngDSM[ind[0],ind[1],ind[2],ind[3],ind[4]]) # Compute sin(theta)</span>
  <span class="c1"># #ctht[ind[0],ind[1],ind[2],ind[3],ind[4]]=np.cos(np.arcsin(Div[ind[0],ind[1],ind[2],ind[3],ind[4]]))</span>
  <span class="c1"># SIN=AngDSM.sin(ind)</span>
  <span class="c1"># t2=t.time()</span>
  <span class="c1"># print(&#39;Time to get sin of angles&#39;,t2-t1)</span>
  <span class="c1"># # FIXME I think it is this step slowing things down.</span>
  <span class="c1"># # FIXME this is sin and ref seperate. do both together?</span>
  <span class="c1"># # FIXME Use matrix division with tesselated vector rather than iterating?</span>
  <span class="c1"># # FIXME write function for cos(thetat) so non of this iteration is repeated.</span>
  <span class="c1"># # ctht=AngDSM.costhetat(refindex,ind)</span>
  <span class="c1"># Div=SIN.dict_DSM_divideby_vec_withind(refindex,ind)             # Divide each column in DSM with refindex elementwise. Set any 0 term to 0.</span>
  <span class="c1"># t3=t.time()</span>
  <span class="c1"># print(&#39;Time to divide by refindex&#39;, t3-t2)</span>
  <span class="c1"># ctht=Div.cos_asin(ind)</span>
  <span class="n">t4</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
  <span class="c1"># print(&#39;Time to do cos arcsin&#39;,t4-t3)</span>
  <span class="c1"># del t3, t2</span>
  <span class="c1"># print(&#39;----------------------------------------------------------&#39;)</span>
  <span class="c1"># print(&#39;cos(theta_t) found time taken &#39;, t4-t1)</span>
  <span class="c1"># del t1</span>
  <span class="c1"># print(&#39;Finding cos(theta_t) with other function&#39;)</span>
  <span class="n">ctht</span><span class="o">=</span><span class="n">AngDSM</span><span class="o">.</span><span class="n">costhetat</span><span class="p">(</span><span class="n">refindex</span><span class="p">,</span><span class="n">ind</span><span class="p">)</span>
  <span class="n">t2</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;New function finished&#39;</span><span class="p">,</span><span class="n">t2</span><span class="o">-</span><span class="n">t4</span><span class="p">)</span>
  <span class="n">t4</span><span class="o">=</span><span class="n">t2</span>
  <span class="k">del</span> <span class="n">t2</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Multiplying by the impedances&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="n">S1</span><span class="o">=</span><span class="p">(</span><span class="n">cthi</span><span class="p">)</span><span class="o">.</span><span class="n">dict_vec_multiply</span><span class="p">(</span><span class="n">Znobrat</span><span class="p">)</span>                <span class="c1"># Compute S1=Znob*cos(theta_i)</span>
  <span class="n">S2</span><span class="o">=</span><span class="p">(</span><span class="n">ctht</span><span class="p">)</span><span class="o">.</span><span class="n">dict_vec_multiply</span><span class="p">(</span><span class="n">Znobrat</span><span class="p">)</span>                <span class="c1"># Compute S2=Znob*cos(theta_t)</span>
  <span class="n">t5</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Multiplication done time taken &#39;</span><span class="p">,</span> <span class="n">t5</span><span class="o">-</span><span class="n">t4</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">t4</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing the reflection coefficients.&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="n">Rper</span><span class="o">=</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">ctht</span><span class="p">)</span><span class="o">.</span><span class="n">truediv_withind</span><span class="p">(</span><span class="n">S1</span><span class="o">+</span><span class="n">ctht</span><span class="p">,</span><span class="n">ind</span><span class="p">)</span>                        <span class="c1"># Compute the Reflection coeficient perpendicular</span>
                                                  <span class="c1"># to the polarisiation Rper=(Zm/Z0cos(theta_i)-cos(theta_t))/(Zm/Z0cos(theta_i)+cos(theta_t))</span>

  <span class="n">Rpar</span><span class="o">=</span><span class="p">(</span><span class="n">cthi</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">.</span><span class="n">truediv_withind</span><span class="p">(</span><span class="n">cthi</span><span class="o">+</span><span class="n">S2</span><span class="p">,</span><span class="n">ind</span><span class="p">)</span>                        <span class="c1"># Compute the Reflection coeficient parallel</span>
                                                  <span class="c1"># to the polarisiation Rpar=(cos(theta_i)-Zm/Z0cos(theta_t))/(cos(theta_i)+Zm/Z0cos(theta_t))</span>
  <span class="n">t6</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Reflection coefficients found, time taken &#39;</span><span class="p">,</span> <span class="n">t6</span><span class="o">-</span><span class="n">t5</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">t5</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Total time to compute reflection coefficients from Mesh &#39;</span><span class="p">,</span> <span class="n">t6</span><span class="o">-</span><span class="n">t0</span><span class="p">)</span>
  <span class="k">del</span> <span class="n">t6</span><span class="p">,</span> <span class="n">t0</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;----------------------------------------------------------&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">Rper</span><span class="p">,</span> <span class="n">Rpar</span><span class="p">,</span> <span class="n">ind</span></div>

<div class="viewcode-block" id="parnonzero"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.parnonzero">[docs]</a><span class="k">def</span> <span class="nf">parnonzero</span><span class="p">(</span><span class="n">nj</span><span class="p">,</span><span class="n">DS</span><span class="p">):</span>
  <span class="sd">&#39;&#39;&#39; Parallel version of a program with a dummy DS and a function for \</span>
<span class="sd">  finding the indices of the nonzero terms in a mesh.</span>

<span class="sd">  :param nj: number of processes.</span>
<span class="sd">  :param DS: the mesh</span>

<span class="sd">  Pool the nj processes</span>
<span class="sd">  Specify what needs to be done.</span>
<span class="sd">  Combine the information.</span>

<span class="sd">  :return: 5xn array which n is the number of nonzero terms.</span>

<span class="sd">  &#39;&#39;&#39;</span>
  <span class="n">x</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">DS</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">y</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">DS</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">z</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">DS</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">coords</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>
  <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">nj</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>         <span class="c1"># start nj worker processes</span>
    <span class="c1"># prints &quot;[0, 1, 4,..., 81]&quot;</span>
    <span class="n">ind</span><span class="o">=</span><span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">DS</span><span class="o">.</span><span class="n">nonzeroMat</span><span class="p">,</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">DS</span><span class="o">.</span><span class="n">nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">DS</span><span class="o">.</span><span class="n">ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">DS</span><span class="o">.</span><span class="n">nz</span><span class="p">)))</span>
    <span class="c1">#it = pool.imap(f, range(10))</span>
    <span class="c1">#print(next(it))                     # prints &quot;0&quot;</span>
    <span class="c1">#print(next(it))                     # prints &quot;1&quot;</span>
    <span class="c1">#print(it.next(timeout=1))           # prints &quot;4&quot; unless your computer is *very* slow</span>
    <span class="c1">#result = pool.apply_async(time.sleep, (10,))</span>
    <span class="c1">#print(result.get(timeout=1))</span>
  <span class="c1">#p.start()</span>
  <span class="c1">#p.join</span>
  <span class="c1">#FIXME</span>
  <span class="c1"># print(ind)</span>
  <span class="k">return</span> <span class="mi">0</span></div>

<span class="c1">#=======================================================================</span>

<span class="c1"># TEST FUNCTIONS</span>

<span class="c1">#=======================================================================</span>

<span class="k">def</span> <span class="nf">test_00</span><span class="p">():</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">DS</span><span class="p">()</span>
  <span class="n">ds</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="n">j</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="c1">## Test creation of dictionary containing sparse matrices</span>
<span class="k">def</span> <span class="nf">test_01</span><span class="p">(</span><span class="n">Nx</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span><span class="n">Ny</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="n">Nz</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">na</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>

<span class="c1">##  test creation of matrix and adding on element</span>
<span class="k">def</span> <span class="nf">test_02</span><span class="p">(</span><span class="n">Nx</span><span class="o">=</span><span class="mi">7</span><span class="p">,</span><span class="n">Ny</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">Nz</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">na</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">nb</span><span class="o">=</span><span class="mi">6</span><span class="p">):</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
  <span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">2</span><span class="o">+</span><span class="mi">3</span><span class="n">j</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>

<span class="c1">## Test creation of diagonal sparse matrices contained in every position</span>
<span class="k">def</span> <span class="nf">test_03</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">):</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">a</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Nz</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">nb</span><span class="p">:</span>
      <span class="n">ds</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="nb">complex</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ds</span>

<span class="c1">## Test creation of first column sparse matrices contained in every position</span>
<span class="k">def</span> <span class="nf">test_03b</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">):</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">,</span><span class="n">nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">a</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Nz</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">nb</span><span class="p">:</span>
      <span class="n">ds</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="nb">complex</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ds</span>

<span class="c1">## Test creation of lower triangular sparse matrices contained in every position</span>
<span class="k">def</span> <span class="nf">test_03c</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">):</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">a</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Nz</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">nb</span><span class="p">:</span>
      <span class="k">for</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">na</span><span class="p">):</span>
        <span class="n">ds</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">ai</span><span class="p">,</span><span class="n">a</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="nb">complex</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">a</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ds</span>

<span class="c1"># Test matrix addition operation</span>
<span class="k">def</span> <span class="nf">test_04</span><span class="p">():</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">test_03</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
  <span class="n">M</span><span class="o">=</span><span class="n">ds</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">M</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">return</span>

<span class="c1">##  Test get column</span>
<span class="k">def</span> <span class="nf">test_05</span><span class="p">():</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">test_03b</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:,</span><span class="mi">2</span><span class="p">])</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:])</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">6</span><span class="p">:</span><span class="mi">2</span><span class="p">,:])</span>
  <span class="k">return</span>

<span class="c1">## Test matrix multiplication</span>
<span class="k">def</span> <span class="nf">test_06</span><span class="p">():</span>
  <span class="n">ds1</span><span class="o">=</span><span class="n">test_03</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
  <span class="n">ds2</span><span class="o">=</span><span class="n">test_03b</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">)</span>
  <span class="n">M0</span><span class="o">=</span><span class="n">ds1</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ds2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">M1</span><span class="o">=</span><span class="n">ds1</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">ds2</span><span class="p">[</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">M0</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">M1</span><span class="p">)</span>
  <span class="k">return</span>

<span class="c1">## Test getting angle from complex entries in matrix</span>
<span class="k">def</span> <span class="nf">test_07</span><span class="p">():</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">test_03</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
  <span class="n">M0</span><span class="o">=</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">indices</span><span class="o">=</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">M0</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
  <span class="n">M1</span><span class="o">=</span> <span class="n">SM</span><span class="p">(</span><span class="n">M0</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
    <span class="n">M1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">M0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">M0</span><span class="p">,</span><span class="n">M1</span><span class="p">)</span>
  <span class="k">return</span>

<span class="c1">## Test getting angle from complex entries in matrix then taking the cosine of every nonzero entry</span>
<span class="k">def</span> <span class="nf">test_08</span><span class="p">():</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">test_03</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
  <span class="n">M0</span><span class="o">=</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">indices</span><span class="o">=</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">M0</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
  <span class="n">M1</span><span class="o">=</span> <span class="n">SM</span><span class="p">(</span><span class="n">M0</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
    <span class="n">M1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">M0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]))</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">M0</span><span class="p">,</span><span class="n">M1</span><span class="p">)</span>
  <span class="k">return</span>

<span class="c1">## test operation close to Fresnel reflection formula</span>
<span class="c1"># On the [0,0,0] matrix in the DS</span>
<span class="c1"># N1=Z1*cos(thetai)-Z2*cos(thetat)</span>
<span class="c1"># N2=Z1*cos(thetai)+Z2*cos(thetat)</span>
<span class="c1"># \todo N1/N2</span>
<span class="k">def</span> <span class="nf">test_09</span><span class="p">():</span>
  <span class="n">obs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">2.0</span><span class="p">,</span><span class="mf">3.0</span><span class="p">])</span>
  <span class="n">obs</span><span class="o">=</span><span class="n">obs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">test_03</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
  <span class="n">M0</span><span class="o">=</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">indices</span><span class="o">=</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">M0</span><span class="o">.</span><span class="n">nonzero</span><span class="p">())</span>
  <span class="n">M1</span><span class="o">=</span> <span class="n">SM</span><span class="p">(</span><span class="n">M0</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
  <span class="n">M2</span><span class="o">=</span> <span class="n">SM</span><span class="p">(</span><span class="n">M0</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">:</span>
    <span class="n">M1</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">M0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]))</span>
    <span class="n">M2</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">0.7</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">M0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]))</span>
  <span class="n">N1</span><span class="o">=</span><span class="n">M1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">obs</span><span class="o">-</span><span class="n">M2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
  <span class="n">N2</span><span class="o">=</span><span class="n">M1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">obs</span><span class="o">+</span><span class="n">M2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">N1</span><span class="p">)</span> <span class="c1"># next step [N1.nonzero()]) #/(N2[N2.nonzero()]))</span>

<span class="c1">##  Multiply by coefficient and sum the nonzero terms in the columns</span>
<span class="c1"># On the [0,0,0] matrix of the DS</span>
<span class="k">def</span> <span class="nf">test_10</span><span class="p">():</span>
  <span class="n">refcoef</span><span class="o">=</span><span class="n">test_09</span><span class="p">()</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">test_03b</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
  <span class="n">M0</span><span class="o">=</span><span class="n">ds</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
  <span class="n">M0</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">M0</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">refcoef</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
  <span class="n">indices</span><span class="o">=</span><span class="n">M0</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
  <span class="n">field</span><span class="o">=</span><span class="mf">1.0</span> <span class="c1">#np.zeros(M0.shape[1],1)</span>
  <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
      <span class="n">field</span><span class="o">*=</span><span class="nb">abs</span><span class="p">(</span><span class="n">M0</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
  <span class="k">return</span> <span class="mi">0</span>

<span class="c1">## Extract reflection angles from DS</span>
<span class="k">def</span> <span class="nf">test_11</span><span class="p">():</span>
  <span class="n">Nx</span><span class="o">=</span><span class="mi">1</span>
  <span class="n">Ny</span><span class="o">=</span><span class="mi">1</span>
  <span class="n">Nz</span><span class="o">=</span><span class="mi">1</span>
  <span class="n">na</span><span class="o">=</span><span class="mi">1000</span>
  <span class="n">nb</span><span class="o">=</span><span class="mi">1000</span>
  <span class="n">DSM</span><span class="o">=</span><span class="n">test_03c</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Nz</span><span class="p">)):</span>
      <span class="n">M</span><span class="o">=</span><span class="n">DSM</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span>
      <span class="n">AngM</span><span class="o">=</span><span class="n">sparse_angles</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
  <span class="c1">#print(AngM)</span>
  <span class="k">return</span> <span class="n">AngM</span>

<span class="c1">## Extract the cos of the reflection angles of the DS</span>
<span class="k">def</span> <span class="nf">test_12</span><span class="p">():</span>
  <span class="n">Nx</span><span class="o">=</span><span class="mi">2</span>
  <span class="n">Ny</span><span class="o">=</span><span class="mi">2</span>
  <span class="n">Nz</span><span class="o">=</span><span class="mi">1</span>
  <span class="n">na</span><span class="o">=</span><span class="mi">3</span>
  <span class="n">nb</span><span class="o">=</span><span class="mi">3</span>
  <span class="n">DSM</span><span class="o">=</span><span class="n">test_03c</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Nz</span><span class="p">)):</span>
      <span class="n">M</span><span class="o">=</span><span class="n">DSM</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span>
      <span class="n">indices</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
      <span class="n">CosAngM</span><span class="o">=</span><span class="n">SM</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
      <span class="n">CosAngM</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">sparse_angles</span><span class="p">(</span><span class="n">M</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">CosAngM</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">CosAngM</span>

<span class="c1">## Attempt to find angle of nonzero element of SM inside dictionary</span>
<span class="k">def</span> <span class="nf">test_13</span><span class="p">():</span>
  <span class="n">Nx</span><span class="o">=</span><span class="mi">2</span>
  <span class="n">Ny</span><span class="o">=</span><span class="mi">2</span>
  <span class="n">Nz</span><span class="o">=</span><span class="mi">1</span>
  <span class="n">na</span><span class="o">=</span><span class="mi">3</span>
  <span class="n">nb</span><span class="o">=</span><span class="mi">3</span>
  <span class="n">DSM</span><span class="o">=</span><span class="n">test_03c</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
  <span class="n">ang</span><span class="o">=</span><span class="n">dict_sparse_angles</span><span class="p">(</span><span class="n">DSM</span><span class="p">)</span>
  <span class="k">return</span> <span class="mi">1</span>

<span class="c1">## Attempt to compute Reflection Coefficents on DS</span>
<div class="viewcode-block" id="test_14"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.test_14">[docs]</a><span class="k">def</span> <span class="nf">test_14</span><span class="p">():</span>
  <span class="sd">&#39;&#39;&#39; This is a test of the reflection coefficient function.</span>
<span class="sd">  It sets test versions for the input parameters required and fills a DS \</span>
<span class="sd">  with dummy values.</span>
<span class="sd">  It then computes the reflection coefficients associated with those \</span>
<span class="sd">  dummy parameters and values.</span>
<span class="sd">  &#39;&#39;&#39;</span>
  <span class="n">Nre</span><span class="o">=</span><span class="mi">2</span>                                        <span class="c1"># Number of reflections</span>
  <span class="n">Nob</span><span class="o">=</span><span class="mi">12</span>                                       <span class="c1"># The Number of obstacle.</span>
  <span class="n">Nra</span><span class="o">=</span><span class="mi">20</span>                                     <span class="c1"># Number of rays</span>
  <span class="n">na</span><span class="o">=</span><span class="n">Nob</span><span class="o">*</span><span class="n">Nre</span><span class="o">+</span><span class="mi">1</span>                                 <span class="c1"># Number of rows in each SM in the DS</span>
  <span class="n">nb</span><span class="o">=</span><span class="n">Nre</span><span class="o">*</span><span class="n">Nra</span><span class="o">+</span><span class="mi">1</span>                                 <span class="c1"># Number of columns in each SM in the DS</span>
  <span class="n">Nx</span><span class="o">=</span><span class="mi">5</span>                                         <span class="c1"># Number of x spaces</span>
  <span class="n">Ny</span><span class="o">=</span><span class="mi">5</span>
  <span class="n">Nz</span><span class="o">=</span><span class="mi">5</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">test_03c</span><span class="p">(</span> <span class="n">Nx</span> <span class="p">,</span> <span class="n">Ny</span> <span class="p">,</span> <span class="n">Nz</span> <span class="p">,</span> <span class="n">na</span> <span class="p">,</span> <span class="n">nb</span> <span class="p">)</span>         <span class="c1"># test_03() initialises a</span>
                                               <span class="c1"># DSM with values on the</span>
                                               <span class="c1"># diagonal of each mesh element</span>
  <span class="n">mur</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">Nob</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="nb">complex</span><span class="p">(</span><span class="mf">3.0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>         <span class="c1"># For this test mur is</span>
                                               <span class="c1"># the same for every obstacle.</span>
                                               <span class="c1"># Array created to get functions correct.</span>
  <span class="n">epsr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">Nob</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="nb">complex</span><span class="p">(</span><span class="mf">2.9493</span><span class="p">,</span> <span class="mf">0.1065</span><span class="p">))</span>         <span class="c1"># For this test epsr is the</span>
                                               <span class="c1"># same for every obstacle</span>
  <span class="n">sigma</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">Nob</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="mi">0</span><span class="p">)</span>                <span class="c1"># For this test sigma is the</span>
                                               <span class="c1"># same for every obstacle</span>

  <span class="c1"># PHYSICAL CONSTANTS</span>
  <span class="n">mu0</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">1</span><span class="n">E</span><span class="o">-</span><span class="mi">6</span>
  <span class="n">c</span><span class="o">=</span><span class="mf">2.99792458E+8</span>
  <span class="n">eps0</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">mu0</span><span class="o">*</span><span class="n">c</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="c1">#8.854187817E-12</span>
  <span class="n">Z0</span><span class="o">=</span><span class="p">(</span><span class="n">mu0</span><span class="o">/</span><span class="n">eps0</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="c1">#120*np.pi Characteristic impedance of free space.</span>

  <span class="c1"># CALCULATE PARAMETERS</span>
  <span class="n">frequency</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">2.79E+08</span>                   <span class="c1"># 2.43 GHz</span>
  <span class="n">top</span><span class="o">=</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">frequency</span><span class="o">*</span><span class="n">mu0</span><span class="p">)</span><span class="o">*</span><span class="n">mur</span>
  <span class="n">bottom</span><span class="o">=</span><span class="n">sigma</span><span class="o">+</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">eps0</span><span class="o">*</span><span class="n">frequency</span><span class="p">)</span><span class="o">*</span><span class="n">epsr</span>
  <span class="n">Znob</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">top</span><span class="o">/</span><span class="n">bottom</span><span class="p">)</span>                    <span class="c1"># Wave impedance of the obstacles</span>
  <span class="k">del</span> <span class="n">top</span><span class="p">,</span> <span class="n">bottom</span>
  <span class="n">Znob</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">Znob</span><span class="p">,</span><span class="n">Nre</span><span class="p">)</span>                      <span class="c1"># The number of rows is Nob*Nre+1. Repeat Nob</span>
  <span class="n">Znob</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Znob</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">complex</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">))</span>     <span class="c1"># Use a zero for placement in the LOS row</span>
  <span class="c1">#Znob=np.transpose(np.tile(Znob,(Nb,1)))    # Tile the obstacle coefficient number to be the same size as a mesh array.</span>
  <span class="n">Znobrat</span><span class="o">=</span><span class="n">Znob</span><span class="o">/</span><span class="n">Z0</span>
  <span class="n">refindex</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">mur</span><span class="p">,</span><span class="n">epsr</span><span class="p">))</span>     <span class="c1"># Refractive index of the obstacles</span>
  <span class="n">refindex</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">refindex</span><span class="p">,</span><span class="n">Nre</span><span class="p">)</span>
  <span class="n">refindex</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">refindex</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

  <span class="n">Rper</span><span class="p">,</span><span class="n">Rpar</span><span class="o">=</span><span class="n">ref_coef</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span><span class="n">Znobrat</span><span class="p">,</span><span class="n">refindex</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">Rper</span><span class="p">,</span><span class="n">Rpar</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">Rper</span></div>

<div class="viewcode-block" id="test_15"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.test_15">[docs]</a><span class="k">def</span> <span class="nf">test_15</span><span class="p">():</span>
  <span class="sd">&#39;&#39;&#39; Testing multiplying nonzero terms in columns &#39;&#39;&#39;</span>
  <span class="n">DS</span><span class="o">=</span><span class="n">test_14</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">DS</span><span class="p">)</span>
  <span class="n">out</span><span class="o">=</span><span class="n">DS</span><span class="o">.</span><span class="n">dict_col_mult</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">out</span><span class="p">)</span>
  <span class="k">return</span></div>

<span class="c1">## Timing nonzero indexing</span>
<span class="k">def</span> <span class="nf">test_16</span><span class="p">():</span>
  <span class="n">Nob</span><span class="o">=</span><span class="mi">24</span>
  <span class="n">Nre</span><span class="o">=</span><span class="mi">3</span>
  <span class="n">Nra</span><span class="o">=</span><span class="mi">20</span>
  <span class="n">ktries</span><span class="o">=</span><span class="mi">20</span>
  <span class="n">narray</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ktries</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
  <span class="n">n</span><span class="o">=</span><span class="mi">2</span>
  <span class="n">timevec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ktries</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">ktries</span><span class="p">):</span>
    <span class="n">narray</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">n</span>
    <span class="n">DS</span><span class="o">=</span><span class="n">test_03</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">Nob</span><span class="o">*</span><span class="n">Nre</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nb">int</span><span class="p">((</span><span class="n">Nre</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Nra</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">t0</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">indices</span><span class="o">=</span><span class="n">DS</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">timevec</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">t0</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">timevec</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
    <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="o">*</span><span class="mi">2</span>
  <span class="n">mp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">timevec</span><span class="p">,</span><span class="n">narray</span><span class="p">)</span>
  <span class="n">mp</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Time against n for nonzero() function&#39;</span><span class="p">)</span>
  <span class="n">mp</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;timenonzero.png&#39;</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">timevec</span>

<span class="c1">## Attempting to parallelise nonzero function</span>
<div class="viewcode-block" id="test_17"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.test_17">[docs]</a><span class="k">def</span> <span class="nf">test_17</span><span class="p">():</span>
  <span class="sd">&#39;&#39;&#39; Test the :py:func:`parnonzero()` function which should find \</span>
<span class="sd">  nonzero() indices in parallel.</span>
<span class="sd">  &#39;&#39;&#39;</span>
  <span class="n">Nob</span><span class="o">=</span><span class="mi">3</span>
  <span class="n">Nre</span><span class="o">=</span><span class="mi">3</span>
  <span class="n">Nra</span><span class="o">=</span><span class="mi">5</span>
  <span class="n">n</span><span class="o">=</span><span class="mi">10</span>
  <span class="n">nj</span><span class="o">=</span><span class="mi">4</span>
  <span class="n">DS</span><span class="o">=</span><span class="n">test_03</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">Nob</span><span class="o">*</span><span class="n">Nre</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="nb">int</span><span class="p">((</span><span class="n">Nre</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">Nra</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
  <span class="c1">#p = Process(target=nonzeroMat, args=(cor,DS))</span>
  <span class="n">out</span><span class="o">=</span><span class="n">parnonzero</span><span class="p">(</span><span class="n">nj</span><span class="p">,</span><span class="n">DS</span><span class="p">)</span>
  <span class="k">return</span></div>

<div class="viewcode-block" id="test_18"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.test_18">[docs]</a><span class="k">def</span> <span class="nf">test_18</span><span class="p">():</span>
  <span class="sd">&#39;&#39;&#39;Testing the save and load pickle functions. &#39;&#39;&#39;</span>
  <span class="n">Nre</span><span class="o">=</span><span class="mi">7</span>                                        <span class="c1"># Number of reflections</span>
  <span class="n">Nob</span><span class="o">=</span><span class="mi">12</span>                                       <span class="c1"># The Number of obstacle.</span>
  <span class="n">Nra</span><span class="o">=</span><span class="mi">100</span>                                      <span class="c1"># Number of rays</span>
  <span class="n">na</span><span class="o">=</span><span class="n">Nob</span><span class="o">*</span><span class="n">Nre</span><span class="o">+</span><span class="mi">1</span>                                 <span class="c1"># Number of rows in each SM in the DS</span>
  <span class="n">nb</span><span class="o">=</span><span class="n">Nre</span><span class="o">*</span><span class="n">Nra</span><span class="o">+</span><span class="mi">1</span>                                 <span class="c1"># Number of columns in each SM in the DS</span>
  <span class="n">Nx</span><span class="o">=</span><span class="mi">5</span>                                         <span class="c1"># Number of x spaces</span>
  <span class="n">Ny</span><span class="o">=</span><span class="mi">5</span>
  <span class="n">Nz</span><span class="o">=</span><span class="mi">10</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">test_03</span><span class="p">(</span> <span class="n">Nx</span> <span class="p">,</span> <span class="n">Ny</span> <span class="p">,</span> <span class="n">Nz</span> <span class="p">,</span> <span class="n">na</span> <span class="p">,</span> <span class="n">nb</span> <span class="p">)</span>         <span class="c1"># test_03() initialises a</span>
                                               <span class="c1"># DSM with values on the</span>
                                               <span class="c1"># diagonal of each mesh element</span>
  <span class="n">filename</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="s1">&#39;testDS&#39;</span><span class="p">)</span>
  <span class="n">ds</span><span class="o">.</span><span class="n">save_dict</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
  <span class="n">ds</span><span class="o">=</span><span class="n">load_dict</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
  <span class="k">return</span></div>

<div class="viewcode-block" id="test_19"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.test_19">[docs]</a><span class="k">def</span> <span class="nf">test_19</span><span class="p">():</span>
  <span class="sd">&#39;&#39;&#39; Test the :py:func:`nonzero_bycol(SM)` function.</span>
<span class="sd">  Initialise a dummy sparse matrix SM.</span>

<span class="sd">  In :py:func:`nonzero_bycol(SM)`:</span>
<span class="sd">    * Transpose the matrix.</span>
<span class="sd">    * Find the nonzero indices.</span>
<span class="sd">    * Swap the rows and columns in the indices.</span>
<span class="sd">    * Return the indices</span>

<span class="sd">  Check these match the nonzero terms in SM.</span>

<span class="sd">  :return: 0 if successful 1 if not.</span>
<span class="sd">  &#39;&#39;&#39;</span>
  <span class="n">na</span><span class="o">=</span><span class="mi">5</span>
  <span class="n">nb</span><span class="o">=</span><span class="mi">5</span>
  <span class="n">S</span><span class="o">=</span><span class="n">SM</span><span class="p">((</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">na</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nb</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span> <span class="p">:</span>
        <span class="n">S</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
  <span class="n">ind</span><span class="o">=</span><span class="n">nonzero_bycol</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
  <span class="n">n</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
  <span class="k">for</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">S</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">count</span><span class="p">],</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">count</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="k">return</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span> <span class="k">pass</span>
  <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="test_20"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.test_20">[docs]</a><span class="k">def</span> <span class="nf">test_20</span><span class="p">():</span>
  <span class="sd">&#39;&#39;&#39; Test the dict_col_mult() function.</span>
<span class="sd">  Use a dummy DS with each matrix upper triangular with the number in \</span>
<span class="sd">  every position the row.</span>
<span class="sd">  Check that the col_mult that comes out is the column number +1 \</span>
<span class="sd">  factorial.</span>
<span class="sd">  &#39;&#39;&#39;</span>
  <span class="n">Nx</span><span class="o">=</span><span class="mi">2</span>
  <span class="n">Ny</span><span class="o">=</span><span class="mi">2</span>
  <span class="n">Nz</span><span class="o">=</span><span class="mi">2</span>
  <span class="n">na</span><span class="o">=</span><span class="mi">5</span>
  <span class="n">nb</span><span class="o">=</span><span class="mi">5</span>
  <span class="n">D1</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nz</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">na</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="n">i</span> <span class="p">:</span>
          <span class="n">D1</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span>
  <span class="n">D2</span><span class="o">=</span><span class="n">D1</span><span class="o">.</span><span class="n">dict_col_mult</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nz</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nb</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">D2</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">1</span>
      <span class="k">else</span> <span class="p">:</span> <span class="k">pass</span>
  <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="test_21"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.test_21">[docs]</a><span class="k">def</span> <span class="nf">test_21</span><span class="p">():</span>
  <span class="sd">&#39;&#39;&#39;Test if the __get_rad__() function works.&#39;&#39;&#39;</span>
  <span class="n">Nx</span><span class="o">=</span><span class="mi">2</span>
  <span class="n">Ny</span><span class="o">=</span><span class="mi">2</span>
  <span class="n">Nz</span><span class="o">=</span><span class="mi">2</span>
  <span class="n">na</span><span class="o">=</span><span class="mi">5</span>
  <span class="n">nb</span><span class="o">=</span><span class="mi">5</span>
  <span class="n">D</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nz</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">na</span><span class="p">):</span>
      <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nb</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;=</span> <span class="n">i</span> <span class="p">:</span>
          <span class="n">D</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>
  <span class="n">R</span><span class="o">=</span><span class="n">D</span><span class="o">.</span><span class="n">__get_rad__</span><span class="p">()</span>
  <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">Nz</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nb</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&gt;</span><span class="n">epsilon</span> <span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
      <span class="k">else</span> <span class="p">:</span> <span class="k">pass</span>
  <span class="k">return</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="test_22"><a class="viewcode-back" href="../index.html#DictionarySparseMatrix.test_22">[docs]</a><span class="k">def</span> <span class="nf">test_22</span><span class="p">():</span>
  <span class="sd">&#39;&#39;&#39; Test the set_item() function for setting columns in a DSM &#39;&#39;&#39;</span>
  <span class="n">Nx</span><span class="o">=</span><span class="mi">3</span>
  <span class="n">Ny</span><span class="o">=</span><span class="mi">3</span>
  <span class="n">Nz</span><span class="o">=</span><span class="mi">3</span>
  <span class="n">na</span><span class="o">=</span><span class="mi">5</span>
  <span class="n">nb</span><span class="o">=</span><span class="mi">5</span>
  <span class="n">Mesh</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
  <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
  <span class="n">vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nb</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
  <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Nz</span><span class="p">)):</span>
    <span class="n">col</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">nb</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">):</span>
      <span class="n">Mesh</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">col</span><span class="p">]</span><span class="o">=</span><span class="n">count</span><span class="o">*</span><span class="n">vec</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
      <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
  <span class="k">if</span> <span class="n">Mesh</span><span class="o">.</span><span class="n">__self_eq__</span><span class="p">():</span>
    <span class="c1">#print(Mesh) #DEBUG</span>
    <span class="k">return</span> <span class="mi">1</span>
  <span class="n">count</span><span class="o">=</span><span class="mi">0</span>
  <span class="n">Mesh</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span><span class="n">Ny</span><span class="p">,</span><span class="n">Nz</span><span class="p">,</span><span class="n">na</span><span class="p">,</span><span class="n">nb</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">Nx</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Ny</span><span class="p">),</span><span class="nb">range</span><span class="p">(</span><span class="n">Nz</span><span class="p">)):</span>
    <span class="n">col</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">nb</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Mesh</span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">,:,</span><span class="n">col</span><span class="p">]</span><span class="o">=</span><span class="n">count</span><span class="o">*</span><span class="n">vec</span>
    <span class="n">count</span><span class="o">+=</span><span class="mi">1</span>
  <span class="k">if</span> <span class="n">Mesh</span><span class="o">.</span><span class="n">__self_eq__</span><span class="p">():</span>
    <span class="c1">#print(Mesh)</span>
    <span class="k">return</span> <span class="mi">1</span>
  <span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="mi">0</span></div>

<span class="k">def</span> <span class="nf">test_23</span><span class="p">():</span>
  <span class="n">Nra</span><span class="p">,</span><span class="n">Nre</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">L</span>    <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/Raytracing.npy&#39;</span><span class="p">)</span>
  <span class="n">Nra</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Nra</span><span class="p">)</span>
  <span class="n">Nre</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Nre</span><span class="p">)</span>
  <span class="n">Nob</span>            <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/Nob.npy&#39;</span><span class="p">)</span>

  <span class="c1">#PI.ObstacleCoefficients()</span>
  <span class="c1">##----Retrieve the antenna parameters--------------------------------------</span>
  <span class="n">Gt</span>            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/TxGains.npy&#39;</span><span class="p">)</span>
  <span class="n">freq</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/frequency.npy&#39;</span><span class="p">)</span>
  <span class="n">Freespace</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/Freespace.npy&#39;</span><span class="p">)</span>
  <span class="n">c</span>             <span class="o">=</span><span class="n">Freespace</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">khat</span>          <span class="o">=</span><span class="n">freq</span><span class="o">*</span><span class="n">L</span><span class="o">/</span><span class="n">c</span>
  <span class="n">lam</span>           <span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="n">freq</span>
  <span class="n">Antpar</span>        <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">khat</span><span class="p">,</span><span class="n">lam</span><span class="p">,</span><span class="n">L</span><span class="p">])</span>

  <span class="c1">##----Retrieve the Obstacle Parameters--------------------------------------</span>
  <span class="n">Znobrat</span>      <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/Znobrat.npy&#39;</span><span class="p">)</span>
  <span class="n">refindex</span>     <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/refindex.npy&#39;</span><span class="p">)</span>

  <span class="c1">##----Retrieve the Mesh--------------------------------------</span>
  <span class="n">meshname</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="s1">&#39;DSM&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Nra</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;Refs&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Nre</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;m.npy&#39;</span><span class="p">)</span>
  <span class="n">Mesh</span><span class="o">=</span> <span class="n">load_dict</span><span class="p">(</span><span class="n">meshname</span><span class="p">)</span>
  <span class="n">ind</span><span class="o">=</span><span class="n">Mesh</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
  <span class="n">AngDSM</span><span class="o">=</span><span class="n">Mesh</span><span class="o">.</span><span class="n">sparse_angles</span><span class="p">()</span>

  <span class="n">ctht</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Initialise a DSM which will be cos(theta_t) #FIXME</span>
  <span class="n">SIN</span><span class="o">=</span><span class="n">AngDSM</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
  <span class="n">Div</span><span class="o">=</span><span class="n">SIN</span><span class="o">.</span><span class="n">dict_DSM_divideby_vec_withind</span><span class="p">(</span><span class="n">refindex</span><span class="p">,</span><span class="n">ind</span><span class="p">)</span>             <span class="c1"># Divide each column in DSM with refindex elementwise. Set any 0 term to 0.</span>
  <span class="n">ctht</span><span class="o">=</span><span class="n">Div</span><span class="o">.</span><span class="n">cos_asin</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ctht</span>

<span class="k">def</span> <span class="nf">test_24</span><span class="p">():</span>
  <span class="n">Nra</span><span class="p">,</span><span class="n">Nre</span><span class="p">,</span><span class="n">h</span><span class="p">,</span><span class="n">L</span>    <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/Raytracing.npy&#39;</span><span class="p">)</span>
  <span class="n">Nra</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Nra</span><span class="p">)</span>
  <span class="n">Nre</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">Nre</span><span class="p">)</span>
  <span class="n">Nob</span>            <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/Nob.npy&#39;</span><span class="p">)</span>

  <span class="c1">#PI.ObstacleCoefficients()</span>
  <span class="c1">##----Retrieve the antenna parameters--------------------------------------</span>
  <span class="n">Gt</span>            <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/TxGains.npy&#39;</span><span class="p">)</span>
  <span class="n">freq</span>          <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/frequency.npy&#39;</span><span class="p">)</span>
  <span class="n">Freespace</span>     <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/Freespace.npy&#39;</span><span class="p">)</span>
  <span class="n">c</span>             <span class="o">=</span><span class="n">Freespace</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
  <span class="n">khat</span>          <span class="o">=</span><span class="n">freq</span><span class="o">*</span><span class="n">L</span><span class="o">/</span><span class="n">c</span>
  <span class="n">lam</span>           <span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">c</span><span class="p">)</span><span class="o">/</span><span class="n">freq</span>
  <span class="n">Antpar</span>        <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">khat</span><span class="p">,</span><span class="n">lam</span><span class="p">,</span><span class="n">L</span><span class="p">])</span>

  <span class="c1">##----Retrieve the Obstacle Parameters--------------------------------------</span>
  <span class="n">Znobrat</span>      <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/Znobrat.npy&#39;</span><span class="p">)</span>
  <span class="n">refindex</span>     <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;Parameters/refindex.npy&#39;</span><span class="p">)</span>

  <span class="c1">##----Retrieve the Mesh--------------------------------------</span>
  <span class="n">meshname</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="s1">&#39;DSM&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Nra</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;Refs&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Nre</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;m.npy&#39;</span><span class="p">)</span>
  <span class="n">Mesh</span><span class="o">=</span> <span class="n">load_dict</span><span class="p">(</span><span class="n">meshname</span><span class="p">)</span>
  <span class="n">ind</span><span class="o">=</span><span class="n">Mesh</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
  <span class="n">AngDSM</span><span class="o">=</span><span class="n">Mesh</span><span class="o">.</span><span class="n">sparse_angles</span><span class="p">()</span>

  <span class="n">ctht</span><span class="o">=</span><span class="n">DS</span><span class="p">(</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Ny</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">Nz</span><span class="p">,</span><span class="n">Mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">Mesh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># Initialise a DSM which will be cos(theta_t) #FIXME</span>
  <span class="n">ctht</span><span class="o">=</span><span class="n">AngDSM</span><span class="o">.</span><span class="n">costhetat</span><span class="p">(</span><span class="n">refindex</span><span class="p">,</span><span class="n">ind</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">ctht</span>


<span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
  <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running  on python version&#39;</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">version</span><span class="p">)</span>
  <span class="c1">#job_server = pp.Server()</span>
  <span class="n">t1</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
  <span class="n">ctht</span><span class="o">=</span><span class="n">test_24</span><span class="p">()</span>
  <span class="n">t2</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">t2</span><span class="o">-</span><span class="n">t1</span><span class="p">)</span>
  <span class="n">ctht</span><span class="o">=</span><span class="n">test_23</span><span class="p">()</span>
  <span class="n">t3</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">t3</span><span class="o">-</span><span class="n">t2</span><span class="p">)</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s2">&quot;test_23()&quot;</span><span class="p">,</span><span class="n">setup</span><span class="o">=</span><span class="s2">&quot;from __main__ import test_23&quot;</span><span class="p">))</span>
  <span class="nb">print</span><span class="p">(</span><span class="n">timeit</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s2">&quot;test_24()&quot;</span><span class="p">,</span><span class="n">setup</span><span class="o">=</span><span class="s2">&quot;from __main__ import test_24&quot;</span><span class="p">))</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, Hayley.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
    </div>

    

    
  </body>
</html>